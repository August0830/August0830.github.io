<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021春季学期小结</title>
    <url>/post/bb9e0ca7/</url>
    <content><![CDATA[<blockquote>
<p>整理文件的时候发现于是发出来 其实是一个补档</p>
</blockquote>
<p>考完试了来回顾一下这一个学期我都在干什么。</p>
<p>考试周的时候感到非常空虚，总是沉迷于阈值很高的娱乐而无所事事，经过一段时间才能调整适应并没有ddl追着打的日子。但是转念一想，在一个学期被ddl追着打的日子里，我又有什么收获呢? 乍一想好像还真没有。</p>
<p>翻开我的日程本，刚开学的三月份过的还是相当忙碌的。寒假结束了STEP项目的申请（失败）和美赛，马不停蹄的又开始参加shopee的比赛以及准备gsoc。</p>
<p>shopee的比赛纯属被大佬带飞，我也认识到自己并不适合短时间突击某个技术模块，厚积薄发才是王道。（尤其是在美赛结果出来以后更是印证了这一点）。</p>
<p>gsoc虽然最终落选，但是在准备的过程中啃了一篇论文以及工程级别的源代码，认识到做研究和做工业的不同。做研究需要独创性，并且需要证明自己的方法有效，至于代码实现，只是作为证明的一部分。同时打破心理舒适区，拓展了一下自己的能力边界，看懂全英文的论文，搞明白代码的互相依赖关系并不是不可能的！</p>
<p>之后就是连着的面试。STEP的惨痛教训另外写过。面腾讯和微软的时候基础知识和算法不够扎实，不出意外的挂了。5月份学期快结束的时候，面字节因为对方不愿意收大二的也挂了。还有一个量化的岗位因为时间不合适我被我拒了面试机会。通过一连串的面试，虽然没有获得996的机会<del>（不是</del>，但是多少了解了自己的不足以及接下来弥补的方向。同时在这期间，学会了如何大胆的请教前辈以及利用connection争取机会。</p>
<p>另外有一个NUS的summer camp出于财务问题被我残忍拒绝了。经此一役确认接下来留学的打算估计要推到自己攒够钱之后了。家里能够提供的支持是有限的，我也不忍心再让父母掏钱。</p>
<p>获得这样的结果我并不意外，并不能算是有顶级天赋又没有下定决心狠狠努力的我显然并不能苛求太多。从另一个角度说，失败是成功的逆位，通过排除自己目前不能做到什么，可以为接下来的假期敲响警钟。</p>
<p>课外活动的丰富尝（shi）试（bai）来源于上个学期无所事事的教训。但是在课外也一无所成的情况下，似乎乍一看是没有任何收获的。这可能是源于我高中一贯以来的思维：大家都做了就等于都没做。但是显然，在有限的时间内，课内的实践也应当成为宝贵的经历。至少在努力过后要有所提炼，有所感悟。</p>
<p>从这个角度看高程无疑是门好课，至少有个植物大战僵尸可以放在主页上。计网学到的东西也不少，除了python的基础语法之外还有一些计网关键部件的运行。算法更不必说，以前看不懂的题解现在至少知道思路了，也为假期刷题打下了理论基础。os真的最让人无语，因为实验手册实在太难搞，水过lab以后留下印象的并不多，打算假期至少补一补关于文件系统的pa作业。</p>
<p>综上，假期的计划是在倒计时的激励下，考过GRE，同时突击巩固口语。把一时兴起的编程任务做一做，比如对防弹1011后的舆论数据分析，一个截图小插件，FAT文件系统，自己的个人网站等等。同时刷刷题，弥补不足。</p>
]]></content>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>2021暑假小结</title>
    <url>/post/f7e510c4/</url>
    <content><![CDATA[<h2 id="目标与效果对照"><a href="#目标与效果对照" class="headerlink" title="目标与效果对照"></a>目标与效果对照</h2><p>假期前列出了以下to do：（按照重要性排序）</p>
<ul>
<li><p>准备GRE 9月开学即考试</p>
</li>
<li><p>完成操作系统课上的PA：FAT12文件系统</p>
</li>
<li><p>搭建博客</p>
</li>
<li><p>leetcode习题积累</p>
</li>
<li><p>自学爬虫 解决一些感兴趣的数据分析话题</p>
</li>
<li><p>收集信息</p>
</li>
<li><p>把借来的书读完（世界史系列8本 北欧神话 二战系列2本 说服与不被说服的艺术 20世纪简史）</p>
</li>
</ul>
<p>实际完成的情况：</p>
<ul>
<li>GRE<ul>
<li>在假期背完了学期间的GRE单词<ul>
<li>粗略过了一遍 做题过程中高频词不够熟悉</li>
</ul>
</li>
<li>Issue 写作5篇，分析6篇 和Arguement 5篇写作<ul>
<li>有大致的思路框架 但是几天不写会模糊</li>
<li>能够表达 但是打字速度和用词需要继续加强</li>
</ul>
</li>
<li>选词 linduxi做了两遍，高频合集做到20+<ul>
<li>与最开始相比能够分析句子</li>
<li>词汇量需要加强</li>
</ul>
</li>
<li>阅读 中间20~30题做了两次 目前到约40题<ul>
<li>能够断长难句 理清逻辑</li>
<li>词汇量和长难文有待提高</li>
</ul>
</li>
<li>数学 专题还差概率部分<ul>
<li>只做了第一遍 需要复习错题和总结技巧</li>
</ul>
</li>
</ul>
</li>
<li>FAT12<ul>
<li>完成了基本的框架代码并且同步到了github上 博客同步更新</li>
<li>但是有bug没有调试完</li>
</ul>
</li>
<li>搭建博客：网站已经可以正常运行 包括评论 tag 收录到搜索引擎<ul>
<li>反复更换心仪的主题 调试比较花时间</li>
</ul>
</li>
<li>Leetcode 100题没有做完，做了一半这样，只要当天在学习就尽量做题<ul>
<li>至少每天一题 偶尔有几次能够在玩耍完回家后随手来一题</li>
</ul>
</li>
<li>读书：读完了《说服与不被说服的艺术 》世界史2本 北欧神话 （都没有更新读书笔记）</li>
</ul>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>最大的问题是作息 1点~3点睡 10~12点起成为常态导致一整个上午直接报废，下午的效率比较高 晚上基本在放松躺平</p>
<p>因为一直在熬夜，所以也不敢运动。关键是到点就休息 维持良好的作息才会有更多的自由时间</p>
<p>其次是不太紧张，虽然开了倒计时但是对于没有明确时间节点的任务经常会因为赖床往后推。在GRE考试延期以后连最开始坚持的GRE刷题也松懈了。</p>
<p>因为在家放假，休息时间很容易失控。应当用温和平静的放松方式代替玩手机，避免一次上头忘乎所以。</p>
<p>假期生活也有做得好的地方，比如：在准备GRE的过程中，发现先探索再调整计划，比担忧能否完成计划更有利于身心健康。</p>
<p>leetcode也渐渐做出手感，希望一天一题至少能保持下去</p>
<h2 id="新学期的展望"><a href="#新学期的展望" class="headerlink" title="新学期的展望"></a>新学期的展望</h2><p>第一，利用在家的时间 把书看完（忙里偷闲的时候看书效率更高！）</p>
<p>第二， leetcode 和GRE保持，leetcode每日一题，GRE采用写作+选词/数学+阅读之类搭配的方式保持练习量直到回校）巩固高频单词 可以利用好早八之前的时间 </p>
<p> 第三，恢复锻炼。利用好下午课程后的时间还有闲置的瑜伽垫进行复检</p>
<p> <em>Make hay while the sun shines</em></p>
]]></content>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>2021秋开学前鸡汤</title>
    <url>/post/d050af8b/</url>
    <content><![CDATA[<p>开学前在西西弗随手翻了两本书，因此做一个读书笔记与反思调整。</p>
<h2 id="如何成为一个会学习的人"><a href="#如何成为一个会学习的人" class="headerlink" title="如何成为一个会学习的人"></a>如何成为一个会学习的人</h2><p>从学习当中发现乐趣</p>
<blockquote>
<p>比如说做GRE阅读题的时候发现自己能够准确梳理文章逻辑，享受抽丝剥茧的乐趣</p>
</blockquote>
<p>设置简单的反馈目标</p>
<blockquote>
<p>不仅是肯定自己完成了某件事，还应当肯定自己从中学到了什么</p>
</blockquote>
<p>遇到困难先做一点点</p>
<blockquote>
<p>比如说不想看书的时候先尝试看5页 或者遇到代码题先考虑分析一下思路再看解析</p>
</blockquote>
<p>重点是投入</p>
<blockquote>
<p>及时隔离包括手机在内的各种干扰源，如果有玩耍的念头 想想无数个恨铁不成钢的时刻，以及投入之后心流的愉悦</p>
</blockquote>
<p>可以对目标先妥协 只要坚持下去</p>
<blockquote>
<p>并不是每次都能准确的预估目标，及时改进比懊恼更有用</p>
</blockquote>
<p>回顾</p>
<ul>
<li>每1 2页回顾一次</li>
<li>每个项目回顾一次每章回顾一次</li>
</ul>
<blockquote>
<p>看书的时候回顾之后要及时回到书本本身 不然容易半途而废</p>
<p>在学习过程中可以利用周末的时间做简单的梳理，上课觉得讲的慢或者不想听的时候也可以利用康奈尔笔记</p>
</blockquote>
<p>散步</p>
<ul>
<li>活动一下 走新的路 </li>
<li>不要路上玩手机 </li>
<li>走20min以上</li>
</ul>
<p>听音乐进入状态 进入状态就可以关掉了</p>
<blockquote>
<p>歪打正着的在上个学期期末非常懒惰不想复习的情况下使用了这个方法 不过注意保护耳朵</p>
</blockquote>
<p>自问自答 可以用录音的方式强化</p>
<blockquote>
<p>比如一些面试问答题 以及背单词</p>
</blockquote>
<p>睡前复习 一页A4纸记录 </p>
<ul>
<li>具体问题或者索引 </li>
<li>可以强化不懂的东西 当然也可以放到第二天再解决</li>
</ul>
<blockquote>
<p>可以作为睡前放松的一种方式 也可以用来避免第二天早上难以进入状态 毕竟还有事情需要解决</p>
</blockquote>
<p>在有成果的时候播放音效激励自己<br>边走路边背书<br>速读 母语+外语</p>
<blockquote>
<p>这个方法应该可以大大提高阅读课外书的速度 虽然目前速度会出现读漏信息的情况，但是也可以帮助我有意识的锻炼按照自己的思维重组内容的能力</p>
</blockquote>
<p>细化学习成果的记录。</p>
<blockquote>
<p>不仅是做了什么 还有学到了什么</p>
</blockquote>
<p>保持专注的三个要求</p>
<ul>
<li>可以控制</li>
<li> 快速反馈 </li>
<li>保持平衡：目标与能力之间的匹配度</li>
</ul>
<p>想办法享受学习</p>
<blockquote>
<p>同上，从学习中找到掌握感和满足感 </p>
</blockquote>
<p>要赚回 成本</p>
<blockquote>
<p>比如说GRE交了钱当然要好好学习</p>
</blockquote>
<p>一些可以采用的学习方法</p>
<ul>
<li>多元思维模型<ul>
<li>具体还需要阅读更多书籍</li>
</ul>
</li>
<li>费曼学习法<ul>
<li>通过写博客来输出 如果时间不支持就在整章或者整本书结束之后写博客总结</li>
</ul>
</li>
<li>康奈尔5r笔记<ul>
<li>上课可以随手记</li>
</ul>
</li>
</ul>
<h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><p>二维的时间衡量尺度</p>
<ul>
<li>成果=专注力*时间</li>
</ul>
<p>了解脑科学 把重要的事情放在早上<br>在疲惫之前休息</p>
<blockquote>
<p>把握好休息时间</p>
</blockquote>
<p>好好睡觉</p>
<p>提高效率 是为了留出更多休息/自由时间<br>专注时间 15 45 90</p>
<blockquote>
<p>意思是人的专注时间是以15min为单位的，可以按照这个周期来组织休息</p>
</blockquote>
<p>限制时间</p>
<blockquote>
<p>给自己的每一小段时间设置ddl 但是我的问题在于不肯及时抽身</p>
</blockquote>
<p>早上效率最高</p>
<p>起床以后：</p>
<ul>
<li><p>睁着眼睛不要睡</p>
</li>
<li><p>不要玩手机</p>
</li>
<li><p>一起来就利用好时间 学习新东西或者看书（背背单词也可以）<br>正式的一天开始前（书中指上班）的时间是自我充电的最佳时间</p>
</li>
</ul>
<blockquote>
<p>计划刷leetcode 或者读一小篇英语文章 或者背单词</p>
</blockquote>
<p>午饭时间</p>
<ul>
<li>出去走一走 </li>
<li>尝试新的菜式 细嚼慢咽。</li>
<li>午睡三十分钟 睡前喝茶或者咖啡</li>
</ul>
<p>下午</p>
<ul>
<li>穿插低消耗的工作</li>
<li>更换场景休息 </li>
</ul>
<p>高效休息</p>
<ul>
<li>不要玩手机 </li>
<li>也不要启动视觉 闭目养神或者走走 听音乐 正念</li>
</ul>
<p>规定离开的时间 “后有约定”</p>
<blockquote>
<p>不要为了工作/任务无限妥协 该休息的时候就休息</p>
</blockquote>
<p>运动可以提高效率 一周至少运动一次 但是不要太累</p>
<p>不要让压力和疲惫过夜 当天恢复不要压到周末</p>
<blockquote>
<p>所以需要养成读感兴趣的书这样平静的放松习惯 避免干扰正常的睡眠</p>
</blockquote>
<p>交流是一种很好的放松 尤其是面对面<br>重视休息 就像重视工作 不要加班</p>
<p>睡前两小时 放松下来才能保证睡眠</p>
<ul>
<li><p>不要高强度工作 </p>
</li>
<li><p>不要玩手机 </p>
</li>
<li><p>不要运动 </p>
</li>
<li><p>不要吃东西</p>
</li>
</ul>
<p>睡前1到2小时是记忆的黄金时间 应该多做些回顾（学习上小结） 记录有趣的事情（不管是基于sns还是日记）</p>
<blockquote>
<p>可以在睡前做一天的学习回顾 写日记</p>
</blockquote>
<p>利用周末</p>
<ul>
<li>睡懒觉也不要超过平常起床时间的两个小时 平常睡好好过补觉</li>
<li>越是疲惫越应该运动</li>
<li>互补休息法 在周末做和平常不一样的事情</li>
</ul>
<p>高效工作</p>
<ul>
<li>不是到什么为止 是什么时候做</li>
<li>能两分钟解决的事情就现在做</li>
</ul>
<p>并行做事 另外一件事一定要是低精力消耗的</p>
<ul>
<li>移动读书（携带电子书 有输出）</li>
<li>利用耳朵 听书听听力</li>
<li>边走边想</li>
</ul>
<p>自由时间</p>
<ul>
<li>投资自己 不仅仅是加班</li>
<li>主动娱乐<ul>
<li>读书是主动娱乐 有助于提高专注力 </li>
<li>玩手机是被动 会降低专注力</li>
<li>有时间再看—-拖着拖着就不想看了<br>带着目的去做</li>
<li>专注工作和专注于娱乐本质是一样的</li>
</ul>
</li>
</ul>
<blockquote>
<p>深有同感 反复切换无法享受会拉高感到快乐的阈值 </p>
</blockquote>
<p>把玩乐写成todo 避免纠结</p>
<blockquote>
<p>面对浩如烟海的追星物料我是这样做的</p>
</blockquote>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>AW07-Event Driven Architecture</title>
    <url>/post/8f0f1e10/</url>
    <content><![CDATA[<p><a href="https://spring.io/projects/spring-cloud-stream">https://spring.io/projects/spring-cloud-stream</a></p>
<p><a href="https://github.com/sa-spring/stream-loan">https://github.com/sa-spring/stream-loan</a></p>
<p><a href="https://piotrminkowski.com/2020/06/05/introduction-to-event-driven-microservices-with-spring-cloud-stream/">https://piotrminkowski.com/2020/06/05/introduction-to-event-driven-microservices-with-spring-cloud-stream/</a></p>
<h1 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h1><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>添加orderService，配置好事件驱动</p>
<p>source/发送者用的是supplier，连续的发送事件，但是我的期望设计是由特定事件驱动，需要用到streamBridge.<a href="https://github.com/spring-cloud/spring-cloud-stream/blob/main/samples/confluent-schema-registry-integration/confluent-schema-registry-integration-producer1/src/main/java/sample/producer1/ConfluentAvroProducer1Application.java">参考</a></p>
<p>处理者也可以返回消息，需要使用consumer<a href="https://github.com/sa-spring/stream-loan/blob/main/loan-check/src/main/java/com/example/loan/check/LoanChecker.java">参考</a></p>
<p>测试</p>
<p>先测试事件驱动架构，在自动化生成请求的情况下；</p>
<p>测试pos-order和pos-delivery在有网页访问的情况下</p>
<p>测试由pos-cart驱动pos-order</p>
<h2 id="Tech-Solution"><a href="#Tech-Solution" class="headerlink" title="Tech Solution"></a>Tech Solution</h2><p>伪代码+配置文件</p>
<h4 id="pos-order"><a href="#pos-order" class="headerlink" title="pos-order"></a>pos-order</h4><ul>
<li><p>配置文件</p>
<p>copy pos-cart</p>
<p>spring.io 生成一个micro service文件</p>
<p>作为微服务的配置/discovery配置/gateaway配置/</p>
<p><strong>cloudstream 配置 ???</strong></p>
<p>直接去掉？</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">function:</span></span><br><span class="line">      <span class="attr">definition:</span> <span class="string">placeOrder</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">function:</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">deliver-order:</span> <span class="string">String</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">loan:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">output</span></span><br></pre></td></tr></table></figure></li>
<li><p>补充api</p>
<ul>
<li>openApi中在responses<a href="https://blog.csdn.net/weixin_39853892/article/details/111127663">使用基本类型的方法</a></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">/order/place</span></span><br><span class="line"><span class="attr">post:</span></span><br><span class="line">	<span class="attr">sumary:</span> <span class="string">place</span> <span class="string">an</span> <span class="string">order</span></span><br><span class="line">	<span class="attr">operationId:</span> <span class="string">placeOrder</span></span><br><span class="line">	<span class="attr">tags:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">order</span></span><br><span class="line">	<span class="attr">requestBody:</span></span><br><span class="line">		<span class="attr">description:</span> <span class="string">order</span> <span class="string">info</span></span><br><span class="line">		<span class="attr">content:</span></span><br><span class="line">			<span class="attr">application/json:</span></span><br><span class="line">				<span class="attr">schema:</span></span><br><span class="line">					<span class="attr">type:</span> <span class="string">string</span></span><br><span class="line">		<span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">	<span class="attr">responses:</span></span><br><span class="line">		<span class="attr">&#x27;200&#x27;:</span></span><br><span class="line">			<span class="attr">description:</span> <span class="string">Expected</span></span><br><span class="line">			<span class="attr">content:</span></span><br><span class="line">				<span class="attr">application/json:</span></span><br><span class="line">					<span class="attr">schema:</span></span><br><span class="line">						<span class="attr">type:</span> <span class="string">boolean</span></span><br><span class="line">		<span class="attr">default:</span></span><br><span class="line">			<span class="attr">description:</span> <span class="string">Unexpected</span></span><br><span class="line">			<span class="attr">content:</span></span><br><span class="line">				<span class="attr">application/json:</span></span><br><span class="line">					<span class="attr">schema:</span></span><br><span class="line">					 <span class="string">$ref:</span> <span class="string">&quot;#/components/schemas/Error&quot;</span></span><br></pre></td></tr></table></figure>

<p>//Info format: productA|productB|addr:CityA</p>
</li>
<li><p>rest </p>
<ul>
<li>restController implements OrdersApi</li>
<li>override method 调用service中方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">boolean</span>&gt; <span class="title">placeOrder</span><span class="params">(<span class="meta">@RequestBody</span> String orderInfo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> res = orderService.placeOrder(orderInfo);</span><br><span class="line">    <span class="keyword">if</span>(!res)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(res,HttpStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>service</p>
<ul>
<li><p>OrderService</p>
<ul>
<li>placeOrder</li>
</ul>
</li>
<li><p>OrderServiceImpl</p>
<ul>
<li>EDA-Impl</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">OrderServiceImp implements OrderService&#123;</span><br><span class="line">    StreamBridge streamBridge</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">placeOrder</span><span class="params">(String orderInfo)</span></span>&#123;</span><br><span class="line">        <span class="comment">//calculate number of products</span></span><br><span class="line">        <span class="keyword">for</span>(str : info)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.startsWith(<span class="string">&quot;addr:&quot;</span>))&#123;</span><br><span class="line">                addr = <span class="keyword">new</span> StringBuilder(str.substring(<span class="number">4</span>)).toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        String deliveryInfo = String.format(<span class="string">&quot;%d|%s&quot;</span>,cnt,addr);</span><br><span class="line">        <span class="keyword">return</span> streamBridge.send(<span class="string">&quot;deliver-order&quot;</span>,deliveryInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单向</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>postman跑不动：用curl来测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; -X POST -d &#x27;&#123;&quot;orderInfo&quot;:&quot;3|CityA&#125;&quot;&#x27; http://localhost:8085/api/order/place</span><br></pre></td></tr></table></figure>



<h4 id="pos-delivery"><a href="#pos-delivery" class="headerlink" title="pos-delivery"></a>pos-delivery</h4><ul>
<li><p>配置：类似loan-checker √</p>
<ul>
<li>application.yml</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">function:</span></span><br><span class="line">      <span class="attr">definition:</span> <span class="comment">#Consume方法名</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">function:</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">checkOrder-in-0:</span> <span class="string">receive</span></span><br><span class="line">          <span class="comment">#consumer方法名-in-0: 发送方send的首个参数</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">      	<span class="comment">#发送的消息名称 保持一致</span></span><br><span class="line">        <span class="attr">order-declined:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">order-declined</span></span><br><span class="line">        <span class="attr">order-approved:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">order-approved</span></span><br></pre></td></tr></table></figure></li>
<li><p>DeliveryApplication √</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main&#123;&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Consumer&lt;String&gt; <span class="title">deliverCart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CartDelivery();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CartDelivery  √</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CartDelivery implements Consumer&lt;String&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(CartDelivery.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StreamBridge streamBridge;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String info)</span></span>&#123;</span><br><span class="line">        <span class="comment">//number to calculate fee</span></span><br><span class="line">        String[] infos = info.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt = Integer.parseInt(infos[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">double</span> fee = <span class="number">1.25</span>*cnt;</span><br><span class="line">        String msg = String.format(<span class="string">&quot;deliver %d product(s) to %s,fee is %f&quot;</span>,cnt,infos[<span class="number">1</span>],fee);</span><br><span class="line">       	log.info(msg+<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">        streamBridge.send(<span class="string">&quot;delivery&quot;</span>,message(msg));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">Message&lt;T&gt; <span class="title">message</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MessageBuilder.withPayload(val).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进阶版：添加DeliveryInfo 记录重量和地区信息</p>
</li>
</ul>
<p>cart中添加用rest发送消息的controller方法 <a href="https://github.com/sawork-2022/aw05-caochun/blob/main/pos-carts/src/main/java/com/micropos/cart/service/CartServiceImpl.java">参考</a></p>
<p>在CartServiceImp：checkout方法中添加生成信息</p>
<p>todo：在vmware上做</p>
<p>discovery&amp;&amp;gateway能正常运转</p>
<p>其他微服务controller问题</p>
<p>cart中添加调用</p>
<h2 id="一些插曲——遇到的问题和解决措施"><a href="#一些插曲——遇到的问题和解决措施" class="headerlink" title="一些插曲——遇到的问题和解决措施"></a>一些插曲——遇到的问题和解决措施</h2><p>因为内存不足在另一台虚拟机上重配了环境，配置maven的时候需要<a href="https://stackoverflow.com/questions/57208665/oracle-jdk-11-error-occuring-every-time-i-install-anything-in-terminal">移除</a>旧的未成功安装的Java环J境并<a href="https://www.javafixing.com/2021/09/fixed-maven-crashes-when-trying-to.html">重新配置Java环境</a></p>
<p><a href="https://blog.csdn.net/xsj_blog/article/details/79531083">持久化javahome设置</a></p>
<p>export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/</p>
<p>/usr/local/src/java/jdk-18.0.1</p>
<p><a href="https://www.jianshu.com/p/afaa5e789f5c">springboot公共类打包成依赖</a> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=/home/avril/SA-2022/HW07/stream-loan/loan-model/target/loan-model-0.0.1.jar -DgroupId=com.example -DartifactId=loan-model -Dversion=0.0.1 -Dpackaging=jar</span><br></pre></td></tr></table></figure>

<p>换环境后<a href="https://blog.csdn.net/ksws0319440/article/details/113246070?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-113246070-blog-81251677.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-113246070-blog-81251677.pc_relevant_aa&utm_relevant_index=1">maven-compiler-plugin版本过高</a></p>
<p>rest-controller无法调用: </p>
<ul>
<li>api之后不需要写getMapping</li>
<li>扫描包</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
        <tag>Software Archetecture</tag>
      </tags>
  </entry>
  <entry>
    <title>AW08 Spring Integration</title>
    <url>/post/3da399b2/</url>
    <content><![CDATA[<p>delivery变成integration</p>
<p>大致思路：</p>
<p>aw07中的delivery不再作为微服务的一部分（去掉discovery和gateway配置）</p>
<p>pos-cart中添加发送消息的部分；发送的消息有load，字符串（与aw08样例中直接get不同）；添加接收</p>
<p>pos-delivery 保持不变</p>
<h2 id="Tech-Solution"><a href="#Tech-Solution" class="headerlink" title="Tech Solution"></a>Tech Solution</h2><ul>
<li>pos-order</li>
</ul>
<p>替换成改写demo中的inbound/outbound</p>
<p>inboud：处理发送来的post请求，提取string信息，调用placeOrder函数进行中间处理转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inboundGateway(uri)</span><br><span class="line">.requestMapping(r -&gt; r.methods(Https.POST)</span><br><span class="line">.consumes(&quot;text/plain&quot;))</span><br><span class="line">.&lt;String&gt;handle((s)-&gt; return placeOrder(s))</span><br><span class="line">.requestPayloadType(String.class)</span><br><span class="line">.get();</span><br></pre></td></tr></table></figure>

<p>中间处理<a href="https://www.tabnine.com/code/java/methods/org.springframework.integration.http.dsl.Http/inboundGateway">ref</a></p>
<p>outbound：向pos-delivery发送post请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">outboundGateway((Message&lt;String&gt; r)-&gt;r.getPayload())</span><br><span class="line">.httpMethod(Https.POST)</span><br><span class="line">.expectedResponseType(Boolean.type)</span><br><span class="line">.get();</span><br></pre></td></tr></table></figure>

<p>#注释 初步 handle是具体的处理函数，可以做简单的处理</p>
<p>method改动</p>
<ul>
<li><p>pos-delivery：</p>
<p>普通的网页应用 rest架构，参数使用和测试方法<a href="https://mkyong.com/spring/curl-post-request-examples/">参考</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &quot;orderInfo=3|CityA&quot; http://localhost:8086/delivery/</span><br></pre></td></tr></table></figure>

<p>采用了RequestParam</p>
</li>
<li><p>pos-cart</p>
</li>
</ul>
<p><img src="/post/3da399b2/.%5CAW08-Spring-Integration.assets%5Cimage-20220621094639379.png" alt="image-20220621094639379"></p>
<p><em>提问</em>：post传递参数和url中携带参数的不同？</p>
<p>Reference：</p>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/http/dsl/HttpInboundEndpointSupportSpec.RequestMappingSpec.html">consumes</a></p>
<p><a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/http/dsl/Http.html#method.detail">outboundGateway加参数</a></p>
<p>code <a href="https://stackoverflow.com/questions/56899730/how-to-send-http-request-from-my-integrationflow">ref1</a> <a href="https://www.tabnine.com/code/java/methods/org.springframework.integration.http.dsl.Http/inboundGateway">ref2</a></p>
<p>outbound中使用的流的类型<a href="https://docs.spring.io/spring-integration/api/org/springframework/integration/http/dsl/BaseHttpMessageHandlerSpec.html">BaseHttpMessageHandlerSpec</a></p>
<p><em>搜索关键词：intergrationflows inbound post</em></p>
<p>pos-order inbound 接收参数,</p>
<p><a href="https://github.com/sa-spring/spring-integration/blob/master/src/main/java/com/example/spring/integration/helloworld/HelloWorldApp.java">在函数中额外指定input/outputChannel</a>；<a href="https://github.com/sa-spring/spring-integration/blob/master/src/main/resources/META-INF/spring/integration/helloworld/helloWorldDemo.xml">xml配置</a></p>
<ul>
<li>引入channel配置</li>
</ul>
<p>AbstractApplicationContext context = new ClassPathXmlApplicationContext(xmlfile in resource,claassName);</p>
<ul>
<li>对inbound channel配置</li>
</ul>
<p><a href="https://stackoverflow.com/questions/50108253/http-outbound-gateway-post-with-payload">https://stackoverflow.com/questions/50108253/http-outbound-gateway-post-with-payload</a></p>
<p>测试 curl -X POST -d “orderInfo=3|CityA” <a href="http://localhost:8085/order">http://localhost:8085/order</a> 在暂时删除掉inbound中的处理函数的情况下<br>-d 是json的意思<br>curl -H “Content-Type:text/plain” -X POST -d ‘p1|p2|addr:CityA’ <a href="http://localhost:8085/order">http://localhost:8085/order</a> 明确是发送字符串</p>
<h2 id="Obstacles："><a href="#Obstacles：" class="headerlink" title="Obstacles："></a>Obstacles：</h2><ul>
<li>直接访问样例中的外部服务无问题，但是运行时出现：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GenericMessage [payload=Each hair in Chuck Norris&#x27;s beard contributes to make the world&#x27;s largest DDOS., headers=&#123;Transfer-Encoding=chunked, http_requestMethod=GET, errorChannel=org.springframework.messaging.core.GenericMessagingTemplate$TemporaryReplyChannel@3be35f5c, Server=cloudflare, Connection=keep-alive, http_statusCode=200 OK, Date=1653960361000, Via=1.1 vegur, accept=*/*, replyChannel=org.springframework.messaging.core.GenericMessagingTemplate$TemporaryReplyChannel@3be35f5c, host=localhost:8080, http_requestUrl=http://localhost:8080/check, id=35b1eb39-4b71-13c7-c14e-9a360c5a757e, contentType=application/json;charset=UTF-8, user-agent=curl/7.47.0, timestamp=1653960361139&#125;]</span><br></pre></td></tr></table></figure>

<p>与外部服务链接无问题 如果需要查看其中的信息可能需要指定gateway，指定errorChannel并提取信息</p>
<p>解决： 中间的打印实际上消耗了流中的数据 因此去掉打印的代码即可</p>
<ul>
<li>设计上的不足 head的模式 类型不匹配——用json改写所有看看</li>
</ul>
<p>how to find api I need:</p>
<p>search spring integration directly：搜索出来的结果和demo并不相似，更像老师的hello-world例子，即显式调用channel发送消息，样例中的服务本质并不是独立服务而是一个java类中的方法</p>
<p>直接搜索demo中调用的方法，查看api doc；然后搜素是否可能用该api传递post中的参数</p>
<p>利用xml是配置的好方式尤其是使用了默认的channel的时候，但是对于代码阅读不是很直观，可以参考stackoverflow和github搜索到的代码样例中的api</p>
<h2 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h2><p>inbound outbound作为接口 和之前接收http request的方法比更加简洁，体现了流式了处理，可以把更多的精力放在中间处理函数上（因为之前在http request上花费了时间）借用更加稳定的架构</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
  <entry>
    <title>AW09-Reactive Version</title>
    <url>/post/f51e3ca2/</url>
    <content><![CDATA[<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://github.com/sa-spring/employee-reactive">sa-spring/employee-reactive</a></p>
<p>针对delivery系统先尝试</p>
<p>EmployeeController 负责处理网页请求，返回的是用Mono或者Flux包装的数据结构</p>
<p>webclient 不管处理怎样的请求 都会显示取两个请求来处理</p>
<ul>
<li>EmployeeRepository/Employee 基础设施 <ul>
<li>repository是内存中 可以模仿之前某次作业里的持久化 或者改进时再做</li>
</ul>
</li>
</ul>
<p>Simple version： 发送一个请求立刻传送 模拟高占时的计算任务</p>
<ul>
<li><p>OrderInfo（需要添加买家名字和地址 order调整时在做，暂定是）应该在order中 迁移；</p>
<ul>
<li>Stirng id    </li>
<li>Items 信息（联调实现） </li>
</ul>
</li>
<li><p>DeliveryInfo pos-api 生成随机时长 显示在路上（log）最后告知已经送达 </p>
<ul>
<li>String 信息</li>
<li>是否已经送达（？）</li>
</ul>
</li>
</ul>
<p>Todo</p>
<ul>
<li><p>rabbitmq 配置</p>
<p>stream来发送 在yml里配置 </p>
</li>
<li><p>order创建好DeliveryDto再发送 才能用mapper 在order中订阅</p>
</li>
<li><p>可以用web client来发送请求</p>
</li>
</ul>
<p>Test Ref: <a href="https://github.com/sa-spring/spring-webflux">sa-spring/spring-webflux</a></p>
<p>测试用例可以写成mvn项目</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>Tips: 把本地jar包添加到本地依赖库：</p>
<p>mvn install:install-file -Dfile=./target/pos-api-0.0.1-SNAPSHOT.jar -Dgroup=com.micropos -DartifactId=micropos -Dversion=0.0.1</p>
<h3 id="Delivery-Service"><a href="#Delivery-Service" class="headerlink" title="Delivery Service"></a>Delivery Service</h3><p>采用了reactive的设计 但是只体现在了mono这种流式处理的数据结构上，自定义的consume只在应用刚启动的时候调用了一次</p>
<p>client中的<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/client/WebClient.RequestHeadersSpec.html#retrieve--">retrieve</a>是用来定义提取什么部分的，只有在有订阅的时候</p>
<p>onSubscribe都是在订阅的之后 publish请求的时候才会被调用</p>
<p><a href="https://github.com/sa-spring/employee-reactive">sa-spring/employee-reactive</a>，是把数据库作为publisher 服务器作为subscriber，这样subscriber可以控制数据产生的速度 order中有mono注册来subscribe 即下运输单的时候取决于运输服务的情况</p>
<p>改接口为Dto  方便服务间传输数据，测试样例不变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-type:application/json&quot; -X POST -d &#x27;&#123;&quot;orderId&quot;:&quot;001&quot;,&quot;deliveryId&quot;:&quot;001&quot;,&quot;delivered&quot;:&quot;false&quot;&#125;&#x27; http://localhost:8090/delivery/add</span><br></pre></td></tr></table></figure>

<h2 id="Order-Service"><a href="#Order-Service" class="headerlink" title="Order Service"></a>Order Service</h2><p>order</p>
<p>按照规范建立 建立rabbit stream传输</p>
<p>参照employee subscribe（感觉合适一些一对多场景？）</p>
<p>测试 发送一个只有一个product的order来测试（之后修改carts）</p>
<p>如果用stream delivery需要改进配合stream </p>
<p>如果是独立服务 那么用get uri？</p>
<p>问题：controller用webflux还是普通的 在service层抽象 repos返回orderInfo service层用mapper转换 flux来返回</p>
<p>add 订阅</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Content-type:application/json&quot;</span> -X POST -d</span><br><span class="line">&#x27;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;id&quot;</span>:<span class="string">&quot;c001&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;items&quot;</span>: [</span><br><span class="line">		&#123;<span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">		<span class="attr">&quot;quantity&quot;</span>:<span class="number">2</span></span><br><span class="line">		<span class="string">&quot;product&quot;</span>:</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="attr">&quot;id&quot;</span>: <span class="string">&quot;p01&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;product1&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;price&quot;</span>: <span class="number">20.0</span></span><br><span class="line">				<span class="string">&quot;image&quot;</span>: <span class="string">&quot;xxx&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br><span class="line">http:<span class="comment">//localhost:8089/order/add</span></span><br></pre></td></tr></table></figure>

<p>修改 发送必要信息 只有string orderId发送</p>
<p>用subscriber来模拟处理订单需要的时间，然后再开始配送</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>下载了windows版（关于和linux虚拟机斗争的故事之后再说。。）</p>
<p>激活命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins.bat enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<p>访问界面：<a href="http://127.0.0.1:15672/">http://127.0.0.1:15672/</a></p>
<p>默认账号和密码：guest/guest</p>
<p><a href="https://cloud.tencent.com/developer/article/1505191">后续参考</a></p>
<p><img src="/post/f51e3ca2/.%5CAW09-Reactive-Version.assets%5Cimage-20220704232815224.png" alt="image-20220704232815224"></p>
<p>暂时先用webclient发送消息 因此消息队列在本次作业中没有用上</p>
<h2 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h2><p>Future 获取结果 在发布任务的服务中可能需要</p>
<p>Mono/Flux区别: Mono 0-1item，Flux 0-n items</p>
<p>callback和future的区别？<a href="https://jayconrod.com/posts/93/futures-are-better-than-callbacks#:~:text=Futures%20have%20several%20advantages%20over,if%20there%20was%20an%20error.">Futures are better than callbacks</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1347628">Future,Callback,Promise</a></p>
<p><img src="/post/f51e3ca2/image-20220630094227028.png" alt="image-20220630094227028"></p>
<img src="/post/f51e3ca2/AW09-Reactive-Version.assets\image-20220630094214316.png" alt="image-20220630094214316" style="zoom:50%;">]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
  <entry>
    <title>AW10-Final-Full-Reactive-MicroPos</title>
    <url>/post/d29cc919/</url>
    <content><![CDATA[<h2 id="Not-Finished-Yet-in-Previous-AW"><a href="#Not-Finished-Yet-in-Previous-AW" class="headerlink" title="Not Finished Yet in Previous AW"></a>Not Finished Yet in Previous AW</h2><ul>
<li><p>choose product and checkout; use message</p>
</li>
<li><p>big collection of goods: extract and save in the repos——patch <a href="https://github.com/sawork-2022/aw06-August0830">aw06</a> products use h2db? 修改pos-product</p>
</li>
<li><p>test case <a href="https://github.com/sa-spring/spring-webflux">sa-spring/spring-webflux</a>测试用例可以写成mvn项目</p>
</li>
<li><p>记得恢复各地的eureka enable 其中cart需要在serviceimpl里恢复loadbalance yml文件</p>
</li>
<li><p>cart传输的数据需要修改</p>
</li>
</ul>
<h2 id="Guideline-to-my-Micropos"><a href="#Guideline-to-my-Micropos" class="headerlink" title="Guideline to my Micropos"></a>Guideline to my Micropos</h2><p>启动gateway 可以通过<a href="http://localhost:2222/%E6%9D%A5%E8%AE%BF%E9%97%AEMicropos%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%90%8E%E7%BC%80%E6%B7%BB%E5%8A%A0product%EF%BC%8Ccarts%EF%BC%8Corder%EF%BC%8Cdelivery%E8%AE%BF%E9%97%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1%E3%80%82%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%90%84%E8%87%AA%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8D%95%E7%8B%AC%E8%B0%83%E8%AF%95">http://localhost:2222/来访问Micropos，其中后缀添加product，carts，order，delivery访问对应的服务。也可以对各自的服务单独调试</a></p>
<h2 id="Obstacles"><a href="#Obstacles" class="headerlink" title="Obstacles"></a>Obstacles</h2><ul>
<li>迁移到windows下环境后delivery启动失败出现<a href="https://stackoverflow.com/questions/65164809/error-creating-bean-with-name-org-springframework-cloud-netflix-eureka-server-e">Unsatisfied dependency expressed through field ‘eurekaServerBootstrap’</a></li>
<li>类似问题 carts启动失败：<a href="https://stackoverflow.com/questions/46878649/maven-compilation-issue-with-java-9">查询后添加</a><ul>
<li>I got the same error on java 11. Adding <a href="https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api/2.2.11">jaxb api</a> dependency to the pom solved my issue</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
  <entry>
    <title>Algo Revised: Dynamic Programing</title>
    <url>/post/9120db44/</url>
    <content><![CDATA[<h4 id="Longest-ZigZag-Path-in-a-Binary-Tree"><a href="#Longest-ZigZag-Path-in-a-Binary-Tree" class="headerlink" title="Longest ZigZag Path in a Binary Tree"></a><a href="https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/">Longest ZigZag Path in a Binary Tree</a></h4><p>尾递归的构建方式 在参数当中完成运算。</p>
<p>本题最优解不依赖于子问题的解，因为有可能子问题中出现最大解但是对于父问题来说不符合加1的要求，例如最长Z路径出现在中间段，所以采用外部设置全局变量比较更新的方法</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tail_recusion</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">int</span> direct,TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen,len);</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(direct==<span class="number">1</span>)<span class="comment">//上一次走的是右侧 即当前节点是父节点的右子树</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                    <span class="built_in">tail_recusion</span>(len+<span class="number">1</span>,<span class="number">0</span>,root-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                    <span class="built_in">tail_recusion</span>(<span class="number">1</span>,<span class="number">1</span>,root-&gt;right);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span><span class="comment">//当前节点是父节点的左子树</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                    <span class="built_in">tail_recusion</span>(<span class="number">1</span>,<span class="number">0</span>,root-&gt;left);<span class="comment">//1 是为了在下一层中记录本层的位置</span></span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                    <span class="built_in">tail_recusion</span>(len+<span class="number">1</span>,<span class="number">1</span>,root-&gt;right);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">tail_recusion</span>(<span class="number">0</span>,<span class="number">0</span>,root);</span><br><span class="line">        <span class="built_in">tail_recusion</span>(<span class="number">0</span>,<span class="number">1</span>,root);</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="887-Super-Egg-Drop"><a href="#887-Super-Egg-Drop" class="headerlink" title="887. Super Egg Drop"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/">887. Super Egg Drop</a></h4><p>重点:描述出状态 找到状态转移方程 本题特征: 利用函数的单调性来逼近答案（这是本题规划的部分）</p>
<img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20210526153430141.png" alt="image-20210526153430141" style="zoom: 50%;">

<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20210526153443782.png" alt="image-20210526153443782"></p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; memo;<span class="comment">//dp中用于存储的字典</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">find</span>(<span class="number">100</span>*n+k)==memo.<span class="built_in">end</span>())<span class="comment">//找不到</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">                ans=n;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">                ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> low =<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> high=n;</span><br><span class="line">                <span class="keyword">while</span>(low+<span class="number">1</span>&lt;high)<span class="comment">//是离散的点 所以只能用间隔逼近</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> t1 = <span class="built_in">dp</span>(k,n-x);</span><br><span class="line">                    <span class="keyword">int</span> t2 = <span class="built_in">dp</span>(k<span class="number">-1</span>,x<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(t1&gt;t2)</span><br><span class="line">                        low = x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(t1&lt;t2)</span><br><span class="line">                        high=x;</span><br><span class="line">                    <span class="keyword">else</span>    </span><br><span class="line">                        low = high = x;</span><br><span class="line">                &#125;</span><br><span class="line">                ans=<span class="number">1</span>+<span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">dp</span>(k,n-low),<span class="built_in">dp</span>(k<span class="number">-1</span>,low<span class="number">-1</span>)),<span class="built_in">max</span>(<span class="built_in">dp</span>(k,n-high),<span class="built_in">dp</span>(k<span class="number">-1</span>,high<span class="number">-1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            memo[<span class="number">100</span>*n+k]=ans;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">100</span>*n+k];<span class="comment">//利用一个函数映射 把二维降为一维存储</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(K,N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>20220118 树状分析改为动态规划：二分法想到的是对的 最后本质采用了二分查找；压缩的本质是 m~n可以用n-m来表示</p>
<h4 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. Palindrome Partitioning</a></h4><p>回溯法写对了 关键在于去除冗余计算</p>
<p>在判断回文串的时候有冗余 dp判断是否是回文串</p>
<p>如果直接采用课堂上二维矩阵的方式来记录的话，需要分配的空间过大</p>
<p> <strong>dp判断s[i]~s[j]是否是回文串</strong></p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; jdg;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;s.<span class="built_in">size</span>();++j)</span><br><span class="line">            &#123;            </span><br><span class="line">                jdg[i][j]=(s[i]==s[j])&amp;&amp;jdg[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//转移方程依赖[i+1][j-1] 从末尾往前</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        jdg.<span class="built_in">assign</span>(len,vector&lt;<span class="keyword">bool</span>&gt;(len,<span class="literal">true</span>));<span class="comment">//学到新函数 注意初始化 i&gt;=j 时都为真 边缘是i+1和j-1交错 此时依赖于i+1和j-1字符是否相等 因此应该设置为true</span></span><br><span class="line">        <span class="built_in">judge</span>(s);</span><br><span class="line">        vector&lt;string&gt; set;</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">0</span>,s,set);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> left,string s,vector&lt;string&gt;&amp; set)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=s.<span class="built_in">size</span>())</span><br><span class="line">            ans.<span class="built_in">push_back</span>(set);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;s.<span class="built_in">size</span>();++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(jdg[left][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    set.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(left,i-left+<span class="number">1</span>));</span><br><span class="line">                    <span class="built_in">backtrace</span>(i+<span class="number">1</span>,s,set);</span><br><span class="line">                    set.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>时间代价：</strong>字符串长度为n，若每个字符都一样，则有2^(n-1) = O(2^n) 的分法，而每种分发都需要遍历一次字符串来获得对应的划分，加上动态规划的代价</p>
<p>O(n*2^n+n^2)=O(n*2^n)</p>
<p><strong>空间代价</strong> dp的数组 O(n^2)</p>
<p>变式 <a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132. Palindrome Partitioning II</a></p>
<p>基于上一题的思路 就是在回溯具体切分的过程中做统计 每次到底得到答案的时候记录切分次数，在切分回溯的过程中利用已经有的答案做出剪枝</p>
<p>还有一个更快的思路是只统计次数 不在乎情况</p>
<p>不要贪心 思路是对的 先用dp求出回文的情况，计算最小分割数的时候的方程是互相依赖的且是一维的 在用上述标记做一次dp</p>
<p>取决于问题是从后往前分析还是从前往后；如果数组定义为从0到位置i需要的最短分割，那么是从前往后（注意！！）数组的定义会影响到问题规划的方式</p>
<p>方程：s[0][i]是回文的话 memo[i]=0 因为无需分割，否则对于j=[0,i], 找到一个最小的memo[j]+1 在此处使用了贪心的解法</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; jdg;</span><br><span class="line">        memo.<span class="built_in">resize</span>(s.<span class="built_in">size</span>(),s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        jdg.<span class="built_in">assign</span>(s.<span class="built_in">size</span>(),vector&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">size</span>(),<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;s.<span class="built_in">size</span>();++j)</span><br><span class="line">                jdg[i][j]=(s[i]==s[j])&amp;&amp;jdg[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(jdg[<span class="number">0</span>][i])</span><br><span class="line">                memo[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)</span><br><span class="line">                    <span class="keyword">if</span>(jdg[j+<span class="number">1</span>][i])</span><br><span class="line">                        memo[i]=(memo[i]&gt;memo[j]+<span class="number">1</span>)?(memo[j]+<span class="number">1</span>):memo[i];</span><br><span class="line">            <span class="comment">//转移方程中 更小的值可能已经被记录 要维持最小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>变式  <a href="https://leetcode-cn.com/problems/palindrome-partitioning-iii/">1278. Palindrome Partitioning III</a></p>
<p>采用同样的预处理，changed[i][j]表示从s[i]到s[j]若修改为字符串需要修改的字符个数，转移方程只需要在判断的基础上略作修改即可。原本考虑用递归来表示待分割的次数k，但是这也转换为一个二维空间 </p>
<blockquote>
<p>为什么changed是二维而不是一维——因为同一层循环可能有不同的分割点</p>
</blockquote>
<p>定义 minch[m][i] 还有m次分割机会（很重要！划重点！）下，从0号位置到i号位置最少改变的字符数</p>
<p>卡在的地方: 解决问题的思路（明确有二维的变量），m的取值（一开始搞成了k+1，k+1是用在不包括0的计数的情况，这里的确只有0~k），内部规划的时候 j 和 i 的关系，注意分割的时候要从下一个字符开始</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;b)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">palindromePartition</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; changed;</span><br><span class="line">    changed.<span class="built_in">assign</span>(len, vector&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                changed[i][j] = changed[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                changed[i][j] = changed[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//再次出现的回文处理方式</span></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; minch;</span><br><span class="line">    minch.<span class="built_in">assign</span>(k, vector&lt;<span class="keyword">int</span>&gt;(len, INT_MAX - <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        minch[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; ++m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;m &quot; &lt;&lt; m &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                minch[<span class="number">0</span>][i] = changed[<span class="number">0</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; minch[m - 1][j] &lt;&lt; &quot; &quot; &lt;&lt; changed[j + 1][i] &lt;&lt; endl;</span></span><br><span class="line">                    minch[m][i] = <span class="built_in">min</span>(minch[m][i], minch[m - <span class="number">1</span>][j] + changed[j + <span class="number">1</span>][i]);<span class="comment">//记住留下最小值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for (int i = 0; i &lt; k; ++i)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt; len; ++j)</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; minch[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; endl;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minch[k<span class="number">-1</span>][len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>变式 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></p>
<p>在原本架构上增加全局变量找最大值 一开始脑子转不过来没有意识到本质是变式。可以接机复习回文串的动态规划架构</p>
<p>在规划顺序卡住，取决于如何分解问题：可以长度由小到大显式：</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20210713201525528.png" alt="image-20210713201525528"></p>
<p>也可以采用如下：右侧限定了左侧，右侧从小到大，左侧从最左开始填写</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>,start=<span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">judge</span>(len,vector&lt;<span class="keyword">bool</span>&gt;(len));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=<span class="number">0</span>;right&lt;len;++right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>;left&lt;=right;++left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[left]!=s[right])  </span><br><span class="line">                &#123;</span><br><span class="line">                    judge[left][right]=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;=<span class="number">2</span>)</span><br><span class="line">                    judge[left][right]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    judge[left][right]=judge[left+<span class="number">1</span>][right<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(judge[left][right] &amp;&amp; right+<span class="number">1</span>-left&gt;maxlen)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen=right+<span class="number">1</span>-left;</span><br><span class="line">                    start=left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最初想到的：中心扩散法</p>
<p>可以优化的地方是：在剩余的长度小于maxlen/2的时候停止，因为此时不可能再有回文串比现行最大长度回文串要长；出现重复字符的时候移动指针直到下一个字符不重复，相当于根据重复字符也是回文串把重复部分压缩，然后再照常判断</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>,start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(len-i&lt;=maxlen/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//长度为1或0必是回文 且不会再有比现行答案更长的回文串 可以早点结束</span></span><br><span class="line">            <span class="keyword">int</span> left=i,right=i;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;len<span class="number">-1</span> &amp;&amp; s[right]==s[right+<span class="number">1</span>])</span><br><span class="line">                right++;<span class="comment">//确认核心</span></span><br><span class="line">            i=right+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;len<span class="number">-1</span> &amp;&amp; left&gt;<span class="number">0</span> &amp;&amp; s[left<span class="number">-1</span>]==s[right+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxlen&lt;right+<span class="number">1</span>-left)</span><br><span class="line">            &#123;</span><br><span class="line">                maxlen=right+<span class="number">1</span>-left;</span><br><span class="line">                start=left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>变式：<a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. Palindromic Substrings</a></p>
<p>评论区RoundOne的dp解法很简洁 学习</p>
<h4 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a><a href="https://leetcode-cn.com/problems/word-break/">139. Word Break</a></h4><p>遇到可以匹配的词就切分并且以切分后的字串为开头继续切分 但该思路的本质是贪心策略，</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">judge</span><span class="params">(len+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        judge[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(wordDict.<span class="built_in">begin</span>(),wordDict.<span class="built_in">end</span>(),str)!=wordDict.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(judge[i+<span class="number">1</span>-cnt])</span><br><span class="line">                &#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;i &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;str &quot;</span>&lt;&lt;str&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;cnt &quot;</span>&lt;&lt;cnt&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    judge[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                    cnt=<span class="number">0</span>;</span><br><span class="line">                    str.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judge[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;aaaaaaa&quot;</span></span><br><span class="line"><span class="comment">[&quot;aaaa&quot;,&quot;aaa&quot;]</span></span><br><span class="line"><span class="comment">My output:false</span></span><br><span class="line"><span class="comment">Expected:true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>动态规划 一维</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt;<span class="built_in">judge</span>(len+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">        judge[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                string str = s.<span class="built_in">substr</span>(j,i+<span class="number">1</span>-j);</span><br><span class="line">                <span class="keyword">if</span>(!judge[i+<span class="number">1</span>]&amp;&amp;<span class="built_in">find</span>(wordDict.<span class="built_in">begin</span>(),wordDict.<span class="built_in">end</span>(),str)!=wordDict.<span class="built_in">end</span>())<span class="comment">//有可分割的情况就不再判断</span></span><br><span class="line">                &#123;</span><br><span class="line">                    judge[i+<span class="number">1</span>]=judge[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:judge)</span><br><span class="line">            cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> judge[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. Regular Expression Matching</a></h4><p>关键在于意识到需要用到动态规划才能解决问题，是在测试用例</p>
<p>s=”aab” p=”ac*a*b”的时候意识到的</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> match=[&amp;](<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="comment">//除了[0][0]之外，其他意味着空串匹配非空串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>];</span><br><span class="line">        &#125;;<span class="comment">//注意边界条件 judge[0][0]=true 是初始条件</span></span><br><span class="line">        <span class="keyword">int</span> m=s.<span class="built_in">size</span>(),n=p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">judge</span>(m+<span class="number">1</span>,vector&lt;<span class="keyword">bool</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        judge[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    judge[i][j]=judge[i][j<span class="number">-2</span>];<span class="comment">//是否需要星号</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">match</span>(i,j<span class="number">-1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        judge[i][j]=judge[i<span class="number">-1</span>][j]||judge[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">match</span>(i,j))</span><br><span class="line">                    &#123;</span><br><span class="line">                        judge[i][j]=judge[i<span class="number">-1</span>][j<span class="number">-1</span>]||judge[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judge[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title=" Letter Combinations of a Phone Number"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/"> Letter Combinations of a Phone Number</a></h4><p>直接做法是哈希表硬记忆，后用回溯</p>
<p>这里看到了一个技巧做法：统计出所有可能性（本身是连乘），然后根据计数规律来构造</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        vector&lt;string&gt; dict=&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>,size=digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digits.<span class="built_in">size</span>();++i)</span><br><span class="line">            len=len*dict[digits[i]-<span class="string">&#x27;0&#x27;</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> last=i;</span><br><span class="line">            string str;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=size<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> c = digits[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> pos = last%dict[c].<span class="built_in">size</span>();</span><br><span class="line">                last/=dict[c].<span class="built_in">size</span>();<span class="comment">//这两句决定了外层的循环是倒序并且最后需要reverse</span></span><br><span class="line">                str.<span class="built_in">push_back</span>(dict[c][pos]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类似题：</p>
<h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a><a href="https://leetcode-cn.com/problems/permutations/">46. Permutations</a></h4><p>上述编号取余的方法并没有比回溯法更加高效 但是学习了unique的用法 返回一个迭代器 从begin到该迭代器 只有一个元素重复出现一次 即对于不重复出现的部分 返回的迭代器相当于end()</p>
<p>回溯法 注意是引用 要创建新的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>.n=nums.length;</span><br><span class="line">        <span class="keyword">this</span>.res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            output.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        backtrace(output,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(List&lt;Integer&gt; output,<span class="keyword">int</span> first)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first==n)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(output));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;n;++i)&#123;</span><br><span class="line">            Collections.swap(output,first,i);</span><br><span class="line">            backtrace(output,first+<span class="number">1</span>);</span><br><span class="line">            Collections.swap(output,first,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. Generate Parentheses</a></h4><p>一个简单的回溯 关键是控制配对</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">char</span> ch,string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left--,right--;</span><br><span class="line">            str.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">reverse</span>(left,right,<span class="string">&#x27;(&#x27;</span>,str);</span><br><span class="line">            <span class="keyword">if</span>(right&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">reverse</span>(left,right,<span class="string">&#x27;)&#x27;</span>,str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right++;</span><br><span class="line">            str.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">reverse</span>(left,right,<span class="string">&#x27;(&#x27;</span>,str);</span><br><span class="line">            <span class="keyword">if</span>(right&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">reverse</span>(left,right,<span class="string">&#x27;)&#x27;</span>,str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(n,<span class="number">0</span>,<span class="string">&#x27;(&#x27;</span>,str);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32. Longest Valid Parentheses"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. Longest Valid Parentheses</a></h4><p>一开始想用栈做 但是实际情况更复杂 没有考虑括号套娃的情况</p>
<p>dp版：关键在于 完整的子串必定是右括号结尾，所以状态转移只需要关注右括号，左括号结尾的子串长度必定是0（全初始化为0就可以） 有两种转移状态 成对和套娃 小心下标合法性的判断</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    dp[i]=<span class="number">2</span>+((i&lt;<span class="number">2</span>)?<span class="number">0</span>:dp[i<span class="number">-2</span>]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]&gt;<span class="number">0</span> &amp;&amp; s[i<span class="number">-1</span>-dp[i<span class="number">-1</span>]]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        dp[i]=<span class="number">2</span>+dp[i<span class="number">-1</span>]+((i<span class="number">-2</span>-dp[i<span class="number">-1</span>]&lt;<span class="number">0</span>)?<span class="number">0</span>:dp[i<span class="number">-2</span>-dp[i<span class="number">-1</span>]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max=(dp[i]&gt;max)?dp[i]:max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>栈：</p>
<p>一开始使用更多的是对符号本身是否匹配，这里改成存下标，以来通过下标的信息可以判断是否匹配，二来下标差可以直接求出子串长</p>
<p>这里栈底是最后一个没有被匹配的右括号的下标，之上都是可以被匹配的左括号初始化采用-1可以在开头不是右括号的情况下完成补全。</p>
<p>需要注意的细节：</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>,len=s.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())</span><br><span class="line">                        max = (i-stk.<span class="built_in">top</span>()&gt;max)?i-stk.<span class="built_in">top</span>():max;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        stk.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. Combination Sum</a></h4><p>卡在了具体实现上（本质就是部分和问题）</p>
<p>动态规划 巧用stl库</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &gt;dict;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it:candidates)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(it==i)</span><br><span class="line">                    dict[i].<span class="built_in">insert</span>(&#123;it&#125;);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> vec:dict[i-it])<span class="comment">//为空会跳过</span></span><br><span class="line">                    <span class="comment">//没有引用符号 不会修改原来的vector</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        vec.<span class="built_in">push_back</span>(it);</span><br><span class="line">                        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">                        <span class="keyword">if</span>(dict[i].<span class="built_in">count</span>(vec)==<span class="number">0</span>)<span class="comment">//绝妙 其中的元素vector比较符号被重载了</span></span><br><span class="line">                            dict[i].<span class="built_in">insert</span>(vec);<span class="comment">//没有就加入</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:dict[target])</span><br><span class="line">            ans.<span class="built_in">push_back</span>(it);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回溯法</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; candi;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; res,<span class="keyword">int</span> remain)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>(),res)==ans.<span class="built_in">end</span>())</span><br><span class="line">                ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : candi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(it&gt;remain)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(it);</span><br><span class="line">            <span class="built_in">backtrace</span>(res,remain-it);</span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        candi = candidates;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">backtrace</span>(res,target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. Minimum Path Sum</a></h4><p>dp和记忆化搜索都可以</p>
<p>dp</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.<span class="built_in">size</span>(),n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        dp[m<span class="number">-1</span>][n<span class="number">-1</span>]=grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            dp[i][n<span class="number">-1</span>]=grid[i][n<span class="number">-1</span>]+dp[i+<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            dp[m<span class="number">-1</span>][i]=grid[m<span class="number">-1</span>][i]+dp[m<span class="number">-1</span>][i+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化只能向右和只能向下的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-2</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>记忆化搜索另外一题：<a href="https://leetcode-cn.com/problems/unique-paths/">62. Unique Paths</a></p>
<h4 id="221-Maximal-Square"><a href="#221-Maximal-Square" class="headerlink" title="221. Maximal Square"></a><a href="https://leetcode-cn.com/problems/maximal-square/">221. Maximal Square</a></h4><p>dp的含义：以ij为右下角的正方形的最大边长</p>
<p>依赖于左上方 左方 上方是否是正方形 为了统计数量方便 也可以理解为依赖于左上方 左方 上方正方形边长大小 缺一不可 所以要取三者最小值 注意边界情况（在图形边界）</p>
<p>可以解释为什么要考虑左侧上侧的最小值</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20210915113432534.png" alt="image-20210915113432534"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(columns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;<span class="comment">//不仅是判断 还要计数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = <span class="built_in">max</span>(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. Perfect Squares</a></h4><p>内层循环是在动态规划解法中是不可避免的 相信自己!</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> minn=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*j&lt;=i;++j)<span class="comment">//用于找最优</span></span><br><span class="line">                minn = <span class="built_in">min</span>(minn,dp[i-j*j]);</span><br><span class="line">            dp[i]=minn+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BFS 减去比自己小的完全平方数 成为树的节点</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">        visited.<span class="built_in">emplace</span>(n);</span><br><span class="line">        que.<span class="built_in">push</span>(n);</span><br><span class="line">        <span class="keyword">int</span> level=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> num = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*j&lt;=num;++j)&#123;<span class="comment">//找多种可能性</span></span><br><span class="line">                    <span class="keyword">int</span> residual = num-j*j;</span><br><span class="line">                    <span class="keyword">if</span>(residual==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(visited.<span class="built_in">count</span>(residual)==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited.<span class="built_in">emplace</span>(residual);</span><br><span class="line">                        que.<span class="built_in">push</span>(residual);</span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. Maximum Product Subarray</a></h4><p>最长子序列的变体 关键在于从动态规划的思路理清</p>
<p>最大除了符号反转之外还有重新开始的可能（<code>nums[i]</code>自身）</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minp=nums[<span class="number">0</span>],maxp=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> tmpmax=<span class="number">0</span>,tmpmin=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpmax=maxp;</span><br><span class="line">            tmpmin=minp;</span><br><span class="line">            maxp = <span class="built_in">max</span>(nums[i],<span class="built_in">max</span>(tmpmax*nums[i],tmpmin*nums[i]));</span><br><span class="line">            minp = <span class="built_in">min</span>(nums[i],<span class="built_in">min</span>(tmpmax*nums[i],tmpmin*nums[i]));</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,maxp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a></h4><p>和最大子串和 最大子串积是同类</p>
<p>动态规划 有重复遍历</p>
<p>贪心+二分查找——上升的尽可能慢 长度为j的最小末尾作为状态记录 遍历到一个数用二分查找来更新（可以证明最小末尾数据是递增的）</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        d[len]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;d[len])</span><br><span class="line">                d[++len]=nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l=<span class="number">1</span>,r=len;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;<span class="comment">//如果都没有找到 说明所有前面的数都比当前数大</span></span><br><span class="line">                <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(d[mid]&lt;nums[i])&#123;<span class="comment">//在记录中查找</span></span><br><span class="line">                        pos = mid;<span class="comment">//尽量向大的靠近 因此先赋值给pos </span></span><br><span class="line">                        l=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>    </span><br><span class="line">                        r=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="comment">//二分查找 目标是找到d[pos]&lt;nums[i] &amp;&amp; d[pos+1]&gt;nums[i]</span></span><br><span class="line">                d[pos+<span class="number">1</span>]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. Best Time to Buy and Sell Stock with Cooldown</a></h4><p><strong>How to come up with the idea that using dynamic programming?</strong></p>
<p>multiple states+rely on state of previous day</p>
<p>Because it has three different decisions in one day, dp vector should be two-dimension.</p>
<p>To optimize the space, we notice that every step is only dependent to its previous one step. So we can use single variable instead of vector to memorize states. In this way the memory used is back to one dimension but it is a bit different to my original thought, which only consider the time series.</p>
<p>Another point is to figure out how the state changes with cool-down.  Devide the state into three situations: stock, not stock and cool, not stocking and not cool.</p>
<p>For day i, Stock means you have bought stocks previous day, so state is same as day i-1 stock. Or you bought it today, which means you cannot cool down and have stocks yesterday. So it is not stock and not cool plus your cost of buying stocks.</p>
<p>For day i, not stock and not cool means you have no stocks yesterday ( same as day i-1 no-stocks-no-cool);or you are cool down yesterday.</p>
<p>For day i, not stock and cool means you sold your stocks yesterday, which is day i-1 stock plus the price you sold them.</p>
<p>Besides, for initialization, stock means you bought stocks on that day, so it’s minus.  It’s impossible for first day to be cool-down but we still set it zero,same as no-stocks-no-cool. We can take it as sell at 0 before.</p>
<p>Last, it’s meaningless to have stocks at last day, so the answer comes from cool-down and no-stocks-no-cool.</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> stock=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cool = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nsnc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> newst = <span class="built_in">max</span>(stock,nsnc-prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newcool = stock+prices[i];</span><br><span class="line">            <span class="keyword">int</span> newnsnc = <span class="built_in">max</span>(nsnc,cool);</span><br><span class="line">            stock = newst;</span><br><span class="line">            cool = newcool;</span><br><span class="line">            nsnc = newnsnc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(cool,nsnc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. House Robber</a></h4><p>小心初始化的时候 第二个位置是取前两个的最大值</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);<span class="comment">//attention</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(nums[i]+dp[i<span class="number">-2</span>],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现 实际上只需要存前两栋房屋的最大值就可以了 再往前的不需要</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> house1=<span class="number">0</span>,house2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            house1 = nums[<span class="number">0</span>];</span><br><span class="line">            house2 = <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=house2;<span class="comment">//不能设置为0 否则nums.size()==2时出错</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(house1+nums[i],house2);</span><br><span class="line">            house1 = house2;</span><br><span class="line">            house2=ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="337-House-Robber-III"><a href="#337-House-Robber-III" class="headerlink" title="337. House Robber III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. House Robber III</a></h4><p>曾经的算法题复习 是否要取状态要记录</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;TreeNode*,<span class="keyword">int</span>&gt; yes;</span><br><span class="line">    unordered_map&lt;TreeNode*,<span class="keyword">int</span>&gt; no;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">robPlan</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            yes[root]=root-&gt;val;</span><br><span class="line">            no[root]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">robPlan</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">robPlan</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        yes[root]=root-&gt;val+no[root-&gt;left]+no[root-&gt;right];</span><br><span class="line">        no[root]=<span class="built_in">max</span>(yes[root-&gt;left],no[root-&gt;left])+<span class="built_in">max</span>(yes[root-&gt;right],no[root-&gt;right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">robPlan</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(yes[root],no[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="312-Burst-Balloons"><a href="#312-Burst-Balloons" class="headerlink" title="312. *Burst Balloons"></a><a href="https://leetcode-cn.com/problems/burst-balloons/">312. *Burst Balloons</a></h4><p>memorized search</p>
<p>if deleting ballon, two non-adjacent balloons will become adjacent. So we can take deletion as addition(Last one deleted). And use addtion to partition. Try every possible solution to find out currently max count.</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; rec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right<span class="number">-1</span>)<span class="comment">//open interval </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(rec[left][right]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> mid=left+<span class="number">1</span>;mid&lt;right;++mid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum=val[left]*val[right]*val[mid];</span><br><span class="line">                sum+=<span class="built_in">solve</span>(left,mid)+<span class="built_in">solve</span>(mid,right);</span><br><span class="line">                rec[left][right]=<span class="built_in">max</span>(rec[left][right],sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="comment">//take deletion as addition</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        val.<span class="built_in">resize</span>(n+<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            val[i]=nums[i<span class="number">-1</span>];</span><br><span class="line">        val[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        val[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        rec.<span class="built_in">resize</span>(n+<span class="number">2</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">2</span>,<span class="number">-1</span>));<span class="comment">//-1 means not calculated</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(<span class="number">0</span>,n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Change the sequence to calculate. So we have dynamic programming.</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">val</span><span class="params">(n+<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            val[i]=nums[i<span class="number">-1</span>];</span><br><span class="line">        val[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        val[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">rec</span>(n+<span class="number">2</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)<span class="comment">//left</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;=n+<span class="number">1</span>;++j)<span class="comment">//right</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;++k)<span class="comment">//mid</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=val[i]*val[k]*val[j];</span><br><span class="line">                    sum+=rec[i][k]+rec[k][j];</span><br><span class="line">                    rec[i][j]=<span class="built_in">max</span>(sum,rec[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum</a></h4><p>一个背包问题 转换为所有值的一半 应该复习的问题 算法课出现过</p>
<p>背包问题用一维是解决不了的 因为需要记录目前加了什么值</p>
<p><code>dp[i][j]</code>的含义 对目标<code>j</code>数组里的前<code>i</code>个数是否能满足</p>
<p>由于只求一半 所以j的范围在0~target就可以 即数组建立为target+1</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxNum=*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//是奇数</span></span><br><span class="line">        <span class="keyword">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(maxNum&gt;target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//最大数比一半还大 不可能</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(target+<span class="number">1</span>，<span class="number">0</span>));<span class="comment">//不写0剩下也默认是false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="literal">true</span>;<span class="comment">//initialise 小心转移方程和初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]]=<span class="literal">true</span>;<span class="comment">//0~0 谁都可以 这是起点 需要为真 ！！！！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num=nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;++j)<span class="comment">//从左到右填表</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=num)</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]|dp[i<span class="number">-1</span>][j-num];</span><br><span class="line">                <span class="comment">//可以不选这个数 或者选了转译成另一个数</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="comment">//不能选 只能看上一个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. Target Sum</a></h4><p>一开始想到的逐个和累加没有排除负数 </p>
<p>列的大小只与目标有关 转换目标</p>
<p>用公式转换 凑需要是负数的和</p>
<p><code>dp[i][j]</code>的含义是前i个数凑出来负数和是j的方法数</p>
<p>neg没有也是一种情况</p>
<p>想明白传一方程:是累加</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum= <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((sum-target)%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//排除一些不可能情况</span></span><br><span class="line">        <span class="keyword">int</span> neg = (sum-target)/<span class="number">2</span>;<span class="comment">//(sum-neg)-neg==target</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(neg+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)<span class="comment">//0：不需要数字 </span></span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=neg;++j)<span class="comment">//0 和倒扣到0 注意初始化的方向 要包括0 eg [1,0] 1</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]+=dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>空间优化</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> delta = sum-target;</span><br><span class="line">        <span class="keyword">if</span>(delta%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> neg = delta/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//优化 只与上一行有关</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(neg+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=neg;j&gt;=n;--j)<span class="comment">//从后往前 因为依赖前面的数据 不能覆盖 同时注意下标</span></span><br><span class="line">                dp[j]+=dp[j-n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. Coin Change</a></h4><p>When using dynamic programing, vector can be initialized to be amount+1. Such impossible value can avoid INT_MAX overflow when calculating.</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,amount+<span class="number">2</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//因为不限次数 所以dp[i]代表amount=i时的方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> n:coins)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i-n&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i]=<span class="built_in">min</span>(dp[i],dp[i-n]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==amount+<span class="number">2</span>?<span class="number">-1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><p>注意返回的答案应当是f_n_1（Fn-1）；以及按照题目要求每个答案都要取模</p>
<h4 id="1048-Longest-String-Chain"><a href="#1048-Longest-String-Chain" class="headerlink" title="1048. Longest String Chain"></a><a href="https://leetcode-cn.com/problems/longest-string-chain/">1048. Longest String Chain</a></h4><p>一开始想到用回溯 但是在边界情况一直出错 可以用动态规划 避免一开始的是否需要加入的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(String shorter,String longer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shorter.length()+<span class="number">1</span> != longer.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> insert=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;shorter.length() &amp;&amp; j &lt; longer.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(shorter.charAt(i)!=longer.charAt(j))</span><br><span class="line">                insert--;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ++i;<span class="comment">//匹配了 前身的指针才移动 否则让插入 后者的指针一直移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(insert&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        List&lt;String&gt; wordsList =Arrays.asList(words);</span><br><span class="line">        wordsList.sort(<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(String str:wordsList)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s &quot;</span>,str);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = wordsList.size();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(judge(wordsList.get(j),wordsList.get(i)))&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(dp[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>,dp[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="375-Guess-Number-Higher-or-Lower-II-220127x"><a href="#375-Guess-Number-Higher-or-Lower-II-220127x" class="headerlink" title="375. Guess Number Higher or Lower II 220127x"></a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/">375. Guess Number Higher or Lower II 220127x</a></h4><p>最开始想到了树，在这过程中想到了区间分治可以用记忆话搜索或者动态规划</p>
<p>预打表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">10</span>][N+<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//下标会到n</span></span><br><span class="line">    <span class="comment">//打表预处理</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=N;++len)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len-<span class="number">1</span>&lt;=N;++l)&#123;</span><br><span class="line">                <span class="comment">//有减一的操作</span></span><br><span class="line">                <span class="keyword">int</span> r = l+len-<span class="number">1</span>;</span><br><span class="line">                cache[l][r]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">                    <span class="keyword">int</span> cur = Math.max(cache[l][i-<span class="number">1</span>],cache[i+<span class="number">1</span>][r])+i;</span><br><span class="line">                    cache[l][r]=Math.min(cache[l][r],cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Algo</tag>
      </tags>
  </entry>
  <entry>
    <title>Algo Revised: Tree</title>
    <url>/post/55a58fe7/</url>
    <content><![CDATA[<h4 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. Symmetric Tree</a></h4><p>从树的递归性质入手 这里增加的难度在于左右交替判断 注意指针为空的情况</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSym</span><span class="params">(TreeNode* rt1,TreeNode*rt2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!rt1&amp;&amp;!rt2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rt1 &amp;&amp; rt2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rt1-&gt;val!=rt2-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isSym</span>(rt1-&gt;left,rt2-&gt;right) &amp;&amp; <span class="built_in">isSym</span>(rt1-&gt;right,rt2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSym</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h4><p>搜索树的定义！！复习非递归实现前序遍历</p>
<p>递归：结合范围 注意数字取值的范围</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> lower,<span class="keyword">long</span> <span class="keyword">long</span> upper, TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(lower,root-&gt;val,root-&gt;left) &amp;&amp; </span><br><span class="line">        <span class="built_in">check</span>(root-&gt;val,upper,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(LONG_MIN,LONG_MAX,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归的中序遍历</p>
<p>甚至都不需要存队列 只需要保存队列的最后一个值进行比较就可以了</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> inorder = LONG_MIN;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() || root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(inorder&gt;=root-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            inorder = root-&gt;val;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h4><p>复习一下切分递归的方式  广度优先</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoSide</span><span class="params">(TreeNode* ltree,TreeNode* rtree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lDepth=<span class="number">0</span>,rDepth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ltree)</span><br><span class="line">            lDepth = <span class="built_in">twoSide</span>(ltree-&gt;left,ltree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(rtree)</span><br><span class="line">            rDepth = <span class="built_in">twoSide</span>(rtree-&gt;left,rtree-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(lDepth,rDepth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">twoSide</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其他方法：深度优先递归 不使用全局变量</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left),<span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h4><blockquote>
<p>美区评论区大神 StefanPochmann</p>
<p>Consider the example again. Instead of finding the <code>1</code> in <code>inorder</code>, splitting the arrays into parts and recursing on them, just recurse on the full remaining arrays and <strong>stop</strong> when you come across the <code>1</code> in <code>inorder</code>. That’s what my above solution does. Each recursive call gets told where to stop, and it tells its subcalls where to stop. It gives its own root value as stopper to its left subcall and its parent`s stopper as stopper to its right subcall.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> preIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> partition(Integer.MAX_VALUE+<span class="number">1</span>,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">partition</span><span class="params">(<span class="keyword">int</span> stop,<span class="keyword">int</span>[] preorder,<span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;inorder.length &amp;&amp; inorder[index]!=stop)&#123;</span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preIndex++]);</span><br><span class="line">            root.left = partition(root.val,preorder,inorder);</span><br><span class="line">            <span class="comment">//左子树遍历完成后index指向root</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="comment">//开始遍历右侧 其中右侧应当停下的位置与上一层指定的stop位置相同</span></span><br><span class="line">            <span class="comment">//右侧遍历和左侧一样 先建立左子树 递归思路</span></span><br><span class="line">            root.right = partition(stop,preorder,inorder);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h4><p>一开始想到广度优先的填色法来交替区分不同层次，答案给出了更小空间的做法：统计当前队列中点的个数 只取出这些作为一列 </p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; line;</span><br><span class="line">            <span class="keyword">int</span> lineCount = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lineCount;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                line.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>用分而治之的思路来解决这个看似复杂的问题：先搞好根节点 递归的构建子节点</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">partBuild</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="keyword">int</span> rootpos,vector&lt;<span class="keyword">int</span>&gt;&amp;inorder,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;rootpos&lt;&lt;&quot; &quot;&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(rootpos&gt;=preorder.<span class="built_in">size</span>() || rootpos&lt;<span class="number">0</span>)<span class="comment">//|| left&gt;right</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[rootpos]);</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[rootpos]);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;res-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> inpos=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==preorder[rootpos])</span><br><span class="line">            &#123;</span><br><span class="line">                inpos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftlen = inpos-left;</span><br><span class="line">        <span class="keyword">if</span>(leftlen!=<span class="number">0</span>)<span class="comment">//记得给两个子树加条件 未必有子树</span></span><br><span class="line">            res-&gt;left = <span class="built_in">partBuild</span>(preorder,rootpos+<span class="number">1</span>,inorder,left,inpos<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(inpos+<span class="number">1</span>&lt;=right)<span class="comment">//救命 debug了半天 或者注释掉两个if 在开头加上 </span></span><br><span class="line">            res-&gt;right = <span class="built_in">partBuild</span>(preorder,rootpos+leftlen+<span class="number">1</span>,inorder,inpos+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partBuild</span>(preorder,<span class="number">0</span>,inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>复习preorder</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode*ptr=root;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        vector&lt;TreeNode*&gt; vec;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() || ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">                stk.<span class="built_in">push</span>(ptr);</span><br><span class="line">                ptr=ptr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            ptr=ptr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vec.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr-&gt;right=vec[i];</span><br><span class="line">            ptr-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">            ptr=ptr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一边遍历一边修改树的难点在于同时保存左右节点的信息</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        TreeNode* prev=<span class="literal">nullptr</span>,*curr=<span class="literal">nullptr</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            curr= stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(prev)</span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">                prev-&gt;right=curr;</span><br><span class="line">            &#125;</span><br><span class="line">            prev=curr;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right)</span><br><span class="line">                stk.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left)</span><br><span class="line">                stk.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最理想的状态是 原地完成 关键是找前驱：<strong>在前序遍历中 左子树最右侧的节点是右子树的前驱</strong></p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)  </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* curr=root,*next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                next=curr-&gt;left;</span><br><span class="line">                <span class="keyword">auto</span> pred = next;</span><br><span class="line">                <span class="keyword">while</span>(pred-&gt;right)</span><br><span class="line">                    pred=pred-&gt;right;</span><br><span class="line">                pred-&gt;right=curr-&gt;right;</span><br><span class="line">                curr-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">                curr-&gt;right=next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a></h4><p>利用分治的思想分析的时候还应该考虑完整的情况 比如作为答案最大值有几种来源（根，根和子树之一，绕过根两棵子树，子树），以及作为子树路径最大值有几种可能（根本身，根和其中一棵子树）</p>
<p>多次提交失败中没有注意到的情况：</p>
<p>子树不能增益</p>
<p>根不能增益</p>
<p>最大值来源于：仅有根，根和两棵子树。根和单边子树</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftres=<span class="number">0</span>,rightres=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            leftres = <span class="built_in">reverse</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            rightres = <span class="built_in">reverse</span>(root-&gt;right);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,root-&gt;val+leftres+rightres);<span class="comment">//经过根节点</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans,root-&gt;val);<span class="comment">//只有根节点</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">max</span>(leftres,rightres)+root-&gt;val);<span class="comment">//经过单边</span></span><br><span class="line">        <span class="comment">//ans = max(ans)</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span>(leftres,rightres)&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val+<span class="built_in">max</span>(leftres,rightres);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (root-&gt;val&gt;<span class="number">0</span>)?root-&gt;val:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="*236. Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">*236. Lowest Common Ancestor of a Binary Tree</a></h4><p>递归</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line"><span class="comment">//两侧检查 向上传递 只在有交汇的地方更新 剩下的不管 只管传递</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> lson = <span class="built_in">DFS</span>(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">bool</span> rson = <span class="built_in">DFS</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>((lson &amp;&amp; rson)||</span><br><span class="line">        ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val)&amp;&amp;(lson || rson)) )&#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lson || rson || root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表记录父亲节点 再记录是否被遍历过 出现重复遍历的就返回</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,TreeNode*&gt; father;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            father[root-&gt;left-&gt;val]=root;</span><br><span class="line">            <span class="built_in">DFS</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            father[root-&gt;right-&gt;val]=root;</span><br><span class="line">            <span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        father[root-&gt;val]=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            visited[p-&gt;val]=<span class="literal">true</span>;</span><br><span class="line">            p = father[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[q-&gt;val]==<span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            q = father[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. Serialize and Deserialize Binary Tree"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. Serialize and Deserialize Binary Tree</a></h4><p>复习了层次遍历 关键在于存入空指针是无法构成联系的</p>
<p>复习了一些库的使用 包括利用stringstream以指定分割符分割字符串，int和string的互相转换</p>
<h4 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. Path Sum III</a></h4><p>原本的思路 用哈希表记录可能的结果——空间优化 记录需要的</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rootSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum) &#123;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        ret += <span class="built_in">rootSum</span>(root-&gt;left, targetSum - root-&gt;val);</span><br><span class="line">        ret += <span class="built_in">rootSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">rootSum</span>(root, targetSum);</span><br><span class="line">        ret += <span class="built_in">pathSum</span>(root-&gt;left, targetSum);</span><br><span class="line">        ret += <span class="built_in">pathSum</span>(root-&gt;right, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>沿用类似的思路 是否加上自己本身 可以折叠成递归</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//k=true 不包括本节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum,<span class="keyword">bool</span> k=<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root? (</span><br><span class="line">            <span class="built_in">pathSum</span>(root-&gt;left,targetSum-root-&gt;val,<span class="literal">false</span>)</span><br><span class="line">            +<span class="built_in">pathSum</span>(root-&gt;right,targetSum-root-&gt;val,<span class="literal">false</span>) </span><br><span class="line">            +(k?(<span class="built_in">pathSum</span>(root-&gt;left,targetSum,<span class="literal">true</span>)<span class="comment">//有不包括的情况才能计入</span></span><br><span class="line">                +<span class="built_in">pathSum</span>(root-&gt;right,targetSum,<span class="literal">true</span>))</span><br><span class="line">            :<span class="number">0</span>)+(root-&gt;val==targetSum?<span class="number">1</span>:<span class="number">0</span>)</span><br><span class="line">        ):<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//空间打败的多</span></span><br></pre></td></tr></table></figure>

<p>前缀和：记录根节点到当前节点的路径上 除去当前节点自身之外节点和</p>
<p>如果有一个节点n 其前缀和为curr 如果n到root路径上存在p点，前缀和为 curr-targetSum 那么p到n和为targetSum</p>
<p>有类似之前线性的一道题 记录本身 找与目标差值的key的哈希表用法</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">long</span> <span class="keyword">long</span> ,<span class="keyword">int</span>&gt; prefix;<span class="comment">//curr对应的路径条数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> curr,<span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        curr+=root-&gt;val;<span class="comment">//accumulate</span></span><br><span class="line">        <span class="keyword">if</span>(prefix.<span class="built_in">count</span>(curr-targetSum))</span><br><span class="line">            ret = prefix[curr-targetSum];</span><br><span class="line">        <span class="comment">//search</span></span><br><span class="line">        prefix[curr]++;</span><br><span class="line">        ret+=<span class="built_in">dfs</span>(root-&gt;left,curr,targetSum);</span><br><span class="line">        ret+=<span class="built_in">dfs</span>(root-&gt;right,curr,targetSum);</span><br><span class="line">        prefix[curr]--;<span class="comment">//从当前路径退出 避免干扰其他路径计数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        prefix[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//ini 假设一开始root-&gt;val==targetSum</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root,<span class="number">0</span>,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a></h4><p>分析清除返回值的含义 争取一次bug free</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sideLongest</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">sideLongest</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right= <span class="built_in">sideLongest</span>(root-&gt;right);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,right+left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sideLongest</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="538-Convert-BST-to-Greater-Tree"><a href="#538-Convert-BST-to-Greater-Tree" class="headerlink" title="538. Convert BST to Greater Tree"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a></h4><p>可以原地！按照右中左反中序遍历 只需要累加并且把值赋予节点就可以</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//可以原地</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">convertBST</span>(root-&gt;right);</span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        root-&gt;val=sum;</span><br><span class="line">        <span class="built_in">convertBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></h4><p>深度优先 更简洁</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1)  </span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(!root2)</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root1-&gt;val+root2-&gt;val);</span><br><span class="line">        root-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>广度优先 用牵引避免空指针 小心空指针的条件</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> merged = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(t1-&gt;val + t2-&gt;val);</span><br><span class="line">        <span class="keyword">auto</span> q = queue&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">auto</span> queue1 = queue&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">auto</span> queue2 = queue&lt;TreeNode*&gt;();</span><br><span class="line">        q.<span class="built_in">push</span>(merged);</span><br><span class="line">        queue1.<span class="built_in">push</span>(t1);</span><br><span class="line">        queue2.<span class="built_in">push</span>(t2);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.<span class="built_in">empty</span>() &amp;&amp; !queue2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(), node1 = queue1.<span class="built_in">front</span>(), node2 = queue2.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            queue1.<span class="built_in">pop</span>();</span><br><span class="line">            queue2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">auto</span> left1 = node1-&gt;left, left2 = node2-&gt;left, right1 = node1-&gt;right, right2 = node2-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (left1 != <span class="literal">nullptr</span> || left2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left1 != <span class="literal">nullptr</span> &amp;&amp; left2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(left1-&gt;val + left2-&gt;val);</span><br><span class="line">                    node-&gt;left = left;</span><br><span class="line">                    q.<span class="built_in">push</span>(left);</span><br><span class="line">                    queue1.<span class="built_in">push</span>(left1);</span><br><span class="line">                    queue2.<span class="built_in">push</span>(left2);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    node-&gt;left = left1;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    node-&gt;left = left2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right1 != <span class="literal">nullptr</span> || right2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right1 != <span class="literal">nullptr</span> &amp;&amp; right2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(right1-&gt;val + right2-&gt;val);</span><br><span class="line">                    node-&gt;right = right;</span><br><span class="line">                    q.<span class="built_in">push</span>(right);</span><br><span class="line">                    queue1.<span class="built_in">push</span>(right1);</span><br><span class="line">                    queue2.<span class="built_in">push</span>(right2);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    node-&gt;right = right1;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node-&gt;right = right2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. Binary Tree Zigzag Level Order Traversal</a></h4><p>注意是整体的排序 需要用到栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            Stack&lt;TreeNode&gt; nextline = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">                TreeNode node = stk.pop();</span><br><span class="line">                <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(cnt%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                        nextline.push(node.left);</span><br><span class="line">                        nextline.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        nextline.push(node.right);</span><br><span class="line">                        nextline.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!list.isEmpty())</span><br><span class="line">                ans.add(list);</span><br><span class="line">            stk.addAll(nextline);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更简单的办法：层序遍历 在最终结果中取奇数位置的list倒序遍历</p>
<h4 id="987-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#987-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="987. Vertical Order Traversal of a Binary Tree"></a><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. Vertical Order Traversal of a Binary Tree</a></h4><p>自定义排序</p>
<p>注意自定排序的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="number">0</span>,<span class="number">0</span>,nodes);</span><br><span class="line">        Collections.sort(nodes,<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] tuple1,<span class="keyword">int</span>[] tuple2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tuple1[<span class="number">0</span>]!=tuple2[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">return</span> tuple1[<span class="number">0</span>]-tuple2[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tuple1[<span class="number">1</span>]!=tuple2[<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> tuple1[<span class="number">1</span>]-tuple2[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span>    </span><br><span class="line">                    <span class="keyword">return</span> tuple1[<span class="number">2</span>]-tuple2[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastCol = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] tuple : nodes)&#123;</span><br><span class="line">            <span class="keyword">int</span> col = tuple[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> row = tuple[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> val = tuple[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(col!=lastCol)&#123;</span><br><span class="line">                lastCol = col;</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.get(size-<span class="number">1</span>).add(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> row,<span class="keyword">int</span> col,List&lt;<span class="keyword">int</span>[]&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] info = &#123;col,row,root.val&#125;;  </span><br><span class="line">        nodes.add(info);</span><br><span class="line">        dfs(root.left,row+<span class="number">1</span>,col-<span class="number">1</span>,nodes);</span><br><span class="line">        dfs(root.right,row+<span class="number">1</span>,col+<span class="number">1</span>,nodes);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Algo</tag>
      </tags>
  </entry>
  <entry>
    <title>Batch-AW06</title>
    <url>/post/27c8219b/</url>
    <content><![CDATA[<h2 id="Task-to-do"><a href="#Task-to-do" class="headerlink" title="Task to do"></a>Task to do</h2><p>读样例代码+看课程其他讲解样例视频</p>
<p>作业思路： 把aw04中的product来源换成batch任务写入的数据库</p>
<p>aw04的数据结构可能需要重构 如product</p>
<p>More： Faster！——Parallel！</p>
<h2 id="Read-Example-Code"><a href="#Read-Example-Code" class="headerlink" title="Read Example Code"></a>Read Example Code</h2><h3 id="Service——batch流程工作流程用到的基本服务"><a href="#Service——batch流程工作流程用到的基本服务" class="headerlink" title="Service——batch流程工作流程用到的基本服务"></a>Service——batch流程工作流程用到的基本服务</h3><p>ItemReader，ItemProcessor，ItemWriter是模板，有类型参数可供自定义，可以通过重载自定义前后预处理的流程</p>
<h4 id="JsonFilerReader"><a href="#JsonFilerReader" class="headerlink" title="JsonFilerReader"></a>JsonFilerReader</h4><ul>
<li><p><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.7/com/fasterxml/jackson/databind/ObjectMapper.html">ObjectMapper</a>：json和Plain Old Java Object互相转换</p>
</li>
<li><p><a href="https://fasterxml.github.io/jackson-databind/javadoc/2.8/com/fasterxml/jackson/databind/JsonNode.html">JsonNode</a>: json的数据被组织成树状，树的节点，样例中实现的ItemReader类型参数是JsonNode</p>
</li>
</ul>
<p>（Reader的原理？）</p>
<h4 id="JsonReader"><a href="#JsonReader" class="headerlink" title="JsonReader"></a>JsonReader</h4><p>和JsonFileReader的区别？</p>
<p>限定了filename </p>
<p><strong>todo: 因为至少有两个文件 所以需要正则表达式来写读取文件</strong></p>
<p>ClassPathResource(“data/xxx”)</p>
<h4 id="ProductProcessor"><a href="#ProductProcessor" class="headerlink" title="ProductProcessor"></a>ProductProcessor</h4><p>利用objectMapper的treeToValue函数转换成Product类，注意Product类的成员应该和json的格式对应</p>
<h4 id="ProductWriter"><a href="#ProductWriter" class="headerlink" title="ProductWriter"></a>ProductWriter</h4><p>重载write方法——todo：写入到数据库中，或许可以参考aw04</p>
<p><a href="https://docs.spring.io/spring-batch/docs/current/reference/html/index.html">官方Spring Batch入门文档</a>，writer有一些与数据库相关的接口。</p>
<p>写入数据库 样例：<a href="https://spring.io/guides/gs/batch-processing/">spring-guides/gs-batch-processing</a></p>
<p>该样例用的hsqldb 是用于模拟、测试的位于内存的数据库</p>
<h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><h4 id="BatchConfig"><a href="#BatchConfig" class="headerlink" title="BatchConfig"></a>BatchConfig</h4><p>@EnableBatchProcessing</p>
<p>使用了线程池来管理step级别的工作；整个任务是一个job，job中读入/处理/写入是step</p>
<p><strong>todo: 可以尝试更多加速的并行方式</strong></p>
<h3 id="PartitionJob"><a href="#PartitionJob" class="headerlink" title="PartitionJob"></a><a href="https://docs.spring.io/spring-batch/docs/current/reference/html/scalability.html#partitioning">PartitionJob</a></h3><p>数据分割成并行的块，有masterStep负责同步，masterStep履行了PartitionHandler的职责，设定了gridSize（？）</p>
<p>Partitioner是示意图中的StepExecutionSplitter，负责</p>
<p>Partitioner 负责分割资源，此处因为要读取的文件不止一个所以用了MultiResourcePartitioner，并且通过正则表达式来指定文件（PathMatchingResourcePatternResolver)</p>
<p>ItemReader要接收的文件格式不是原本的文件，而是经过分割的，所以用Value注解进行了注释说明</p>
<h2 id="Tech-Solution"><a href="#Tech-Solution" class="headerlink" title="Tech Solution"></a>Tech Solution</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>原有的product和amazon导入的AmazonProduct分离，repository之上套一层posDB服务进行类型转换</p>
<h4 id="对aw06（Batch）："><a href="#对aw06（Batch）：" class="headerlink" title="对aw06（Batch）："></a>对aw06（Batch）：</h4><p>确认使用何种数据库</p>
<p>找到写入数据库的方式</p>
<h4 id="对aw04原有代码（Amazon-webpos）："><a href="#对aw04原有代码（Amazon-webpos）：" class="headerlink" title="对aw04原有代码（Amazon-webpos）："></a>对aw04原有代码（Amazon-webpos）：</h4><ul>
<li>单机模式下运行 redis和jdbc的关系？能写入redis吗 不能切换成jdbc<ul>
<li>cache原本是用于存储从网上拉取的product信息的，原本使用的redis是用于存session的，因此redis部分并不干扰</li>
</ul>
</li>
</ul>
<p>aw04中的db 新写一个posDB的实现代替原本的JD-PosDB</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p><strong>跑起来就花了很多时间</strong></p>
<p><em>看样例代码的时候需要关注说明！</em>有一些环境需要配置的，如添加建立数据库的脚本</p>
<p>数据库写入的数据具有原子性，而product结构中有list，因此被迫放弃使用jdbc+sql硬编码语句，转向抽象程度更高的CrudRepository+h2db，但是依旧要解决写入list的问题。</p>
<p><em>仔细看报错，分析原因；搜索提问的时候问题描述需要准确，可以更快的解决问题</em></p>
<p><a href="https://stackoverflow.com/questions/5867130/how-to-persist-a-list-of-strings-in-hibernate">How to persist a List of String in Hibernate</a></p>
<p>jsonType推荐  <a href="https://www.baeldung.com/hibernate-types-library">A Guide to the Hibernate Types Library</a></p>
<p>检查是否写入数据库——下载一个h2客户端来独立检查，因为没有spring-boot web无法用浏览器打开</p>
<p><a href="https://www.yawintutor.com/table-batch_job_instance-not-found-sql-statement/">bad SQL grammar [SELECT JOB_INSTANCE_ID, JOB_NAME from BATCH_JOB_INSTANCE where JOB_NAME = ? and JOB_KEY = ?]</a></p>
<ul>
<li><p>成功连上数据库 可以用持久化文件来检查 暂时用jdbc:h2:mem:testdb来确认是否写入</p>
<ul>
<li>直接h2客户端查看更快</li>
<li>testdb没有写入，直接用文件来持久化。还可以看到dbtrace，方便调试</li>
<li>下载解压后进入h2文件夹运行./h2.sh脚本即可</li>
</ul>
</li>
<li><p>但是没有能写入数据——果然问号是因为是空值 为什么会是空值呢</p>
<ul>
<li>控制台问号不是空值 是h2数据库需要重启脚本来刷新 才能读取到正确的文件</li>
</ul>
</li>
</ul>
<h4 id="数据存储的方式"><a href="#数据存储的方式" class="headerlink" title="数据存储的方式"></a>数据存储的方式</h4><p>对于简单的非list的部分，直接存在指定的表amazon_product中；对于List&lt;String&gt;部分，新建表格存储，一对多的关系转换成多个一对一关系</p>
<p>List&lt;String&gt;在代码中如何配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(ignoreUnknown = true)</span><span class="comment">//写表时如果无法识别就填null 是兜底的操作</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;amazon_products&quot;)</span><span class="comment">//简单属性会直接存入这张表 list属性会在同层生成其他表 实际可以用join来获取信息</span></span><br><span class="line"><span class="meta">@TypeDefs(&#123;</span></span><br><span class="line"><span class="meta">    @TypeDef(name = &quot;json&quot;, typeClass = JsonStringType.class)//使用hibernate扩展的属性来写入List&lt;String&gt; 定义别名</span></span><br><span class="line"><span class="meta">    //@TypeDef(name = &quot;json&quot;, typeClass = JsonType.class)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"> <span class="meta">@ElementCollection</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;imageURL&quot;,columnDefinition = &quot;json&quot;)</span><span class="comment">//指明列名和类型</span></span><br><span class="line">    <span class="meta">@Type(type = &quot;json&quot;)</span><span class="comment">//该类型需要引入hibernate的扩展包并且用注解定义别名才能使用</span></span><br><span class="line">    <span class="meta">@Getter</span><span class="comment">//不能省略 供外界调用</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; imageURLHighRes;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<p><a href="https://howtodoinjava.com/hibernate/hibernate-insert-query-tutorial/">https://howtodoinjava.com/hibernate/hibernate-insert-query-tutorial/</a></p>
<p><a href="https://stackoverflow.com/questions/32765893/storing-a-listsomeclass-as-json-in-a-text-field-with-hibernate">https://stackoverflow.com/questions/32765893/storing-a-listsomeclass-as-json-in-a-text-field-with-hibernate</a></p>
<p><a href="https://www.baeldung.com/hibernate-persist-json-object">https://www.baeldung.com/hibernate-persist-json-object</a></p>
<p><a href="https://www.concretepage.com/spring-5/spring-data-crudrepository-example">https://www.concretepage.com/spring-5/spring-data-crudrepository-example</a></p>
<h3 id="Amazon-webpos读取数据"><a href="#Amazon-webpos读取数据" class="headerlink" title="Amazon-webpos读取数据"></a>Amazon-webpos读取数据</h3><p>命名并指定注入的组件</p>
<p>Amazon-webpos读取失败：</p>
<p>原来是设置了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.batch.jdbc.initialize-schema=never/always</span><br></pre></td></tr></table></figure>

<p>h2每次连接都会刷新（照搬了batch的配置），在batch中应当刷新，但是读取的时候不应该改动。</p>
<p>crudRepository是很方便可靠的架构，出问题应该先检查数据是否有问题——发现持久化文件被清空了。</p>
<h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h2><p>大部分时间花在了接入数据库上，batch工作的原理只是大概了解了流程，学会了重载writer，更多的parallel的性质还没有探索。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始写简历</title>
    <url>/post/cbfb1047/</url>
    <content><![CDATA[<p>这里的从零是字面意思，不管是刚开始找实习的同学，还是因为考研不幸落榜匆忙投入春招的同学，这篇文章是为之前完全没有写过简历的你准备的！</p>
<p>这一篇是对我实习经验分享中写简历部分的具体拓展，对其他内容感兴趣也可以<a href="https://njucs.top/internet_company_pratice/">移步</a>。</p>
<h2 id="前期准备——拉清单"><a href="#前期准备——拉清单" class="headerlink" title="前期准备——拉清单"></a>前期准备——拉清单</h2><p>清单内容如下：</p>
<ul>
<li>所有专业相关课程<ul>
<li>不管你认为有多水都要写出来</li>
<li>有项目/课设/代码的课程要把代码和实验报告找到；整理好上传到Github/博客上，之后根据简历排布情况置顶重要项目的仓库</li>
<li>如果没有代码等材料，尽量回忆课程主要内容，列出大纲</li>
</ul>
</li>
<li>所有专业相关活动<ul>
<li>大创、技术社团活动、数模比赛、美赛等</li>
<li>专业内容弱相关的活动可以记下来，只是写进简历的优先级比上述略低</li>
</ul>
</li>
<li>考过的证书<ul>
<li>四六级成绩证明，雅思托福（如果有）</li>
<li>或者你认为能体现你能力的其他证书</li>
</ul>
</li>
</ul>
<h2 id="开始动笔"><a href="#开始动笔" class="headerlink" title="开始动笔"></a>开始动笔</h2><p>先来看一份来自CMU的简历</p>
<img src="/post/cbfb1047/image-20230322211658324.png" class title="image-20230322211658324">

<p>是不是看起来很简洁很干货？我原来用的工具现在有人反映总是会泄露个人隐私，就不推荐了。可以使用Overleaf或者自行查找类似模板。</p>
<p>好的，现在让我们来写简历，争取像上述简历一样一页写完 (*^_^*)</p>
<ul>
<li>教育背景<ul>
<li>专业相关课程可以放到技能里，或者参考CMU简历里的写法，分数特别高的课程请大胆亮出分数！</li>
<li>课程不需要写出具体内容，留名即可（具体内容面试时再拓展，<del>留有悬念</del>）</li>
<li>校园活动和个人荣誉可以放到简历末端，因为没有写也没关系（说的就是我这种没有拿得出手奖学金的人</li>
</ul>
</li>
<li>项目经历<ul>
<li>总结项目内容的时候可以参照STAR（Situation-Task-Action-Result）原则，写的时候不妨动词开头，紧跟结果；Situation和Task可以作为补充</li>
<li>使用的技术框架放在一句话的开头能更好的抓住HR的视线。如果技术点比较多，可以写项目中使用多的、你有把握的、符合岗位要求的技术</li>
<li>措辞公式：工具+做了个什么东西+这个东西的功能：<ul>
<li>如果一行总结不完，可以参考CMU简历，一句话总结项目中的一个模块</li>
<li>eg：使用C语言，在Linux上模拟实现操作系统中的FAT12文件系统。程序能够生成、加载二进制磁盘镜像，将文件读取、写入到磁盘</li>
</ul>
</li>
<li>从清单里列出的各种课程中，优先选和岗位匹配的、参与度高的、写了代码的</li>
<li>可以把你认为重要的项目排在上面，吸引面试官提问，觉得不够有分量的放在下端撑场面；<strong>简历里附上github链接更有说服力</strong></li>
</ul>
</li>
<li>技能可以写框架/语言，可以不涉及详细内容<ul>
<li>eg：算法分析与设计、数据结构，计算机网络，操作系统， 数据库</li>
<li>顺序也很重要，不太有把握的可以往后面写</li>
</ul>
</li>
</ul>
<h2 id="根据简历准备"><a href="#根据简历准备" class="headerlink" title="根据简历准备"></a>根据简历准备</h2><p>目标是：</p>
<ul>
<li>了解简历上的项目不至于被问麻</li>
<li>引导面试官向你更熟悉的方向提问</li>
</ul>
<p>准备项目相关的八股，可以参考<a href="https://njucs.top/internet_company_pratice/#%E7%AE%80%E5%8E%86">这篇</a></p>
<img src="/post/cbfb1047/Reflection-Quesiton-For-Project.png" class title="Reflection-Quesiton-For-Project">

<p>如果你的项目内容有更经典的实现，比如编译器、操作系统、现实中的商城系统等，可以去学习经典代码的写法，思考如何让你的项目向经典接近，下个模块中这种分析训练会派上大用场。</p>
<h3 id="如果真的问到我不会的怎么办？"><a href="#如果真的问到我不会的怎么办？" class="headerlink" title="如果真的问到我不会的怎么办？"></a>如果真的问到我不会的怎么办？</h3><p>就算认真准备了也不可能面面俱到，被问到不懂太正常了。关键是<strong>Think Out Loud</strong>——大胆的说出你的分析</p>
<p>实习或者是校招的同学是不可能什么都知道的，重点是展现出你：</p>
<ul>
<li>有分析、拆解问题的能力；</li>
<li>懂得学习经典方案的思路，活用解决现实问题；</li>
<li>能够把看起来笨的办法通过逐步优化找到更好的方案。</li>
</ul>
<p>所以一定要大胆的说出你的分析，即便你认为自己一开始提出来的方法很笨也没关系，像做算法题一样逐步去优化，展现出思路，这总比你真的在面试中沉默要好太多。</p>
<h2 id="写在最后——一点鸡汤"><a href="#写在最后——一点鸡汤" class="headerlink" title="写在最后——一点鸡汤"></a>写在最后——一点鸡汤</h2><p>除我之外，第一位按照如上思路准备简历的是我的发小，一位不幸落榜还被考研耽搁所以无实习经历的西电射频方向（偏硬件）的本科同学；在我给她呕心沥血地倾吐我的血泪教训之后，她最终在两周的时间里顺利拿到年包18w+的offer。希望我的经验也能如此帮到你~(^_^)~</p>
<p>有问题可以评论留言or给我发<a href="mzl0830@sina.com">邮件</a></p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>FAT12 File System</title>
    <url>/post/7f6e4fde/</url>
    <content><![CDATA[<h1 id="FAT12-File-System"><a href="#FAT12-File-System" class="headerlink" title="FAT12 File System"></a>FAT12 File System</h1><h2 id="DAY-3-1"><a href="#DAY-3-1" class="headerlink" title="DAY-3~1"></a>DAY-3~1</h2><blockquote>
<p>出现负数是之前的时间一直在厘清思路，并没有很大的进展</p>
</blockquote>
<p>大致框架：在main函数内初始化一个模拟磁盘的数据结构，作为FAT12文件系统，在支持输入和输出。目前给定的测试目标是存入文件并且读取。</p>
<p>由于使用的是内存的堆栈的空间，实际上在每次退出程序之后模拟文件系统中的内容都不会保存。阅读别人的代码以后，进行改进：把模拟磁盘的内容使用文件读写写进一个二进制文件（镜像），在程序运行的时候进行装载。</p>
<blockquote>
<p>不要想着一口吃成胖子！可以先入手的是固定数据结构的实现</p>
</blockquote>
<p>运行逻辑：main函数内接受指令，对模拟磁盘进行操作（模拟磁盘是一个大小与为1.44MB的char型数组，这就意味着以字节为单元），在程序结束时将该模拟磁盘数组的内容写入指定的二进制文件，在程序开始时反之装载二进制文件的内容到模拟磁盘数组。</p>
<p>对连续空间的操作：逐个字节搬运数据；在设计数据结构的时候使用union，使得结构同时具有字符数组的形式，通过对每个字节进行操作来完成读写盘。（ICS的pa中其实有类似的思路，文艺复兴！）</p>
<p>首先实现的读写操作如下：</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将bootsector结构体中的数据写入缓存磁盘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write_rmdisk_bootsector</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ramdisk,<span class="keyword">const</span> BootSector* mbr)</span></span>;</span><br><span class="line"><span class="comment">//从缓存磁盘中读出数据到bootsector结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read_rmdisk_bootsector</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*ramdisk,BootSector*mbr)</span></span>;</span><br><span class="line"><span class="comment">//从磁盘中指定块读出一个数据块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read_rmdisk_block</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* ramdisk,<span class="keyword">unsigned</span> <span class="keyword">int</span> index,<span class="keyword">unsigned</span> <span class="keyword">char</span>* block)</span></span>;</span><br><span class="line"><span class="comment">//将一个数据块写入到指定块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write_rmdisk_block</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ramdisk,<span class="keyword">unsigned</span> <span class="keyword">int</span> index,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*block)</span></span>;</span><br><span class="line"><span class="comment">//将缓存磁盘的数据写入到磁盘文件中 成功返回0 否则-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Write_rmdisk</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ramdisk,string diskname)</span></span>;</span><br><span class="line"><span class="comment">//从一个磁盘文件中读取数据到缓存磁盘中 返回成功从文件中读入的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Read_rmdisk</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ramdisk,string diskname)</span></span>;</span><br><span class="line"><span class="comment">//打印bootsector的信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_bootsector</span><span class="params">(<span class="keyword">const</span> BootSector* mbr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>进行简单的测试，头部变化较少，相对数据区更加简单，先装载头部进行测试：</p>


<p><img src="/post/7f6e4fde/image-20210713152438835.png"></p>
<p><img src="/post/7f6e4fde/image-20210713152455925.png"></p>
<p>在编写过程中首次独立编写简单的makefile，学习在脱离vs这类保姆式开发环境的情况下独立编译模块组合。</p>
<p>关于字符串的bug调了很久，const char*需要逐个赋值，后来被迫动手改造strcpy，注意strlen计算的是终止符之前的字符个数，所以未赋值的静态字符数组是无法通过strlen获得预定分配的空间的</p>
<p>优先实现具有代表性的个命令</p>
<ul>
<li>mkdir: 创建文件夹 实际上包含再已有情况下新建和直接新建两种情况，对应着查找指定目录和新建目录两个任务<ul>
<li>分解路径，根据当前路径名找到对应的cluster，在当前cluster继续查找，直到无法找到为止（目标是支持建立不止一层新文件夹 即在只有./a的情况下mkdir ./a/b/c也支持）如果能找到说明已经存在</li>
<li>在父文件夹cluster下补充信息，即新建新的entry，有必要就使用新的cluster（似乎应当交给函数封装实现）</li>
<li>分配新的cluster给将要建立的子目录</li>
</ul>
</li>
<li>touch 新建文件<ul>
<li>同上 分解路径 找到最近一级存在的父目录</li>
<li>如果是需要建立目录，那么同上；最后一段被<code>/</code>分割的默认为文件名，无论是否有<code>.</code>做分割</li>
</ul>
</li>
<li>edit 编辑文件<ul>
<li>根据文件路径 逐步拆分找到入口cluster并逐步遍历找到最后一个cluster</li>
<li>从标准输入读入 存放在临时空间中，根据偏移量判断是否需要新的cluster来存放</li>
</ul>
</li>
<li>cat 输出文件<ul>
<li>根据文件路径拆分找到入口cluster 一边遍历一边输出 直到计数器等于文件大小</li>
</ul>
</li>
</ul>
<p>实现过程：</p>
<p>0718</p>
<p>从mkdir开始实现 对位操作不太熟悉（之前ICS PA基础还不够扎实）对具体的模块也没有头绪 借鉴了代码 补齐了一些按照给定数据结构读写磁盘内容的基本操作，本质是把结构体内的成员根据字符串/数字逐个读取填写（即底层实现是两个parse数据结构的函数）</p>
<p>争取之后实现其他命令的时候把文字思路转换成伪代码，这样就能更好的确定各板块的共同需求 方便划分函数功能。</p>
<p>另外没有对新写的模块进行编译测试 磁盘FAT部分的初始化也没有完成 还有函数没有完成</p>
<p>0729 </p>
<p>花了很长时间写mkdir的指令，因为需要补充很多底层的指令。调试的时候发现段错误，于是用gdb调试；为了及时看到源码，对每一个模块都用了-g参数便于调试。</p>
<p>编译的时候因为typo， debug了很久，后来总是显示找不到新加入的cmd内的函数，检查发现makefile内编译主体程序的编译命令没有包含cmd.o</p>
<p>在认为有问题的函数打断点直接执行来缩小范围，后来怀疑是在parsePath的strcpy出现问题，因为一开始char entname[12] 编译没有通过改成了 char* entname，怀疑没有分配足够的空间导致栈溢出，于是改成用动态数组分配，问题解决</p>
<p>调试的时候遇到了输入第二个命令会 <code>*** stack smashing detected ***: terminated Aborted (core dumped)</code> </p>
<p>0730</p>
<p>先把剩下的命令全部实现，其中在写edit命令的时候学到一个函数<a href="https://www.cplusplus.com/reference/cstdio/fgets/"><strong>fget</strong></a>的用法,支持逐个字节读入数据并写入磁盘</p>
<h2 id="Sum-up"><a href="#Sum-up" class="headerlink" title="Sum up"></a>Sum up</h2><p>第一次在没有框架代码的情况下写这样的小系统。通过阅读别人的代码和自己设计实现逐步理清了框架和各个函数的功能与实现。项目管理的缺失让coding的进展非常不稳定。下个学期上课应该多注意这一方面的训练。</p>
<p>断断续续做了一个月，还有一些小bug没有调试。之后有空再来填坑</p>
<p>项目代码：（因为网络问题暂时没有同步，回校再填坑）</p>
<p>参考文献：</p>
<p><a href="https://zhuanlan.zhihu.com/p/122569192">https://zhuanlan.zhihu.com/p/122569192</a></p>
<p><a href="https://blog.csdn.net/yxc135/article/details/8769086">https://blog.csdn.net/yxc135/article/details/8769086</a></p>
<p><a href="https://reeeeeeeeeein.github.io/2020/04/15/fat12%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">https://reeeeeeeeeein.github.io/2020/04/15/fat12%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</a></p>
<p><a href="https://github.com/warpmatrix/fat12-file-system">https://github.com/warpmatrix/fat12-file-system</a> useful</p>
<p><a href="https://blog.csdn.net/Laichilueng/article/details/54669370?utm_medium=distribute.pc_relevant_download.none-task-blog-2~default~searchFromBaidu~default-7.test_version_3&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-2~default~searchFromBaidu~default-7.test_version">https://blog.csdn.net/Laichilueng/article/details/54669370?utm_medium=distribute.pc_relevant_download.none-task-blog-2~default~searchFromBaidu~default-7.test_version_3&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-2~default~searchFromBaidu~default-7.test_version</a>_</p>
<p><a href="https://zhuanlan.zhihu.com/p/121807427">https://zhuanlan.zhihu.com/p/121807427</a> 给出参数具体值</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Google2021STEP 失败小结</title>
    <url>/post/c243b9f0/</url>
    <content><![CDATA[<h2 id="初期准备"><a href="#初期准备" class="headerlink" title="初期准备"></a>初期准备</h2><p>起初真就见财起意，但是由于本人执行力太差，大一下在家期间原本希望的早起刷题并没有实现，暑假又以准备开学考试为由没有刷题，真正刷题是大二上学期在决定申请之后，刷力扣大概一两个月的时间，算法面试题的集合中动态规划几乎没做（划重点这里会考！），其他部分做了七七八八。但是完成度不高，不够精细，基本都是先想一会然后看答案，如果不太难就自己复刻，太难没耐心想就会理解之后copy。而且重难点的题目没有多次巩固。一方面是时间问题，刷题的时间集中在了复习周+美赛爆肝期间（不过事实证明时间确实是海绵里的水，没空是因为还不够渴望）；另一方面是方法问题，由于对需要达到怎样的程度并没有清晰的认识，在钻研的深度上有所欠缺。</p>
<h2 id="软实力准备"><a href="#软实力准备" class="headerlink" title="软实力准备"></a>软实力准备</h2><p>写了简历，结合了自己做过的一些小项目和课程大作业（呜呜这里也划重点），但是简历当时写的不够精简。</p>
<p>找了HR姐姐给自己内推，之后出现情况也很及时的去push了 夸夸自己！</p>
<h2 id="本人搞笑实录"><a href="#本人搞笑实录" class="headerlink" title="本人搞笑实录"></a>本人搞笑实录</h2><p>留了两个邮箱，但是一直以来主要通过新浪联系，导致没发现最后最关键的通知面试信息投到谷歌邮箱去了，还好在朋友开始面试之后去问了hr姐姐 我是憨憨</p>
<p>不知道是否是回复面试通知确认时间太晚的原因，我第二天的上海base面试竟然被放鸽子了，于是只能过年后回来再面。我早早面完的同学第二天就收到了拒信orz</p>
<h2 id="手撕代码部分"><a href="#手撕代码部分" class="headerlink" title="手撕代码部分"></a>手撕代码部分</h2><h3 id="第一场-北京base"><a href="#第一场-北京base" class="headerlink" title="第一场 北京base"></a>第一场 北京base</h3><p><strong>Q: 有N个盒子，盒子内壁厚度不计，只有盒子长和宽大于等于另一个盒子的长和宽的时候能套盒，求能够套盒的最大数目</strong></p>
<p>与一般的排序不同，有两个维度，先对于长排序，然后考虑对宽思考，在面试官姐姐的提示下考虑用了动态规划的思路（还好我对记忆化搜索以及动态规划的名词有点印象），前一个盒子的最大套盒数=max{比它小的盒子的最大套盒数}+1 </p>
<p>思路理清楚之后上手写代码，同时用一些简单的测试用例来检查了一些小bug，（比如初始状态写错了）发现盒子宽度是逆序的时候会出现无法处理的情况，于是通过修改排序函数中比较大小的函数来规避 注意返回的逻辑变量与期望的大小是相反的 写完这些面试时间已经到了</p>
<p>总体来说，上来自我介绍的时候说了姓名学校入学时间，好死不死说了一句学过数据结构了 之后首先是问了实习会做什么 其次问了面试官对我有什么建议。面试官肯定了我的表达能力，但是说我的代码能力需要加强，可以多看看面经，我心里有一点点慌。貌似我踩雷了，不应该让面试官再回忆我的缺点的</p>
<h3 id="第二场-上海base"><a href="#第二场-上海base" class="headerlink" title="第二场 上海base"></a>第二场 上海base</h3><p><strong>Q： 计算N个数中，抽取k个数的最大和</strong></p>
<p>转换成求K个最大数，又转换成快速排序的算法，在面试官小哥哥的提醒下意识到K个最大数内不需要排序，所以在写出快速排序的基础上还需要进行修改。。然而我发现自己对快速排序理解还不够深刻，解释原理的时候磕磕绊绊，在解释分界线的时候误认为是一半之处，小哥哥还顺着我的话往下说真是呜呜呜谢谢不戳穿之恩。是否继续递归需要分情况讨论：较大一组数的数量大于/小于/等于K 根据需要停止/继续排序 算复杂度，我认为原本最终停下时的被排序的子数组长度是1，在本题情况下是n/k，所以结合原本快速排序的时间复杂度，本题版本的时间复杂度应该是 $$ O(nlog \frac{n}{k}) $$  面试官说应该要更小一些（惊恐的怀疑自己算错了，从语气中听出来的）。之后自己设计了一组简单的用例，但是只测试到了一种情况，还有一种来不及测试针对性的用例，于是面试官问了一些设计用例的测试思路。从数据规模，排列方式，k的大小选择上都说了一些。最后一个当我提到的时候面试官也正好开口了，说明是重点。</p>
<p>除了问题，开头还问了我的简历中的项目，问了消消乐 结果因为听不清加上英文没对上我还去翻了自己的简历才反应过来，自己的简历也要好好复习哇</p>
<p>基础功不扎实，回答的时候磕巴空白很多，写代码也卡了很久，天哪连基础的快速排序都磕磕绊绊的 虽然后来还坚强的走完了流程 但是我觉得听语气上来说 我应该是凉了。</p>
<p>之后只好意思问了提升自己的方法这个问题，得到的建议是偏工业方向的，做经典的项目，对比学习经典的代码来提高。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实是在结果没出来之前码字的，我心里残存的不甘心和渴望反映在了梦境里，我真是高考都没那么心心念念过。事实证明我的努力完全配不上我的在意。也罢，从在意的事情的失败上来学习面对失败，同时也学到很多面试小技巧，以及认识到了自己的诸多不足和five之处。谨以此警醒自己。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Owl at Dusk</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop实验一记录</title>
    <url>/post/f141b6ad/</url>
    <content><![CDATA[<h2 id="虚拟机环境准备"><a href="#虚拟机环境准备" class="headerlink" title="虚拟机环境准备"></a>虚拟机环境准备</h2><p>账户设置：采用虚拟机原有设置 没有新建账号</p>
<p>环境变量设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi ~/.bash_profile</span><br><span class="line"></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/bin/java <span class="comment">#需要查询本地Java安装地址 export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/bin/java //需要查询本地Java安装地址 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/hadoop/hadoop_installs/hadoop-2.7.7</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$JAVA_HOME</span>/lib:.</span><br></pre></td></tr></table></figure>

<p>下载安装ssh 确认启动</p>
<p>（由于和另一个实验环境冲突，尝试了修改，暂时未测试）</p>
<h2 id="Hadoop配置"><a href="#Hadoop配置" class="headerlink" title="Hadoop配置"></a>Hadoop配置</h2><p><a href="https://hadoop.apache.org/docs/r2.7.2/index.html">Apache Hadoop官方文档</a></p>
<p><a href="https://www.w3cschool.cn/hadoop/hadoop_command_reference.html">账户配置和基础指令指导</a></p>
<h3 id="填写配置文件"><a href="#填写配置文件" class="headerlink" title="填写配置文件"></a>填写配置文件</h3><p><a href="https://blog.csdn.net/u013232219/article/details/104429007">https://blog.csdn.net/u013232219/article/details/104429007</a></p>
<p><a href="https://www.jianshu.com/p/2138e473b909">https://www.jianshu.com/p/2138e473b909</a></p>
<p><a href="https://blog.51cto.com/u_13836096/2532831">带参数解读版本</a></p>
<h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#~/.bashrc etc/profile同理</span></span><br><span class="line">sudo vim ~/.bashsrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashsrc <span class="comment">#启动配置</span></span><br></pre></td></tr></table></figure>

<p>HADOOP_HOME应该填写hadoop安装的路径 这样在bash中可以直接使用hadoop命令</p>
<p>jdk 版本比较高 <a href="https://blog.csdn.net/weixin_43968936/article/details/102654353">弹出警告可以忽略不计</a></p>
<p>hadoop需要的java环境变量</p>
<p><code>/usr/lib/jvm/java-11-openjdk-amd64/bin/java</code> 而vscode java 需要的是 <code>/usr/lib/jvm/java-11-openjdk-amd64/bin/java</code></p>
<p>出现问题时可以在安装hadoop的文件夹下的logs中查看，也注意观察终端info信息中显示log写入的地方 出现问题及时打印log查看报错</p>
<h3 id="进行测试实验"><a href="#进行测试实验" class="headerlink" title="进行测试实验"></a>进行测试实验</h3><p> <a href="https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#copyFromLocal">指令文档</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start-all.sh</span><br><span class="line">jps <span class="comment">#查hadoop伪集群启动情况</span></span><br><span class="line">hadoop fs -ls /    <span class="comment">#先查看当前hdfs下的文件夹</span></span><br><span class="line">hadoop fs -mkdir /test-in <span class="comment">#创建文件夹</span></span><br><span class="line">hadoop fs -put /home/njucs/BigData/V.html /test-in <span class="comment">#移动文件到hadoop hdfs文件系统中指定文件夹下 注意本地文件夹的名字要写全 如果是在hadoop文件夹中操作的话</span></span><br><span class="line">tail -500 yarn-hadoop-resourcemanager-xxx <span class="comment">#显示前500个字节</span></span><br><span class="line">hadoop dfs -cat /V-out/part-r-00000 <span class="comment">#查看结果</span></span><br></pre></td></tr></table></figure>

<p><a href="https://hijiangtao.github.io/2014/02/19/wordcountrunning/">样例的运行方法指导</a> 样例程序wordcount在hadoop的share/hadoop/mapreduce下</p>
<p>可视化信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:50070/ 查看信息 端口是默认的</span><br><span class="line">http://localhost:8088/cluster  查看集群信息 ip和端口默认 </span><br></pre></td></tr></table></figure>

<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol>
<li><p>不要轻易使用format命令，会导致datanode无法启动，<a href="https://blog.csdn.net/aicyo8644/article/details/102063909?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.topblog&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.topblog">解决方案</a>是检查datanode和namenode的cluster-ID是否一致 最好直接删除</p>
</li>
<li><p>application中找不到正在运行的任务，参考<a href="https://blog.csdn.net/tangtang5156/article/details/40867759">解决方案</a>后，是yarn.xml没设置好</p>
</li>
</ol>
<h2 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h2><p>类别：添加或规范化License信息</p>
<p>位置：<code>pkg/ddc/goosefs/runtime_info.go</code></p>
<p>内容：在该文件头部添加或规范化License信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add upstream https://github.com/fluid-cloudnative/fluid.git</span><br><span class="line">git fetch upstream</span><br><span class="line">git merge upstream/master <span class="comment">#merge远程代码改动</span></span><br></pre></td></tr></table></figure>

<p>调试方法+远程提交方法见Chap4 PPT</p>
<p>主要是熟悉git的开源社区协作方法</p>
<p>/user/2021sz01/exp4-1.0-SNAPSHOT.jar</p>
<p>hadoop jar /user/2021sz01/exp4-1.0-SNAPSHOT.jar com.hadoop.KMeans /user/2021sz01/exp4-example</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发高级设施实现原理笔记</title>
    <url>/post/175000d5/</url>
    <content><![CDATA[<blockquote>
<p>vscode看java api的源码非常舒适 提供了跳转到指定源码的功能</p>
<p>结合Oracle的JAVA文档食用更佳</p>
<p><a href="https://www.baeldung.com/">Java相关api介绍网站推荐: Baeldung</a></p>
</blockquote>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a></h2><p>核心是sync，Sync类是基于AbstractQueueSynchonizer这一抽象接口实现的</p>
<h3 id="AbstractQueueSynchronizer"><a href="#AbstractQueueSynchronizer" class="headerlink" title="AbstractQueueSynchronizer"></a>AbstractQueueSynchronizer</h3><p>一个用链表实现的队列，对节点加自旋锁来实现synchronize。按照队列的性质，头部的节点会先获得申请锁的机会，但是不保证成功。</p>
<p>有state来存储状态，其中state是volatile的，即存储在内存中，立即更新，不存在写缓冲问题。</p>
<p>这里的加锁方式有exclusive/shared两种。实现上没有做显著区分</p>
<h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p>实现了上述接口，其中Count直接存储在了AbstractQueueSynchronizer（以下简称AQS）的state变量中。</p>
<p>CountDownLatch的countDown方法是调用sync的releaseShared方法实现的 而sync中又调用AQS的tryReleaseShared() 判断能否释放，如果能，就调用doReleaseShared()对队列里的节点做操作。具体会调整列表中节点的状态。</p>
<p>CountDownLatch的await方法是调用sync的tryAcquireSharedNanos方法实现的，其中有设置限时（这里以纳秒为单位）。除了返回之外还会抛出异常。sync的方法调用了AQS的tryAcquireShared ,doAcquireSharedNanos方法 try方法有三种状态，不成功（返回负数），shared mode成功但subsequent shared-mode acquisition不成功（返回0，这里理解成时序上接下来共享状态下的申请不成功），shared mode和subsequent shared-mode acquisition都成功</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><a href="https://www.baeldung.com/java-cyclic-barrier">CyclicBarrier</a></h2><p>cyclic表达了可以重复利用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties，Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure>

<p>parties代表参与的线程的数量，通过await登记到达了共同的阻塞状态（目的地）并进入阻塞，只有当参与的所有线程都调用await进入阻塞的时候，所有进程才能同时进入barrierAction所对应的操作。注意，和CountDownLatch不同的是，这里并没有新开一个总结的线程（类型是Runnable，是任务而非Thread线程），而是把最后一个进入阻塞状态的线程用来执行barrierAction</p>
<h3 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h3><p>实现重用依赖于Generation这个类。线程会阻塞，停止，因此用Generation来装载可以实现重用。Generation的实例被分配给哪一个线程是不确定的，而且可以有多个被分配给使用CyclicBarrier的线程，但是可以确定的是，同一时间只能有一个Generation是活跃中的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="comment">//是之前提及的可重用锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="comment">//Condition即java分配给每个对象的monitor相关数据结构，有notify notifyAll wait等方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/** The number of parties */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* The command to run when tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** The current generation */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Updates state on barrier trip and wakes up everyone.</span></span><br><span class="line"><span class="comment">     * Called only while holding lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// signal completion of last generation</span></span><br><span class="line">        trip.signalAll();<span class="comment">//condition中的方法，把所有线程都唤醒</span></span><br><span class="line">        <span class="comment">// set up next generation</span></span><br><span class="line">        count = parties;</span><br><span class="line">        generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets current barrier generation as broken and wakes up everyone.</span></span><br><span class="line"><span class="comment">     * Called only while holding lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        generation.broken = <span class="keyword">true</span>;</span><br><span class="line">        count = parties;</span><br><span class="line">        trip.signalAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可能抛出中断、超时 阻塞中断异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed,<span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException,BrokenBarrierException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">			<span class="comment">//引用 浅拷贝</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = --count;<span class="comment">//记录有线程到达目的地</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;<span class="comment">//最后一个到达的线程执行方法</span></span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                    nextGeneration();<span class="comment">//这一批结束了 进行更新 把状态重设</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();<span class="comment">//没有要做的最终操作也要把这一代结束</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();<span class="comment">//condition的方法 让当前线程等待</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();<span class="comment">//被打断了 而且当前一代没作废 主动作废</span></span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();<span class="comment">//如果出现意外上面的条件没执行 也要主动打断</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">ScheduledThreadPoolExecutor</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">extends ThreadPoolExecutor <span class="comment">//线程池 池化线程对应的资源 避免反复生成和销毁带来的代价</span></span><br><span class="line">implements ScheduledExecutorService<span class="comment">// extends ExecutorService 可以调度命令使得经历一段延迟之后再执行，或者阶段性的执行</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//case:</span></span><br><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://www.baeldung.com/thread-pool-java-and-guava">线程池系列介绍</a></p>
</blockquote>
<p>enable：激活 execute：执行</p>
<p>激活不一定执行，按照激活的顺序排队（FIFO）来被调度去提交执行</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211030113256401.png" alt="image-20211030113256401"></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html">Semaphore</a></h2><p>permits:允许调用的资源，如果没有permit，acquire方法会阻塞；release方法释放permit资源。Semaphore通常用来限制进入临界区的线程数量。lock可以认为是数量为1的semaphore</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//case</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     available.acquire();<span class="comment">//申请</span></span><br><span class="line">     <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (markAsUnused(x))</span><br><span class="line">       available.release();<span class="comment">//释放</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Not a particularly efficient data structure; just for demo</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">          used[i] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">return</span> items[i];</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部实现——Sync-extends-AbstractQueuedSynchronizer"><a href="#内部实现——Sync-extends-AbstractQueuedSynchronizer" class="headerlink" title="内部实现——Sync extends AbstractQueuedSynchronizer"></a>内部实现——Sync extends AbstractQueuedSynchronizer</h3><p>利用了AQS，与CountDownLatch类似，permit的数量被state记录</p>
<p>acquire方法调用了Sync的acquireSharedInterruptibly，实际调用了AQS的tryAcquireShared和doAcquireSharedInterruptibly，与CountDownLatch类似。</p>
<p>release方法调用了Sync的releaseShared，实际调用了AQS的tryReleaseShared和doReleaseShared</p>
<blockquote>
<p>综合来看，在涉及数量的同步上，都利用了AQS 这里信号量的逻辑和AQS的逻辑基本一致，申请的到就继续，申请不到即阻塞</p>
</blockquote>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Exchanger.html">Exchanger</a></h2><p>“Synchronization point” 说明可以认为这里的exchanger操作是一个可以视为原子操作 交换指定的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FillAndEmpty</span> </span>&#123;</span><br><span class="line">  Exchanger&lt;DataBuffer&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;DataBuffer&gt;();</span><br><span class="line">  DataBuffer initialEmptyBuffer = ... a made-up type</span><br><span class="line">  DataBuffer initialFullBuffer = ...</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FillingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      DataBuffer currentBuffer = initialEmptyBuffer;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (currentBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          addToBuffer(currentBuffer);</span><br><span class="line">          <span class="keyword">if</span> (currentBuffer.isFull())</span><br><span class="line">            currentBuffer = exchanger.exchange(currentBuffer);<span class="comment">//在这里交换</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">EmptyingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      DataBuffer currentBuffer = initialFullBuffer;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (currentBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          takeFromBuffer(currentBuffer);</span><br><span class="line">          <span class="keyword">if</span> (currentBuffer.isEmpty())</span><br><span class="line">            currentBuffer = exchanger.exchange(currentBuffer);<span class="comment">//在这里交换</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> FillingLoop()).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> EmptyingLoop()).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sun.misc.Unsafe U; compareAndSwapObject来实现原子操作</p>
<p>可以用来实现管道之类进程间通信的机制（？）</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/DelayQueue.html">DelayQueue</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; //有四种处理不能立刻满足的操作的方式</span></span><br></pre></td></tr></table></figure>

<p>不限长度的延迟元素的队列，其中元素只有超时之后才能取出。队列头的元素是超时最久的元素</p>
<p>其中容纳的元素需要继承自Delayed类，还要重载compareTo以便进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayObject</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayObject</span><span class="params">(String data, <span class="keyword">long</span> delayInMilliseconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.startTime = System.currentTimeMillis() + delayInMilliseconds;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> diff = startTime - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> unit.convert(diff, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ints.saturatedCast(</span><br><span class="line">          <span class="keyword">this</span>.startTime - ((DelayObject) o).startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.baeldung.com/java-delay-queue">例子：超时的消费者和生产者</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueProducer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;DelayObject&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Integer numberOfElementsToProduce;</span><br><span class="line">    <span class="keyword">private</span> Integer delayOfEachProducedMessageMilliseconds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfElementsToProduce; i++) &#123;</span><br><span class="line">            DelayObject object</span><br><span class="line">              = <span class="keyword">new</span> DelayObject(</span><br><span class="line">                UUID.randomUUID().toString(), delayOfEachProducedMessageMilliseconds);</span><br><span class="line">            System.out.println(<span class="string">&quot;Put object: &quot;</span> + object);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(object);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                ie.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;DelayObject&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Integer numberOfElementsToTake;</span><br><span class="line">    <span class="keyword">public</span> AtomicInteger numberOfConsumedElements = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard constructors</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfElementsToTake; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                DelayObject object = queue.take();</span><br><span class="line">                numberOfConsumedElements.incrementAndGet();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer take: &quot;</span> + object);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> givenDelayQueue_whenProduceElement</span></span><br><span class="line"><span class="function">  <span class="title">_thenShouldConsumeAfterGivenDelay</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// given</span></span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    BlockingQueue&lt;DelayObject&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> numberOfElementsToProduce = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> delayOfEachProducedMessageMilliseconds = <span class="number">500</span>;</span><br><span class="line">    DelayQueueConsumer consumer = <span class="keyword">new</span> DelayQueueConsumer(</span><br><span class="line">      queue, numberOfElementsToProduce);</span><br><span class="line">    DelayQueueProducer producer = <span class="keyword">new</span> DelayQueueProducer(</span><br><span class="line">      queue, numberOfElementsToProduce, delayOfEachProducedMessageMilliseconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// when</span></span><br><span class="line">    executor.submit(producer);</span><br><span class="line">    executor.submit(consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then</span></span><br><span class="line">    executor.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    executor.shutdown();</span><br><span class="line"> </span><br><span class="line">    assertEquals(consumer.numberOfConsumedElements.get(), numberOfElementsToProduce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM Internals Notes</title>
    <url>/post/601be613/</url>
    <content><![CDATA[<p>阅读<a href="https://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a>的笔记</p>
<h2 id="JVM-System-Threads"><a href="#JVM-System-Threads" class="headerlink" title="JVM System Threads"></a>JVM System Threads</h2><p>用户运行的main函数并不是java中最初始的线程，java开始运行的时候就对应着机器中的一个线程，可以称之为Java Thread，当java中其他的线程（non-deamon）的都结束以后，Java Thread才会终止，可以认为是java本身一个代表</p>
<p>在main运行之外，还有一些java system thread来在幕后支撑main函数运行，比如：</p>
<ul>
<li>VM thread 等到JVM到达safe point，例如“stop-the-world”垃圾回收，线程的栈dump，线程暂停和biased locking revocation（有偏向的锁的撤回？）</li>
<li>Periodc task thread 阶段性任务；一些计时事件</li>
<li>GC Thread 垃圾回收</li>
<li>Compiler thread 在运行时将字节码转成原本的代码的线程</li>
<li>Signal dispatcher thread处理发送给JVM线程的信号并调用对应的JVM方法</li>
</ul>
<p>对于每一个thread来说，有一些必要的组件:</p>
<ul>
<li>PC 程序计数器 其中native线程的PC是不确定的</li>
<li>Stack 栈 每一个被调用的方法都有一个对应的frame被放入栈中，遵循LIFO原则 其中栈空间除了push和pop是不被直接管理支配的，并且frame中的一些结构可能被分配到堆上，因此这些object所占用的空间未必连续</li>
<li>Native Stack 为native方法准备的 和C stack一样 因为Java Native Invocation用C语言的连接模型（linkage model）实现</li>
<li>Stack Restrictions 大小可以固定或者灵活，超出范围是栈溢出，没有多余空间可分配是OutOfMemoryError</li>
<li>Frame 对每一次方法调用都会配备的相关信息，在抛出异常或者方法返回的时候被pop出栈<ul>
<li>Local Variable Array 一些基本数据类型，对象只保存引用，返回地址，this指针</li>
<li>OperandStack 作用类似于CPU中的general-purpose reg（通用寄存器）因为对变量操纵频繁 因此local variable array和operand stack数据交换也很频繁（具体看ClassFile里字节码的写法）</li>
</ul>
</li>
<li>Dynamic Linking 与c在编译中确定方法汇编和所在文件位置不同 在java当中方法编译后的链接是在运行时动态完成的 在类被确定并加载，调用静态方法或者动态方法的时候，symbolic reference从一个逻辑上的指针经由lazy resolution被解析，被替换成直接的引用，如果直接引用中涉及到的类没有被解析，那么就会去加载这个类。每个直接引用以相对于运行时变量或者方法存储的相对位置（offset）被储存</li>
</ul>
<h2 id="Shared-Between-Thread"><a href="#Shared-Between-Thread" class="headerlink" title="Shared Between Thread"></a>Shared Between Thread</h2><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>Object和Array数据结构都是存放在堆中的，因为frame并不是为空间大小会变化的数据结构设计的。并且不像简单的数据类型和引用，堆中的对象并不会随着方法返回而被销毁。</p>
<p>在堆中存在垃圾管理机制，被分为三种类型：young generation（常被分为Eden&amp;Survivor），old generation，permanent generation</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li><p>新对象被创建时进入young generation；minor garbage是把young generation中的对象从eden移到survivor，此时对象仍然活跃；</p>
</li>
<li><p>major garbage是把活跃的对象从young generation移动到old generation，通常会使得线程暂停；</p>
</li>
<li><p>permanent generation在old generation回收的时候回收，当其中有一个满的时候两者都会回收</p>
</li>
</ul>
<h3 id="Non-Heap-Memory"><a href="#Non-Heap-Memory" class="headerlink" title="Non-Heap Memory"></a>Non-Heap Memory</h3><p>一些不在Heap中的结构</p>
<ul>
<li>permanent generation 含有方法域和interned string的</li>
<li>code cache 已经被JIT compiler编译的部分方法的代码</li>
</ul>
<h3 id="Just-In-Time-Compilation"><a href="#Just-In-Time-Compilation" class="headerlink" title="Just In Time Compilation"></a>Just In Time Compilation</h3>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java下运行mysql</title>
    <url>/post/15229090/</url>
    <content><![CDATA[<h2 id="环境配置问题"><a href="#环境配置问题" class="headerlink" title="环境配置问题"></a>环境配置问题</h2><p>如果出现 <code>java.lang.ClassNotFoundException: com.mysql.jdbc.Driver</code> 的问题（在mysql 8.0及以上的版本 应该是<code>com.mysql.cj.jdbc.Driver</code>）有可能是没有安装connection j的依赖，最好先借助mysql installer检查mysql的安装包。</p>
<p>查到的解决方案大多针对有maven等管理工具的大型软件，对vscode下临时建立的小项目不直接适用。</p>
<p>安装后有一个jar包，移动到classpath以后依旧报错，在YouTube上找到一位<a href="https://www.youtube.com/watch?v=MtME-ERufu0&ab_channel=BoostMyTool">印度小哥制作的新手教程</a> 把jar包移动到java project中即可。</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211209203900546.png" alt="image-20211209203900546"></p>
<h2 id="依赖和包的使用"><a href="#依赖和包的使用" class="headerlink" title="依赖和包的使用"></a>依赖和包的使用</h2><p>需要java.sql.*</p>
<p>可以<a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-usagenotes-statements.html">参考Mysql官方文档</a> 和 <a href="https://www.runoob.com/java/java-mysql-connect.html">菜鸟教程</a></p>
<p>Statement: 用于像数据库发送指令 其中execute可以用于执行无返回结果和有返回结果的sql语句，但是executeQuery只能用于有返回结果的（如select）</p>
<p>ResultSet：用于接收结果，<a href="https://blog.csdn.net/SHU15121856/article/details/79305295">游标</a>可以通过该对象使用</p>
<h4 id="额外收获"><a href="#额外收获" class="headerlink" title="额外收获"></a>额外收获</h4><ul>
<li>”==“ 改成 equals就可以正常判断 why？<ul>
<li>“==” 基本类型比较的是值，引用类型比较的是引用 string后者，equals比较的是引用类型的值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>NJUCS 各研究组宣讲</title>
    <url>/post/89396cda/</url>
    <content><![CDATA[<h2 id="BigAI"><a href="#BigAI" class="headerlink" title="BigAI"></a>BigAI</h2><p>邮件: <a href="mailto:&#108;&#x69;&#x77;&#x75;&#x6a;&#x75;&#110;&#64;&#x6e;&#106;&#117;&#x2e;&#x65;&#100;&#x75;&#46;&#x63;&#110;">&#108;&#x69;&#x77;&#x75;&#x6a;&#x75;&#110;&#64;&#x6e;&#106;&#117;&#x2e;&#x65;&#100;&#x75;&#46;&#x63;&#110;</a></p>
<p>主页: <a href="https://cs.nju.edu.cn/lwj">https://cs.nju.edu.cn/lwj</a></p>
<p>大数据机器学习 机器学习算法：存储、计算、通信</p>
<ul>
<li>哈希学习<ul>
<li>哈希函数很关键 哈希值应当保留样本是否相似的特征</li>
<li>实际应用: 行人重识别，自动问答，视频查重</li>
</ul>
</li>
<li>并行与分布式随机学习<ul>
<li>单机器：并行；多机器：分布式</li>
<li>交互协同的开销有时比计算开销更大，是加速的代价</li>
<li>分布式机器学习：数据不出本地（保护隐私等原因），实现可信机器学习</li>
</ul>
</li>
<li>大数据机器学习平台LIBBLE<ul>
<li>机器学习的底层数据平台</li>
</ul>
</li>
</ul>
<p>应用：</p>
<p>智慧医疗</p>
<h2 id="ICS-基础研究和系统工程中心"><a href="#ICS-基础研究和系统工程中心" class="headerlink" title="ICS - 基础研究和系统工程中心"></a>ICS - 基础研究和系统工程中心</h2><p><a href="http://cs.nju.edu.cn/ics">http://cs.nju.edu.cn/ics</a></p>
<p>判断程序的正误？如何根据行为习惯进行推断？高效的多心（并发）问题？</p>
<p>（可见许畅老师的主页）</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/ics-zhihulink.png"></p>
<p><img src="/post/89396cda/191220083\Young&Wild&Free\hexo\source_posts\NJUCS-各研究组宣讲.assets\image-20220418164044249-16502763430033.png" alt="image-20220418164044249"></p>
<p><img src="/post/89396cda/191220083\Young&Wild&Free\hexo\source_posts\NJUCS-各研究组宣讲.assets\image-20220418164145804.png" alt="image-20220418164145804"></p>
<p>（见软件所主页）</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418164409172.png" alt="image-20220418164409172"></p>
<ul>
<li>软件工程+机器学习<ul>
<li>软件智能化: 机器编写代码，自动测试等</li>
<li>逻辑的演绎性+学习的归纳性的冲突 SE+AI</li>
</ul>
</li>
</ul>
<p><a href="http://cs.nju.edu.cn/ics">http://cs.nju.edu.cn/ics</a></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418165928416.png" alt="image-20220418165928416"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418170429405.png" alt="image-20220418170429405"></p>
<h2 id="SEG"><a href="#SEG" class="headerlink" title="SEG"></a>SEG</h2><p><a href="http://seg.nju.edu.cn/">http://seg.nju.edu.cn</a></p>
<p>设计开发方法/程序分析/编译优化</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418171124595.png" alt="image-20220418171124595"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418171902259.png" alt="image-20220418171902259"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418172312609.png" alt="image-20220418172312609"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418172344072.png" alt="image-20220418172344072"></p>
<p>学术or工程</p>
<p>4月25日</p>
<h2 id="COSEC"><a href="#COSEC" class="headerlink" title="COSEC"></a>COSEC</h2><p>仲盛、华景煜、张渊</p>
<p>研究方向</p>
<p>密码学/网络空间安全/博弈论</p>
<p>隐私、网络安全在分布式、网络的引用</p>
<p>推荐服务的隐私保护，app隐私合规</p>
<p>多方合作计算的隐私保护、激励兼容</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220425162750489.png" alt="image-20220425162750489"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220425164042872.png" alt="image-20220425164042872"></p>
<h2 id="应用为导向的网络系统研究"><a href="#应用为导向的网络系统研究" class="headerlink" title="应用为导向的网络系统研究"></a>应用为导向的网络系统研究</h2><p>先进网络系统大组</p>
<p>分布式网络与系统 计算网络+存储系统</p>
<p>企业合作</p>
<p>大四开始加入研究</p>
<h3 id="topic："><a href="#topic：" class="headerlink" title="topic："></a>topic：</h3><p>云存储系统与网络，软件定义的测量技术与系统，超低时延网络，图计算 偏算法，流式计算，可编程网络，统一通信库，机器学习系统和网络，音视频传输</p>
<h2 id="智能软件生态研究小组"><a href="#智能软件生态研究小组" class="headerlink" title="智能软件生态研究小组"></a>智能软件生态研究小组</h2><p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220425165747795.png" alt="image-20220425165747795"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220425170214676.png" alt="image-20220425170214676"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220425171515818.png" alt="image-20220425171515818"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220425171846425.png" alt="image-20220425171846425"></p>
<h2 id="计算机理论之美——尹一通老师-理论实验室"><a href="#计算机理论之美——尹一通老师-理论实验室" class="headerlink" title="计算机理论之美——尹一通老师 理论实验室"></a>计算机理论之美——尹一通老师 理论实验室</h2><p>tcs.nju.edu.cn</p>
<p>cs之于computer有如望远镜之于天文学</p>
<p>图灵机 通用的数学模型：对各种计算机的基本抽象</p>
<p>元胞自动机 game of life</p>
<p>计算机科学的创立时间早于第一台通用计算机的诞生</p>
<p>公理化的历程：</p>
<p>几何原本——罗素悖论</p>
<p>建立在喜欢钻研某个领域的基础再考虑未来学术道路如是否出国</p>
<ul>
<li>林冰凯<ul>
<li>参数复杂性与算法<ul>
<li>按照参数精细刻画计算开销</li>
</ul>
</li>
</ul>
</li>
<li>刘景铖<ul>
<li>计算相变 why easy 和物理结合</li>
</ul>
</li>
<li>尹一通<ul>
<li>采样算法 并行与分布式计算理论</li>
</ul>
</li>
<li>郑朝栋 <ul>
<li>分布式算法 现代分布式计算模式中的原语问题（一些经典问题）</li>
<li>网络算法</li>
</ul>
</li>
</ul>
<h2 id="Meta-Graphics-amp-3D"><a href="#Meta-Graphics-amp-3D" class="headerlink" title="Meta Graphics &amp; 3D"></a>Meta Graphics &amp; 3D</h2><p>CV+ML</p>
<h2 id="分布式计算实验室"><a href="#分布式计算实验室" class="headerlink" title="分布式计算实验室"></a>分布式计算实验室</h2><p>dislab.nju.edu.cn</p>
<p>谢磊</p>
<ul>
<li><p>智能感知</p>
</li>
<li><p>云/边缘计算</p>
</li>
<li><p>数据挖掘</p>
</li>
<li><p>数据中心</p>
</li>
</ul>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220516174136009.png" alt="image-20220516174136009"></p>
<h2 id="边缘智能——钱柱中-张胜老师"><a href="#边缘智能——钱柱中-张胜老师" class="headerlink" title="边缘智能——钱柱中/张胜老师"></a>边缘智能——钱柱中/张胜老师</h2><p>数据产生在客户端/远端 如何计算？如果全部放在远端对用户不友好（eg：手机设备掉电快）</p>
<p>近数据源</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220526161853790.png" alt="image-20220526161853790"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220526162438968.png" alt="image-20220526162438968"></p>
]]></content>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
  <entry>
    <title>NPC问题：服务商+bitset用法</title>
    <url>/post/4a3554ff/</url>
    <content><![CDATA[<p>原题：</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/Cache_3de56e540c5c45f2..jpg" alt="Cache_3de56e540c5c45f2."></p>
<p>参考的是<a href="https://blog.csdn.net/RayoNicks/article/details/102875252?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%B8%80%E5%AE%B6%E5%85%AC%E5%8F%B8%E5%9C%A8%20N%20%E4%B8%AA%E5%B0%8F%E9%95%87%E9%94%80%E5%94%AE%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%EF%BC%883%E2%89%A4N%E2%89%A435%EF%BC%89%EF%BC%8C%E6%9C%89%20M%20&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-102875252.pc_search_result_control_group&spm=1018.2226.3001.4187">Program Challenge的CSDN解析</a></p>
<p>数据结构上的绝妙是利用<a href="https://en.cppreference.com/w/cpp/utility/bitset">bitset</a>来压缩信息的存储.可以认为把二位vector中的行变为bitset，即每个单位由int变为bit，则每一行对应一个点的连通信息，每个比特对应点对点是否连通。之后的DFS中，通过位运算可以简洁的合并信息并进行判断。</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(i); <span class="comment">//把bitset的第i位比特设置成1</span></span><br><span class="line"><span class="built_in">test</span>(i);<span class="comment">//检查bitset的第i位是1则返回true</span></span><br><span class="line"><span class="built_in">count</span>();<span class="comment">//数bitset中有多少位是1</span></span><br><span class="line">对bitset可以做位运算</span><br></pre></td></tr></table></figure>

<p>这是一个NPC问题，多项式时间内没有解法，但是可以多项式时间验证解是否正确。作为一个图论问题，自然想到用DFS或者BFS来做。为了求出最小的站点数，从小到大遍历答案并检查。</p>
<p>这里为了简化求解，把图拆封成连通分量分别求解，每个连通分量上的最小解的和就是整个图的最小解。在压入每一个点的信息（即每一行bitset）的时候，可以认为对子图进行了重新编号。</p>
<p>还有一处简化是是通过覆盖率来剪枝。由于遍历是按照序号从小到大来遍历的，back的意思是，从当前点往更大的点遍历，能有多少个点被服务站覆盖。因此填写信息的时候是从序号大的点往序号小的点遍历，因为较大序号的点不会再去遍历小序号的点。这里主要是为了剪枝以下情况。（左侧是结果树）</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/A45CFDC5EF4DCAB9BA01E313BD59C701.png" alt="A45CFDC5EF4DCAB9BA01E313BD59C701"></p>
<p>可以看到在对1的处理中，对5做DFS是没有意义的，因此剪枝。</p>
<p>由于本身建站和相邻建站都算覆盖，这里的连通实际上也代表了覆盖的情况。因此可以通过或运算来计算覆盖的情况。</p>
<p>以下是对原作者代码的注释</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//划分出连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divideGraph</span><span class="params">(<span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt; &amp;graph,vector&lt;vector&lt;bitset&lt;MAX_N&gt;&gt;&gt; &amp;vecChildGraph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    graph 原本的图，graph[i]代表序号为i的点所处的连通分量的记录图</span></span><br><span class="line"><span class="comment">    vecChildGraph 用于存储子图的vector</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">size_t</span> N =graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">size_t</span>&gt; <span class="title">vecVisited</span><span class="params">(N,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">//用于记录每一个点是否已经被遍历并归入一个连通子图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vecVisited[i])<span class="comment">//点还没遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;bitset&lt;MAX_N&gt;&gt; ChildGraph;</span><br><span class="line">            deque&lt;<span class="keyword">size_t</span>&gt; que;<span class="comment">//BFS找连通分量</span></span><br><span class="line">            que.<span class="built_in">push_back</span>(i);</span><br><span class="line">            vecVisited[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">size_t</span> front;</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">                ChildGraph.<span class="built_in">push_back</span>(graph[front]);<span class="comment">//构建连通图信息中的行</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">size_t</span> pos=<span class="number">0</span>;pos&lt;N;pos++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(graph[front].<span class="built_in">test</span>(pos) &amp;&amp; !vecVisited[pos])</span><br><span class="line">                    &#123;</span><br><span class="line">                        que.<span class="built_in">push_back</span>(pos);</span><br><span class="line">                        vecVisited[pos]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vecChildGraph.<span class="built_in">push_back</span>(ChildGraph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calBackCover</span><span class="params">(vector&lt;vector&lt;bitset&lt;MAX_N&gt;&gt;&gt; &amp;vecChildGraph,vector&lt;vector&lt;bitset&lt;MAX_N&gt;&gt;&gt; &amp;vecBackCover)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//vecChildGraph是连通子图的集合，vecBackCover是记录覆盖率信息的二维bitset，每一行代表遍历到该行序列对应的点的覆盖率信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> idx=<span class="number">0</span>;idx&lt;vecChildGraph.<span class="built_in">size</span>();idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt; &amp;childGraph = vecChildGraph[idx];</span><br><span class="line">        <span class="keyword">size_t</span> node = childGraph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//取出一个子图 记录下子图中节点的数量</span></span><br><span class="line">        vecBackCover.<span class="built_in">push_back</span>(vector&lt;bitset&lt;MAX_N&gt;&gt;(node,bitset&lt;MAX_N&gt;()));</span><br><span class="line">        <span class="comment">//生成一个二维bitset对应该子图，并放入答案vector中</span></span><br><span class="line">        bitset&lt;MAX_N&gt; BackCover;</span><br><span class="line">        <span class="comment">//中间变量 代表一个点的覆盖率信息</span></span><br><span class="line">        <span class="keyword">for</span>(;node&gt;<span class="number">0</span>;--node)</span><br><span class="line">        &#123;</span><br><span class="line">            vecBackCover[idx][node<span class="number">-1</span>]=childGraph[node<span class="number">-1</span>]|BackCover;</span><br><span class="line">            <span class="comment">//直接对bitset进行或运算来得到连通信息 bitset默认初始值应该是全0</span></span><br><span class="line">            BackCover=vecBackCover[idx][node<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//记录下来 下一轮继续用 因为是层层向序号小的节点传递的连通的信息 小节点的信息依赖于序号更大的覆盖率的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt; &amp;graph,<span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt; &amp;back,bitset&lt;MAX_N&gt; &amp;cover,<span class="keyword">size_t</span> curr,<span class="keyword">size_t</span> cnt,<span class="keyword">const</span> <span class="keyword">size_t</span> bound,<span class="keyword">size_t</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    graph 处理后的连通子图 确保只有一个连通分量</span></span><br><span class="line"><span class="comment">    back 该子图上每个点的覆盖率信息</span></span><br><span class="line"><span class="comment">    cover 遍历到当前点的已有的覆盖子图的情况</span></span><br><span class="line"><span class="comment">    curr 当前遍历的点的序号</span></span><br><span class="line"><span class="comment">    cnt 当前已经建立的服务站的数量</span></span><br><span class="line"><span class="comment">    bound 最多能建的服务站的数量</span></span><br><span class="line"><span class="comment">    num 最终返回的答案</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(cnt==bound)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cover.<span class="built_in">count</span>()==graph.<span class="built_in">size</span>())</span><br><span class="line">            num=cnt;</span><br><span class="line">       	<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//验证当前的bound是否能够使得点都被覆盖 如果是，确定答案并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    bitset&lt;MAX_N&gt; newCover;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=curr;i&lt;graph.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        newCover = cover;</span><br><span class="line">        newCover |=back[curr];</span><br><span class="line">        <span class="keyword">if</span>(newCover.<span class="built_in">count</span>()!=graph.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//做覆盖率的剪枝 现有的覆盖情况与curr覆盖如果合起来不是全图 那么一直不会对之后的点做DFS</span></span><br><span class="line">        newCover = cover;</span><br><span class="line">        newCover |= graph[i];<span class="comment">//更新情况</span></span><br><span class="line">        <span class="keyword">if</span>(newCover == cover)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//覆盖率没有变化 不需要遍历选中的i点 剪枝</span></span><br><span class="line">        <span class="built_in">DFS</span>(graph,back,newCover,i+<span class="number">1</span>,cnt+<span class="number">1</span>,bound,num);</span><br><span class="line">        <span class="comment">//对i建站并更新 记录新的覆盖情况，从下一个点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(num!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       	<span class="comment">//已经有答案 不用再继续</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> N=<span class="number">0</span>,M=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;N&gt;&gt;M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span> &amp;&amp; M==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        vector&lt;bitset&lt;MAX_N&gt;&gt; <span class="built_in">graph</span>(N,bitset&lt;MAX_N&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> v=<span class="number">0</span>;v&lt;N;++v)</span><br><span class="line">        &#123;</span><br><span class="line">            graph[v].<span class="built_in">set</span>(v);</span><br><span class="line">            <span class="comment">//自己与自己算连通</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> v1,v2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> m=<span class="number">0</span>;m&lt;M;++m)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;v1&gt;&gt;v2;</span><br><span class="line">            graph[v1<span class="number">-1</span>].<span class="built_in">set</span>(v2<span class="number">-1</span>);</span><br><span class="line">            graph[v2<span class="number">-1</span>].<span class="built_in">set</span>(v1<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//记录路径信息 注意下标已经双向</span></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;bitset&lt;MAX_N&gt;&gt;&gt; vecChildGraph;</span><br><span class="line">        vector&lt;vector&lt;bitset&lt;MAX_N&gt;&gt;&gt; vecBackCover;</span><br><span class="line">        <span class="built_in">divideGraph</span>(graph,vecChildGraph);<span class="comment">//划分连通子图</span></span><br><span class="line">        <span class="built_in">calBackCover</span>(vecChildGraph,vecBackCover);<span class="comment">//求每个子图中每个点的覆盖率</span></span><br><span class="line">        <span class="keyword">size_t</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> idx=<span class="number">0</span>;idx&lt;vecChildGraph.<span class="built_in">size</span>();++idx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt; &amp;childGraph = vecChildGraph[idx];</span><br><span class="line">            <span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt;&amp; back=vecBackCover[idx];</span><br><span class="line">            bitset&lt;MAX_N&gt; cover;</span><br><span class="line">            <span class="keyword">size_t</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> bound=<span class="number">1</span>;bound&lt;=childGraph.<span class="built_in">size</span>();++bound)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">DFS</span>(childGraph,back,cover,<span class="number">0</span>,<span class="number">0</span>,bound,num);<span class="comment">//对每个bound做验证 NPC问题</span></span><br><span class="line">                <span class="keyword">if</span>(num!=<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//有解</span></span><br><span class="line">            &#125;</span><br><span class="line">            total+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Algo</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful microPos-AW05</title>
    <url>/post/c689f23c/</url>
    <content><![CDATA[<p><a href="https://github.com/sawork-2022/aw05-August0830">作业项目地址</a></p>
<p>Question：</p>
<ul>
<li>断路器：在gateway实现，在<a href="https://github.com/sa-spring/spring-circuitbreaker/blob/master/src/main/java/com/example/circuitbreaker/AlbumService.java">读取product列表</a>的时候实现</li>
</ul>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p><a href="https://spring.io/guides/tutorials/rest/">官方文档</a></p>
<p><a href="https://www.bilibili.com/video/BV1GE411G7hu?p=4">课程对应样例讲解：spring-projects/spring-hateoas-examples</a></p>
<p>REST目标之一是解决接口不规范的问题；ResponseEntity RESTful架构下返回的标准的数据接口，可以被网页解析，并且传入http状态代码。</p>
<p>annotation类型与get/post等http方法对应</p>
<p>配合open-api：规定程序接口 </p>
<h3 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a><a href="https://en.wikipedia.org/wiki/Data_transfer_object">DTO</a></h3><p><a href="https://martinfowler.com/eaaCatalog/dataTransferObject.html">martinFowler的解读</a></p>
<p><a href="https://www.baeldung.com/entity-to-and-from-dto-for-a-java-spring-application">Entity To DTO Conversion for a Spring REST API</a></p>
<p><a href="https://www.baeldung.com/java-dto-pattern">The DTO Pattern (Data Transfer Object)</a></p>
<p>不同类型的数据进行综合——为了减少传输时间，把多次请求（不同类型）的数据合并在一起传输，mapper主要用来处理此类转换。</p>
<p>map struct：把服务内的数据结构映射成服务间通讯需要的数据结构。数据可能被重构，不一定与服务内的数据结构保持一致。</p>
<p>spring-petclinic-microservice 虽然有dto文件夹 但是并没有用到map 主要是抽离gateway和biz层的数据交换</p>
<h2 id="pos-api-——-服务间通用api"><a href="#pos-api-——-服务间通用api" class="headerlink" title="pos-api  —— 服务间通用api"></a>pos-api  —— 服务间通用api</h2><p>open-api <a href="https://github.com/OpenAPITools/openapi-generator/tree/master/modules/openapi-generator-maven-plugin">官方说明+参数说明</a></p>
<p> <a href="https://www.baeldung.com/java-openapi-generator-server">baeldung</a></p>
<p>前端页面—— 先返回json格式的数据 可以裸奔</p>
<p>把所需的所有api统一建立一个文件夹，注意不是单独服务所以不要用spring-plugin打包，把它作为依赖在其他服务中引用，或者在sprng-plugin配置中选择忽略main函数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span><span class="comment">&lt;!--不需要main类打包--&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>把pos-api安装到本地，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=../pos-api/target/pos-api-0.0.1-SNAPSHOT.jar -DgroupId=com.micropos -DartifactId=micropos -Dversion=0.0.1</span><br></pre></td></tr></table></figure>

<p>其他模块就可以直接在依赖中引用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.micropos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pos-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>把products原本有的open-api移除，改用统一的pos-api</p>
<p>修改顶层项目中的pom文件，否则会自动给下层指定默认位置，即上层pom的设置优先于下层的pom设置。</p>
<p>对于曾经有过open-api的products：去掉open-api的plugin换成spring。</p>
<p>原本products中关于open-api的import也要重写，包名与依赖中写的保持一致。</p>
<h2 id="product"><a href="#product" class="headerlink" title="product"></a>product</h2><p>先尝试启动product作为一个独立服务，openapi使用的时候遇到如下报错：</p>
<p><code>required a bean of type that could not be found.</code></p>
<p><a href="https://stackoverflow.com/questions/42907553/field-required-a-bean-of-type-that-could-not-be-found-error-spring-restful-ap">搜索后</a>，在ProductsApplication文件中修改注释为：<code>@SpringBootApplication(scanBasePackages = &#123;&quot;com.micropos.products.*&quot;&#125; )</code></p>
<p>访问时记得加前缀api，如下：<code>http://localhost:8082/api/products</code></p>
<p>类似上一次作业，应该在此处添加cache</p>
<h3 id="ehcache"><a href="#ehcache" class="headerlink" title="ehcache"></a>ehcache</h3><p> <a href="https://www.baeldung.com/spring-boot-ehcache">在服务中使用的例子</a> <a href="https://its401.com/article/weixin_30617737/96032178">性能讲解和测试方式</a></p>
<p>类似之前 在JDRepostry添加  配置了但是不知道是否成功，由于mapper对product进行了转换，所以在指明key/value类型的时候，value类型应当是productDTO，否则mapper会报空指针错：<code>ProductMapper.java:[10,8] Internal error in the mapping processor: java.lang.NullPointerException      at jdk.compiler/com.sun.tools.javac.comp.Modules.enterModule(Modules.java:310) </code></p>
<p>不能像redis一样直接检查数据，需要java程序来管理。先完成其他部分，过程中遇到问题再说。</p>
<p><a href="https://its401.com/article/weixin_30617737/96032178">程序样例1</a></p>
<p><a href="https://blog.csdn.net/kzcming/article/details/108849444">缓存查看</a></p>
<p><a href="https://blog.csdn.net/elim168/article/details/71600366">查询缓存</a></p>
<h2 id="carts"><a href="#carts" class="headerlink" title="carts"></a>carts</h2><p>并不是针对单个用户的购物车状态跳转，而是指同时管理多用户的购物车资源</p>
<p>javax.persistence.* 简单的进行持久化</p>
<p><a href="https://docs.oracle.com/javaee/6/tutorial/doc/bnbqa.html#bnbqb">文档</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.persistence<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.persistence-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&lt;/dependency</span><br></pre></td></tr></table></figure>

<p>@Entity 加了该注释的类在关系型数据库中建表</p>
<p><a href="https://docs.oracle.com/javaee/7/api/javax/persistence/GeneratedValue.html">@GeneratedValue</a> 生成关系数据库中的primarykey</p>
<p><a href="https://projectlombok.org/features/experimental/Accessors">@Accessors</a></p>
<p>fluent限定只是简单的getter和setter，默认是false，设置为true时，另一个属性chain默认是true，chain为true时决定了返回类型是this而非void</p>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/persistence/OneToMany.html">@OneToMany</a></p>
<p>有嵌套引用的类并且是一组实体的时候,使用该注释</p>
<p><a href="https://docs.oracle.com/javaee/7/api/javax/persistence/JoinTable.html">@JoinTable</a> </p>
<p>配合OneToMany使用，在有多对多，一对多的情况下指明</p>
<p>用spring-boot提供的<a href="https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html">CrudRepository</a> 这是一个提供了数据管理功能的包，<a href="https://zetcode.com/springboot/crudrepository/">样例程序</a></p>
<p>implements了cartsApi之后可以直接override方法——where is super？？</p>
<p>再次出现：<code>[spring boot classnotfound org.springframework.boot.Bootstrapper while staring application](https://stackoverflow.com/questions/65917014/spring-boot-classnotfound-org-springframework-boot-bootstrapper-while-staring-ap)</code></p>
<p>需要指明spring-cloud的版本，与discovery中保持一致；并且dependencyManagement保留有参数的形式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>2021.0.1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>记得在springboot application的Java文件中用注解扩大bean的扫描范围并且声明向eureka注册</p>
<p>运行时遇到如下问题</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220427095447461.png" alt="image-20220427095447461"></p>
<p>重新编译pos-api （没有找到根本的解决办法，偶尔出现）</p>
<p>注册时出现unknown并且端口是默认端口，说明配置文件读取不成功，发现resources放在了和main同级，应该和java文件夹同级</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Parameter 0 of method setCartMapper <span class="keyword">in</span> com.micropos.carts.rest.CartsController required a bean of <span class="built_in">type</span> <span class="string">&#x27;com.micropos.carts.mapper.CartMapper&#x27;</span> that could not be found.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Consider defining a bean of <span class="built_in">type</span> <span class="string">&#x27;com.micropos.carts.mapper.CartMapper&#x27;</span> <span class="keyword">in</span> your configuration</span><br></pre></td></tr></table></figure>

<p>遇到cartController有bean无法初始化的问题，是没有定义默认公共构造函数的<a href="https://stackoverflow.com/questions/52841620/parameter-0-of-constructor-in-required-a-bean-of-type-java-lang-string-that-co">原因</a> 建议直接在公共构造函数中传入参数cartMapper和cartService</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing: com.micropos.carts.model.CartItem</span><br></pre></td></tr></table></figure>

<p>OneToMany注解中添加属性 cascade = casecadeType.ALL</p>
<h2 id="micro-微服务架构"><a href="#micro-微服务架构" class="headerlink" title="micro 微服务架构"></a>micro 微服务架构</h2><p>参考的代码 <a href="https://github.com/spring-petclinic/spring-petclinic-microservices">spring-petclinic-microservices</a>和<a href="https://github.com/spring-petclinic/spring-petclinic-microservices-config">配置文件参考</a>；以及<a href="https://github.com/paulc4/microservices-demo">microservice-demo</a></p>
<h3 id="discovery-eureka"><a href="#discovery-eureka" class="headerlink" title="discovery/eureka"></a>discovery/eureka</h3><h3 id="eureka-server"><a href="#eureka-server" class="headerlink" title="eureka server"></a>eureka server</h3><p>没有采用远程fetch的形式，直接做了本地配置。</p>
<p>对于eureka的配置，可以参考spring关于eureka的<a href="https://spring.io/guides/gs/service-registration-and-discovery/">官方文档</a>。其中提供了在start.io建立eureka项目的方式。可以直接使用，对于已经有配置文件的本项目来说，复制粘贴pom中的内容即可（关键是要包含netflix-eureka的依赖）。启动时记得添加@EnableEurekaServer的标注。</p>
<p>yml文件是对于discovery的配置，作为一个独立的服务配置。如果不是默认application.yml的命名方式，需要在mian函数中额外指明。**并且不需要加后缀yml!**（遇到问题记得检查文件是否生效）</p>
<p>如果yml没有配置成功，默认情况下eureka会把自身注册，就会出现如下报错：</p>
<p><code>com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server</code></p>
<p>即一个逻辑死循环，因此需要仿照样例将 <code>registerWithEureka</code>,<code>fetchRegistry</code>设置为false。</p>
<h3 id="other-server"><a href="#other-server" class="headerlink" title="other server"></a>other server</h3><p><a href="https://cloud.spring.io/spring-cloud-netflix/multi/multi__service_discovery_eureka_clients.html">简单教程</a></p>
<p>记得在yml文件中添加eureka，服务的application类中启用@EnableDiscoveryClient，并且在pom中添加如下依赖（注意starter不同！）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>调试中： rest/mvc架构和gateway不共存</p>
<p>如果上层文件夹中pom文件已经有依赖资源，在子层中再次添加依赖需要指明版本。</p>
<p>如果log中出现 <code>Registering application GATEWAY with eureka with status UP</code>，再检查eureka，一般是成功注册了。</p>
<p><strong>配置服务的一般步骤: 依赖+注解+运行检查</strong></p>
<p>如果已有文件中出现冲突，如出现以下报错即是spring-boot-starter-web和spring-cloud-starter-netflix-eureka-client版本冲突，</p>
<p><code>[spring boot classnotfound org.springframework.boot.Bootstrapper while staring application](https://stackoverflow.com/questions/65917014/spring-boot-classnotfound-org-springframework-boot-bootstrapper-while-staring-ap)</code></p>
<p>可以在<a href="https://start.spring.io/">自动生成项目文件的spring官方网站</a>同时选中所需的依赖，然后进行替换。此处是添加了dependencyManagement解决的。</p>
<p>如果需要随机分配，则不在应用中指定server port（待确定？）</p>
<h2 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h2><p>最后做 其他的可以先做独立应用？——应用本身应该是能够在端口被访问的</p>
<p>配置文件中 关于spring的部分，配置了thymeleaf相关，即网页显示</p>
<p>添加断路器 在转发需求的时候</p>
<p>两部分，一部分保证在eureka登记，另一部分实现转发</p>
<p><a href="https://www.javainuse.com/spring/cloud-gateway">转发-简单样例</a> <a href="https://spring.io/guides/gs/gateway/">转发-官方手册</a></p>
<p><a href="https://stackoverflow.com/questions/60705382/mono-class-in-java-what-is-and-when-to-use">Mono&lt;T&gt;</a> 处理流式数据</p>
<p>可以直接在yml中配置，即可完成转发。但是如果要配置断路器，则必须用代码。</p>
<h2 id="plantuml——AWSuml"><a href="#plantuml——AWSuml" class="headerlink" title="plantuml——AWSuml"></a>plantuml——AWSuml</h2><p>画图资源</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
  <entry>
    <title>RM 高考 目的与手段 和我</title>
    <url>/post/72f41795/</url>
    <content><![CDATA[<p>rm生日的时候看到一条生贺视频 缪斯、月亮与鲸鱼 里面南俊说 在工作压力下 通过看展 散步 骑车 亲近自然 来放松自己 虽然说不能指望这些体验对音乐工作有直接的作用 但是至少这是他对抗压力的方式</p>
<p>突然鼻子就一酸 南俊的生活当中镶嵌了许许多多他喜欢的治愈的事情 而我却有很长一段时间都在把想做的事情推到“等到xx的时候” 如果压力一直长存没有尽头 如果人生不是为了一个目的就可以放弃一切 那在松动下来的时间里忙里偷闲又有何妨？跑弹不必留到周末再看 吃饭间隙就可以享受 想读的时候就找来放在手边 网络一关就可以开始看 毕竟 某种程度上 这也是让我不必崩溃的办法</p>
<p>到底是为什么没有办法享受闲暇 只能在碎片化中找到安心的时刻 只能在压力下承认自己也需要休息 为什么总要在极端反复跳跃？我想这个问题 得要回到高三的时候 毕竟那个时候只有一个目标 哪怕心底里在反抗 但只能在指挥棒下不断的自我拉扯 看综艺没办法看完 看书也不能认真享受 一切都推到高考以后 推着推着 高考过去了整整两年 我还困在这里</p>
<p>想起来看到的一篇衡水学生的文章 不得不承认尽管自己的高中已经宽松太多 但是总有一些相似的ptsd是高考体制下人们共通的 里面作者写到无法忍受等待和闲暇 做什么都要有目的和效率 实在是让人狠狠共情 为了一个目标能够放弃一切的想法 以及随之造就的习惯 其实作为一种惯性留在很多人的后高考时代 看转发评论里的人们可见一斑 可是有很多事情 也同样重要 或者换句话说 一些斗争不会到此为止 难道要一直这样等到克服一切困难才能放过自己吗 那可能要把一些原本属于自己的时光带进坟墓了</p>
<p>看着南俊 突然意识到自己也有和压力共存的方式 心安理得的在午饭的时候享受跑弹 心安理得的在认真做了几个小时的任务之后放松自己 反倒减少了很多犹如溺水之人抓不到救命稻草的时刻 想要从网络上找一些转移注意力的刺激的时刻减少了不少 搭配digital balance 这两天连睡眠作息都规律了很多</p>
<p>承认自己的压力 承认自己的欲望 让自己慢慢学会享受闲暇 享受专注 避免碎片化的emo 这是我最近学到的love myself的方式 感谢南俊 还有那个剪出让人落泪的生贺视频的4粉</p>
]]></content>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>Software-Architecture docker踩坑小结+AW04记录</title>
    <url>/post/961e2082/</url>
    <content><![CDATA[<h2 id="gcr-io-镜像因为网络原因拉取失败"><a href="#gcr-io-镜像因为网络原因拉取失败" class="headerlink" title="gcr.io 镜像因为网络原因拉取失败"></a>gcr.io 镜像因为网络原因拉取失败</h2><p>尝试换源失败，总是提示验证失败，于是打算直接用代理从原网站下载</p>
<h3 id="虚拟机使用宿主机的梯子环境"><a href="#虚拟机使用宿主机的梯子环境" class="headerlink" title="虚拟机使用宿主机的梯子环境"></a>虚拟机使用宿主机的梯子环境</h3><p>vitualbox上没有装梯子，尝试使用宿主机的梯子环境。vitualbox上的网络连接方式是 <strong>网络地址转换（NAT）</strong></p>
<p>在终端用 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route show</span><br></pre></td></tr></table></figure>

<p>查看虚拟机所占用的ip地址，选择default的记录下来。</p>
<p>在虚拟机设置中找到Network-NeworkProxy 选择manual</p>
<p>所有proxy的ip都填写刚刚记录的ip，端口就查看电脑本机梯子上的端口填入（我的梯子软件界面自带了该信息，如果没有可以通过查看梯子软件进程占用的端口来确定）</p>
<p>在浏览器中访问google/youtube，成功即可</p>
<h3 id="mvn中的jib-dockerBuild使用代理"><a href="#mvn中的jib-dockerBuild使用代理" class="headerlink" title="mvn中的jib dockerBuild使用代理"></a>mvn中的jib dockerBuild使用代理</h3><p>首先参照<a href="https://note.qidong.name/2020/05/docker-proxy/">此篇文章</a>给dockerd设置的全局的代理。</p>
<p>随后，参考github上的<a href="https://github.com/GoogleContainerTools/jib/issues/1403">此issue</a>和另一篇<a href="https://www.jianshu.com/p/4701d9738bfa">文章</a>，执行mvn命令时需要添加参数，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn compile -Dhttps.proxyHost=10.0.2.2 -Dhttps.proxyPort=33210 compile jib:dockerBuild</span><br></pre></td></tr></table></figure>

<p>其中<code>10.0.2.2</code>和<code>33210</code>换成和虚拟机网络代理设置中的ip地址和端口，注意ip地址前不需要加协议名（在这里被坑了，因为不是很了解代理参数的含义）</p>
<p>就可以成功得到所需要的镜像了！</p>
<h2 id="gatling使用"><a href="#gatling使用" class="headerlink" title="gatling使用"></a>gatling使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/gatling.sh</span><br></pre></td></tr></table></figure>

<p>参考gatling官方文档编写更复杂的脚本，比如模仿添加购物车操作，简单来说是在get函数中的url带上参数</p>
<h2 id="docker的使用"><a href="#docker的使用" class="headerlink" title="docker的使用"></a>docker的使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps //查看当前在运行的容器</span><br><span class="line">docker ps -a //查看所有</span><br><span class="line">docker run -d --name app-pi-0.5 --cpus=0.5 -p 18080:8080 app-pi //限制cpu占用时间，映射端口，命名，选择镜像</span><br><span class="line">docker stop &#123;container-hash&#125;</span><br><span class="line">docker rm &#123;container-hash&#125; //删除容器</span><br><span class="line">docker rmi &#123;image-hash&#125; //删除镜像</span><br><span class="line">docker run --name redis -p 6379:6379 -e ALLOW_EMPTY_PASSWORD=yes bitnami/redis:latest//镜像启动redis服务 第一次会自动下载</span><br><span class="line">docker logs &#123;container-hash&#125; //查看log </span><br></pre></td></tr></table></figure>



<p>vscode中的run方法不会补全pom文件中的组件，第一次运行用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean spring-boot:run</span><br></pre></td></tr></table></figure>

<h3 id="Docker相关概念"><a href="#Docker相关概念" class="headerlink" title="Docker相关概念"></a>Docker相关概念</h3><p>image 映像文件: 包括光盘的所有信息的文件 可以被运行</p>
<p>root文件系统: 内核启动后加载的第一个文件系统，包括内核代码的影响文件和初始化脚本</p>
<p>docker image相当于一个root文件系统，配置了容器运行时需要的程序、库、资源、配置参数，但是都是静态的，image不包括任何动态数据。</p>
<p>image和container 就像class 和 instance的关系，可以认为是一种特定轻量级的环境。</p>
<h2 id="Redis相关"><a href="#Redis相关" class="headerlink" title="Redis相关"></a>Redis相关</h2><h3 id="Redis-info："><a href="#Redis-info：" class="headerlink" title="Redis info："></a>Redis info：</h3><p>键值对 非关系型数据库；</p>
<p>可以内存，可以分布式</p>
<p>Redis slot：可以认为是逻辑上构建范围区间，每个节点对应一定的范围，计算出的哈希值落到一个slot中，则值存到对应的节点中去。在节点添加和减少的时候，</p>
<h5 id="cluster-配置不同的地方在于："><a href="#cluster-配置不同的地方在于：" class="headerlink" title="cluster 配置不同的地方在于："></a>cluster 配置不同的地方在于：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.redis.cluster.nodes[0]=ip:port</span><br><span class="line">...[1]=ip:port</span><br></pre></td></tr></table></figure>



<h5 id="another-redis-manager"><a href="#another-redis-manager" class="headerlink" title="another redis manager:"></a>another redis manager:</h5><p>可以用来查看redis中数据存储的情况</p>
<h5 id="尝试连接数据库查看session遇到的问题-此时使用的是JDBC"><a href="#尝试连接数据库查看session遇到的问题-此时使用的是JDBC" class="headerlink" title="尝试连接数据库查看session遇到的问题,此时使用的是JDBC"></a>尝试连接数据库查看session遇到的问题,此时使用的是JDBC</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.beancreationexception: error creating bean with name &#x27;org.springframework.boot.autoconfigure.session.sessionautoconfiguration$servletsessionrepositoryvalidator&#x27;</span><br></pre></td></tr></table></figure>

<p>解决方案：在pom.xml中添加依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h5 id="基于redis的session配置"><a href="#基于redis的session配置" class="headerlink" title="基于redis的session配置"></a><a href="https://www.baeldung.com/spring-session">基于redis的session配置</a></h5><p>bean factory 初始化失败 ：把starter-data-jpa 改成 starter-data-redis 前者是用于session-jdbc的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>连不上 给redis镜像<a href="https://www.jianshu.com/p/67fc4b1cbe1b">添加配置文件</a> 修改映射端口（见群聊讨论）？？重启 先开redis镜像 再开webpos镜像 又好了</p>
<h5 id="直接配置redis，不使用docker"><a href="#直接配置redis，不使用docker" class="headerlink" title="直接配置redis，不使用docker"></a>直接配置redis，不使用docker</h5><p>redis容器问题太多了 改用直接配置</p>
<p>下载压缩包 make后make install 确认redis-server,redis-cli可用</p>
<p>分节点配置脚本可以参考<a href="https://redis.io/docs/manual/scaling/">官方网站</a></p>
<p>自动化读取各个文件夹中的脚本来构建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for d in ./*/ ; do (cd &quot;$d&quot; &amp;&amp; redis-server ./redis.conf &amp;); done</span><br><span class="line"></span><br><span class="line">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \</span><br><span class="line">--cluster-replicas 1 &amp;</span><br></pre></td></tr></table></figure>

<p>构建之后需要检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check 127.0.0.1:7000 //example</span><br><span class="line">redis-cli --cluster fix 127.0.0.1:7000 //if something wrong</span><br><span class="line">redis-cli -h localhost -p 7000</span><br><span class="line">keys*</span><br><span class="line">flushdb //清空当前</span><br></pre></td></tr></table></figure>



<h5 id="镜像中连不上集群？"><a href="#镜像中连不上集群？" class="headerlink" title="镜像中连不上集群？"></a>镜像中连不上集群？</h5><p><a href="https://blog.csdn.net/qq_20597727/article/details/85040056">参考</a> 由于在镜像中运行程序，应使用ifconfig查看docker对应的ip，替换127.0.0.1 并且在每个节点的redis.conf中插入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected-mode no</span><br></pre></td></tr></table></figure>

<p>设置后可以在宿主机命令行用redis-cli检查各个节点状态或者查看内容</p>
<h5 id="host-网络？"><a href="#host-网络？" class="headerlink" title="host 网络？"></a>host 网络？</h5><p>待补充</p>
<h5 id="可序列化对象才能写入redis数据库"><a href="#可序列化对象才能写入redis数据库" class="headerlink" title="可序列化对象才能写入redis数据库"></a>可序列化对象才能写入redis数据库</h5><p>出现问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer ; nested exception is java.io.NotSerializableException: com.example.webpos.model.Product] with root cause</span><br><span class="line"></span><br><span class="line">java.io.NotSerializableException: com.example.webpos.model.Product</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询后发现是被写入的对象（包括cart，item，product）应该implements Serializable接口，成为可序列化对象才能写入redis数据库</p>
<h2 id="cache和session"><a href="#cache和session" class="headerlink" title="cache和session"></a>cache和session</h2><p><strong>cache</strong>：product时使用——实际的业务层是在JD 不是原先的serviceImp——用的是另一个数据库</p>
<p>@CacheEvict  清除缓存</p>
<p><strong>session</strong>: 传递cart信息 getAttribute-getCart/setAttribute-changeCart  <strong>在controller中添加 与网页运行有关</strong></p>
<h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p>编写好haproxy.cfg </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defaults</span><br><span class="line">	mode tcp</span><br><span class="line">frontend lb-app-pi</span><br><span class="line">	bind *:8080 #统一对外接口</span><br><span class="line">	default_backend servers</span><br><span class="line">backend servers</span><br><span class="line">	balance roundrobin #轮换方式</span><br><span class="line">	server server1 localhost:8081 # 单独一个服务器的端口 在本次实验中是镜像映射到本机的端口</span><br><span class="line">	server server2 localhost:8082</span><br><span class="line">	server server3 localhost:8083</span><br><span class="line">	server server4 localhost:8084</span><br></pre></td></tr></table></figure>

<p>用以下命令运行对应目录下的该文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">haproxy -f haproxy.cfg</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -nlp //是查看所有的端口占用情况</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
  <entry>
    <title>The Truth Untold--迟到两年的高中生活回忆</title>
    <url>/post/7b442c5c/</url>
    <content><![CDATA[<p>写这篇的原因是，临时起意在知乎搜索了二中，结合和朋友讨论二中老师近期的反应，有很多零零碎碎又反复出现的想法，不如一次写个痛快。</p>
<span id="more"></span>



<h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>事实上我已经几次下定决心不再关注二中的事情，但是今年高考成绩实在是让我大跌眼镜。理科前一百三人，前五十一人（来自我本届同学的消息，知乎提问中则说是两人），二中前三十对应全省排名竟然到600名左右。文科稍好，文科有榜眼。一本率和600分率我不太清楚。</p>
<p>当然也有本届的同学站出来说二中并不算差，不能因此唱衰二中。首先，要明确的是，所有讨论都没有责怪同学的意思，毕竟在自认生源不好的情况下，老师和领导会反复强调“你们这届生源不行”，但是却忘记二三中的同学的水平在除尖子以外的重合率是非常高的。因此所有讨论都无意否定同学们自身的努力。加上我本人的视野水平有限，也会更多关注尖子生，即特训班/实验班层次的整体成绩。同时，对于尖子生来说，清北也并不是衡量他们全部努力和才智的唯一标准。因此，当我批评二中成绩的时候，更多的讨论在学校自身KPI体系下学校的表现，而无意冒犯同学。我想一部分同学否定二中今年成绩不理想，可能是出于不愿否定自己努力的心理，但是当我们把学校的教学方针和同学的努力分割开，为何不大大方方的承认今年二中的成绩就是在尖子层肉眼可见的差。今年毕业的同学缺少信息来源或许不太清楚，但在已经毕业观察多届成绩，并且经历过报考选校甚至参与过招生的人眼里，历年的横向比较足以说明问题。<del>废话有些学校的朋友都快要没直系了当然说明大滑坡啊</del></p>
<h2 id="归根到底"><a href="#归根到底" class="headerlink" title="归根到底"></a>归根到底</h2><p>自我毕业以来，二中经历了收手机，加强补课等一系列衡水化的加速，期间也有不少非制度性的<del>恶性</del>事件。每一次都会激起一阵讨论，但是说来说去，问题无非都一样。</p>
<p><strong>领导层的改革缺乏可行性和科学性</strong>，朝令夕改，容易受家长影响，领导脱离实际，不够尊重一线的老师的自主权；这样导致的结果就是老师和学生疲于奔命，浪费宝贵的时间（尤其是在高三期间），并且加重老师和学生，老师和领导，学生和领导，学生和家长之间的对立情绪。瞎折腾高三是大忌，影响高一高二打基础也不是明智之举。二中领导已经到了一种草木皆兵，邯郸学步的地步了。</p>
<p><strong>对尖子生，学校领导“狡兔死走狗烹”的态度太过明目张胆</strong>，让人寒心；唯清北论也非常影响高三尖子生的心理状态。领导可能以为所有人都自小立志清北“不破楼兰终不还”，但是忘记了过大了压力会让人更早崩溃。为了KPI<em>道德绑架</em> 学生乃至进行语言上的<em>PUA</em>的情况我就不再赘述了，之前发过一个长篇说说被人喷戾气太重我可真是不愿再笑。朋友，未经他人苦莫劝他人善好吧。</p>
<h2 id="说说特训"><a href="#说说特训" class="headerlink" title="说说特训"></a>说说特训</h2><p>特训班其实是这样一个心理的产物：清北 or nothing。人们在讨论一所高中的成绩的时候，往往最先关注的是清北，连复交浙科南等都被直接无视。我曾经很不能理解，清北终究是少数，为什么家长如此执着，直到我同学一语道破：“毕竟进来之前谁都以为自家小孩是上清北的料”</p>
<p>OK Fine. 但即便是特训班，也做不到全员清北。如果真要把特训班定性成非清北不可的班级的话，我建议也别弄什么1班2班了，留15个人在理特就行了。更何况非清北不可对于在清北线边缘徘徊的同学是非常负面的，终日活在患得患失里还不如直接放弃执念。这种执念也会让认同这套价值体系的人自觉的区别对待学生个体，无论程度轻重。虽然我们的班主任不止一次的抱怨过我们“没有血性”，但在我看来这恰恰是00后某种心理上的转变：清北的光环并不值得你牺牲一切，比如心理和生理的健康。忽视这种执念与情结的淡化，一味的通过否定其他学府的价值来道德绑架学生，显然并不能达到“冲一冲”清北“的效果。<del>有兴趣可以知乎搜索南宁二中，有一部分各届特训班同学的回答有点意思的</del></p>
<p>再来说说特训班自身。以我自己为例，虽然特训班偶尔要被领导恶心几个小时（骂的就是座谈会），但是氛围搞得好的话也能享受和高手过招的快乐。说到生源，大家似乎都比较喜欢以6A+评定尖子生源好坏。甚至后来几届的分班也基本以5+6+为一锤定音的根据。但是在我看来这显然不科学。如果观察过历年尖子生榜，你不难发现，4A+5A+的同学不在少数；甚至我所在的特训班的入口成绩分布也以4、5个A+占大头。在我看来，如果二三中在4 5A+的人数分布没有明显差距，那么考不好就不是尖子层学生的错，而是教学方针的问题。而这教学方针，又与领导有更大关系。毕竟我的班主任和科任老师在每次大考后开完会都会肉眼可见的焦虑。领导不适当的施压和干涉只会打乱老师原本的教学安排，这种错误最后必定会传导到学生身上。与我朝夕相处的老师无论如何都还会真正关系我作为个体的发展，而一年到头见不到几次面的领导可就不一定了。</p>
<h2 id="一个理想主义者的自白"><a href="#一个理想主义者的自白" class="headerlink" title="一个理想主义者的自白"></a>一个理想主义者的自白</h2><p>在我认识的人当中，我可能是骂二中骂的最狠的那一个（乐了。从高三开始，在我见识到一些社达言论以后，我感到自己被拉扯撕裂。作为一个16年入学的人，多少还是享受了二中最后几年的宽松氛围，有幸体会了“启牖智慧 活泼身心“的校训。我曾经也是真的相信来到二中可以借助这里优秀的师资和同学氛围来self-educate成一个人，而非一个工具的。但是一些急功近利的措施和言论让我开始动摇：某些人眼里，我们也只是KPI工具人罢了。</p>
<p>当我和大学同学聊到我的高中的时候，我突然意识到，让我有归属感的是我的老师，我的同学，还有那个允许我“八分精力在学习，两分精力瞎搞”的氛围。<strong>会痛苦，会失望是因为依旧对那里有期待。</strong>介于我本人的性格是有感情也照样嘴的，所以一年前写下关于我在特训班一些不愉快记忆但却被人说戾气重以及被讲“此人观点需要观望”的时候，我不明白了。有些人对二中莫名其妙的滤镜大到听不得一点点真话。</p>
<h2 id="防杠说明"><a href="#防杠说明" class="headerlink" title="防杠说明"></a>防杠说明</h2><p>为了防止有些人说我纸上谈兵破而不立，先声明，我不能保证我的观点一定正确，毕竟我只是从我自己的角度出发，谈谈我作为一个曾经的学生所见所思。不过介于有些老师认为有意见的特训班学生是白眼狼，我只能说<strong>所有特训班的学生都没有跪着求进二中的特训班 凭成绩进出谁也不欠谁 如果你真的在乎老师付出的额外努力就应该看看这些努力到底是有用的还是在互相折磨学生与老师</strong> </p>
<p>写破防了，呼应一下题目，用The Truth Untold歌词收尾吧</p>
<blockquote>
<p>난 울고 있어，</p>
<p>我泪流满面，</p>
<p>사라진，</p>
<p>消失的，</p>
<p>무너진，</p>
<p>倒塌的，</p>
<p>홀로 남겨진 이 모래성에서，</p>
<p>独自残留下的这沙城之中，</p>
<p>부서진 가면을 바라보면서，</p>
<p>望着这破碎的假面，</p>
<p>And I still want you，</p>
</blockquote>
]]></content>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-world</title>
    <url>/post/b1d4025b/</url>
    <content><![CDATA[<p>如果表达是为了给自己记录，而不是为了成为大触，那么表达的好坏是无所谓的。</p>
<p>所以这里只是各种碎碎念</p>
]]></content>
  </entry>
  <entry>
    <title>tunneling socket could not established， cause = getaddrinfo ENOTFOUND 解决方案</title>
    <url>/post/d0b95d98/</url>
    <content><![CDATA[<p>这个错误同时在PicGo上传图片和我登陆科学上网小工具的时候出现。一开始在科学上网工具出现的时候没当回事，以为是工具本身问题，再次出现发现不对劲，应该配置问题。</p>
<p>感谢谷歌,让我翻到一个<a href="https://www.lifeee.top/posts/1004.html">参考解决方案</a>。</p>
<p>因为不是PicGo本身的问题，所以搜索到的调整PicGo的方案都不符合我的要求，最后发现是当前用户的系统变量莫名其妙多出来一个https的环境变量，删除以后解决。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title>与Chatgpt二三事二三思</title>
    <url>/post/6a1e4dd7/</url>
    <content><![CDATA[<h2 id="Chatgpt会威胁人类吗"><a href="#Chatgpt会威胁人类吗" class="headerlink" title="Chatgpt会威胁人类吗"></a>Chatgpt会威胁人类吗</h2><p>大概会威胁到脑子空空的人。</p>
<p>最早注意到Chatgpt是在豆瓣看到一个测试它的<a href="https://www.douban.com/group/topic/279710957/?_i=785876838f16251">帖子</a>。当时我对帖子里“AI具有鉴赏、哲学思考的可能性从而让人感到威胁”的观点有所不同意。在我的一番“抬杠”下，我发现Chatgpt会从提问里学习提问者的话术再生成回答（也许是In-context learning的一种表现？），因此提问者实际上是被自己的才华惊讶而非Chatgpt。而且仔细推敲，Chatgpt的答案实际上欠缺逻辑，也欠缺事实，信息量有限。</p>
<p>因此，我当时对Chatgpt的判断是：</p>
<ul>
<li>一只人类友好的学舌鹦鹉，在处理文书、工作邮件等有模版需要填内容的文件表现优异</li>
<li>只靠Chatgpt，是没有逻辑和信息量的</li>
</ul>
<p>人一直认为创造力是人的独有，所以人们能用Chatgpt创作小说的时候，不免又有惊恐的声音出现。但是Chatgpt更像是一个初步的索引。比如让写小说大纲，它能洋洋洒洒写出一篇。然而创作大纲本身有规律可循，网上也有不少教程总结过。Chatgpt学习了这部分语料而人没有学习就会让人觉得不明觉厉。但是对于精于创作的人（或者比较挑剔的人）来说，大纲就只是大纲，缺乏更多细节。</p>
<p>综上，我认为该感到恐慌的人，是所书写的文字材料本身就是套话空话，信息量少的类型。还有一群人，或许不恐慌，但是需要小心被新时代人工智能的洪水淹没的可能———没有办法判断别人话语里逻辑和事实的人，也许很容易被Chatgpt给忽悠了。</p>
<p>逻辑、理性和创造力，或许始终是人类的诺亚方舟。</p>
<h2 id="Chatgpt是生产力新突破吗"><a href="#Chatgpt是生产力新突破吗" class="headerlink" title="Chatgpt是生产力新突破吗"></a>Chatgpt是生产力新突破吗</h2><p>可以是，取决于科技巨头和开发者们能多大程度弥补Chatgpt的缺陷并创造更多的可能性。</p>
<p>因为之后我才知道，无法提供准确事实并不是Chatgpt不可战胜的通病——毕竟它还并非一个完美的产品。谷歌和微软，两个都有搜索引擎产品的巨头，都开始积极追赶，将类Chatgpt和自家产品融合。Chatgpt作为人类友好的途径，加上搜索引擎能够提供的信息，也许会像当年搜索引擎带来的革新一样，再次刷新人类获取知识和信息的途径。</p>
<p>与匆忙上阵的谷歌相比，微软的New Bing似乎给一直被压着打的Bing提供了新的生机。New Bing弥补了Chatgpt不能联网信息不及时的问题。微软的野心不至于此，微软计划让自家各类产品，包括Office系列（经典看家产品），Dynamic 365（To B信息平台）都搭上这趟顺风车。微软实际上是OpenAI一直以来的投资者，如果没有微软，像Chatgpt这样对算力和数据集要求的非常高的项目不可能坚持下来。相比之下，支持DeepL的谷歌能否在之后再带来惊喜突破，还需要观察。</p>
<p>Chatgpt的开发生态同样相当精彩。<a href="https://www.chatpdf.com/">读pdf的</a>，<a href="https://springwood.me/chatgpt-api-use-in-macos/">在系统上增加小插件</a>做语言翻译润色相关小工具的，做本地资料wiki的…… 总是时不时能在社交媒体上刷到新的基于Chatgpt API的应用。目前已经有人尝试用Chatgpt提供的API来搭建问答型对话搜索服务， 对于有大量文档数据的人，借助Chatgpt可以搭建起更用户友好的调研报告框架；而对于之前像我一样不满足于Chatgpt一本正经胡说八道的开发者来说，与更专业的AI结合是一个新的可行方案。比搜索引擎更有吸引力的信息获取、呈现方式，能做为基础工具开发不同类型的知识问答搜索产品，通过提供链接，保留来源兼容过去搜索引擎，Chatgpt类似服务的商业化的前景，在谷歌和微软的竞相“画饼”中变得似乎清晰起来。</p>
<p>因为我不是搞AI的，我还关心其他码农是否会被替代，以及是否能在其中分一杯羹。现在我的判断是不会，Chatgpt本身依赖云端服务（目前是挂在微软家的Azure上），在大规模提供服务访问的场景，在使用Chatgpt之后商业数据机密能否得到保证的场景下，不搞AI的工程师们依旧有事可做。所以尽管Chatgpt能写代码，我还是持一种谨慎乐观的态度期待着。</p>
<p>不过要回答Chatgpt是否是一个像iPhone一样划时代的生产力跃升新产品，我觉得还需要思考以下两个问题：</p>
<ul>
<li>为什么搜索引擎不是人们获取信息的最终形态？</li>
<li>为什么Chatgpt有威胁到搜索引擎的能力？</li>
</ul>
<p>如果Chatgpt能够比搜索引擎更诱人，那么它的商业价值就显然比Web3更值得期待。<strong>搜索引擎需要正确的提问才能返回高质量的结果，Chatgpt降低了“正确提问”的门槛。</strong></p>
<p>我认为这和人们实际上并没有那么会提问有关系。我记得大学刚入学的时候，有幸听到了“解决问题的艺术”这一讲座，对里面“学会提问”的板块印象深刻。事实上很多人都不擅长提问，面对无解决措施的场景，面对需要学习新知识新领域的场景，很多时候人们是不清楚自己应该获取什么信息的，自然也不知道应该问什么问题。就算有了问题，如何通过搜索关键词来锁定范围，选用什么样的平台（百度？Bing？Google？经典争论就是Debug去CSDN还是去StackOverflow），也并不是人人都能掌握利用好搜索引擎的技巧。这就像一个人要到森林里寻宝，但是他手上压根没地图，又怎么会知道该往哪走呢？</p>
<p>举个例子，我想对我记账软件里的流水数据做分析，看看什么地方我能够缩减开支。但是我对财务一窍不通，也不太会用Excel制图，如果Chatgpt能基于我提供的数据绘制出一目了然的图表、给出财务建议并附上相应策略的来源链接，那么我可以节省很多摸索的时间。我可以顺着链接去了解不同类别的个人支出管理方式，从而让Chatgpt调整策略。偌大的森林，可以不再是一片迷雾。</p>
<p>Chatgpt或许能从更简单的问题出发，画出一幅知识脉络地图，即整合知识并且给出简单的介绍描述，指明一条可行的道路，即给出资料数据的来源链接。除了流畅的语言表达，微软提供的Chatgpt加持的bing还有生成图表的功能，这也反映了类Chatgpt的趋势：更人类友好，更简单清晰的交互方式。这让我想起最近看的黑豹2里，苏睿公主设计的AI小助手——有问必答，提供翔实资料的AI小管家。Chatgpt更胜于搜索引擎的地方，或许就在于此。</p>
<p>要说新突破，不得不提到<strong>Chatgpt让作为生产力工具的AI不再是技术领域人们的专享</strong>。语言是思考的载体，不仅是做Tech的，其他领域的人也会想要利用人类友好的工具提升效率。他们不一定会使用Chatgpt本身，但是很有可能会喜欢使用基于Chatgpt的服务。与过去的概念比，至少Chatgpt的使用场景切实、靠谱很多。</p>
<p>我最近的使用体验be like：</p>
<ul>
<li><p>当智能代码手册用</p>
<img src="/post/6a1e4dd7/Untitled.png" class title="Untitled">

<ul>
<li><p>和手册对比</p>
<img src="/post/6a1e4dd7/constrast-16782458845638.png" class title="constrast"></li>
</ul>
</li>
<li><p>帮忙Debug</p>
<ul>
<li>直接复制粘贴报错到Chatgpt，告别了以前打开一大堆浏览器页面寻找合适解决方案的日子。</li>
</ul>
</li>
<li><p>寻找合适的工具</p>
<ul>
<li>我问Chatgpt： is there any online service to tell whether a picture is ps?</li>
<li>它优化了我的提问（原来可以用edited or fake photos表达“被p过的图”）并且提供了平台推荐</li>
</ul>
</li>
<li><p>帮助没做过数据分析的我在两个小时时间里处理我的开销记录并绘制趋势图供我分析（日后会写文章补充）</p>
</li>
<li><p>在我emo的时候提供情绪建议</p>
<ul>
<li><p>在情感上更加人性化。人在情绪波动大的时候未必能合理的组织自己的问题。通过Chatgpt能得到一个初步的回答。</p>
</li>
<li><p>我认为AI对人类的挑战不是科幻片里的控制资源，而是让人心依赖而不自知。我认为这里的Chatgpt很好的安慰了我，无爹味很真诚。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Chatgpt是技术奇点吗"><a href="#Chatgpt是技术奇点吗" class="headerlink" title="Chatgpt是技术奇点吗"></a>Chatgpt是技术奇点吗</h2><p>可能是，但是最终的答案，得取决于Chatgpt多大程度上能模仿人类逻辑思维情感，甚至超越人类。</p>
<p>AI是否是技术奇点被讨论了很长时间。简单说就是AI能完全模拟人类智能甚至超越的时刻，就是奇点时刻。如此，人类让机器来解决复杂问题的梦想或许就能实现了。可惜的是，过去的AI一直停留在处理相对简单的判断、分类上，对于内容生成，内容理解还和人类有着很大的差距。</p>
<p>Chatgpt的成功让大语言模型LLM进入了大众的视野，这种基础型的研究展现了它的威力。不过我认为目前也有一些新闻报道危言耸听了。比如有个新闻标题说Chatgpt具备了九岁小孩的智力，但是新闻援引的研究本身讲的是Theory of Mind，简单来说就是看上下文语境的能力。新闻标题多少是以偏概全了。</p>
<p>单项上媲美人类当然不能算是完全具备，但是这也引出了核心问题：我们是如何定义人的智能的？Chatgpt要在多少项能力上模仿人类，我们才会认为它已经能与人类并肩？换句话说，人类的智能，能被拆分成多少标准？Chatgpt大概能激发出许多有趣的哲学讨论。</p>
<p>就目前极其活跃的Chatgpt<a href="https://gpt3demo.com/">生态</a>和不断好评的使用体验而言，Chatgpt即便最终被证明不能与人类智能并肩，它目前也已是一个让人眼前一亮的赛博伙伴。当越来越多的人和Chatgpt相聊甚欢，用Chatgpt及相关服务提升效率的时候，或许意味着我们离奇点时刻又近了一步。</p>
<h2 id="Chatgpt会拉大人和人的差距吗？"><a href="#Chatgpt会拉大人和人的差距吗？" class="headerlink" title="Chatgpt会拉大人和人的差距吗？"></a>Chatgpt会拉大人和人的差距吗？</h2><p>又是一个It depends的问题。有人能提升效率，有人可能会被彻底甩出浪潮之外。</p>
<p>互联网诞生之初，人们相信信息变得触手可及，互联网会带来平等。但是事实并非如此，无论刻意还是无意，人们都事实上建立了小群体与信息茧房。同理，一个新技术工具的愿景，是否能落地取决于人。</p>
<p>什么都会，样样未必都精通的Chatgpt可以让学习曲线变得平缓。但是真正能利用好Chatgpt的仍然是那些能看出Chatgpt给出框架下空白，想要攀登学习曲线和想要用Auto工具带来便利的人。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Chatgpt</tag>
      </tags>
  </entry>
  <entry>
    <title>保研就业分享</title>
    <url>/post/e7143260/</url>
    <content><![CDATA[<h2 id="就业分享"><a href="#就业分享" class="headerlink" title="就业分享"></a>就业分享</h2><p>认识自己 再去考虑工作的去向</p>
<p>想是没有用的 去尝试才会知道</p>
<p>大学期间 转型是代价相对小的</p>
<p><img src="/post/e7143260/image-20220526164234394-16594014462471.png" alt="image-20220526164234394"></p>
<p>但是需要有一个标准</p>
<p><img src="/post/e7143260/image-20220526164413972.png" alt="image-20220526164413972"></p>
<p><img src="/post/e7143260/image-20220526164744117-16535548658031.png" alt="image-20220526164744117"></p>
<p>技巧+实力 对问题有思考</p>
<p><img src="/post/e7143260/image-20220526164841788-16535549237082.png" alt="image-20220526164841788"></p>
<p>从课程项目入手的指南</p>
<p>简历</p>
<p><img src="/post/e7143260/image-20220526165339138.png" alt="image-20220526165339138"></p>
<p><img src="/post/e7143260/image-20220526165808015-16535554895653.png" alt="image-20220526165808015"></p>
<p><img src="/post/e7143260/image-20220526170026861.png" alt="image-20220526170026861"></p>
<p><img src="/post/e7143260/image-20220526170154076-16535557151634.png" alt="image-20220526170154076"></p>
<p><img src="/post/e7143260/image-20220526170318981-16535557999605.png" alt="image-20220526170318981"></p>
<h2 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h2><p><img src="/post/e7143260/image-20220526171216845.png" alt="image-20220526171216845"></p>
<p><img src="/post/e7143260/image-20220526172011878.png" alt="image-20220526172011878"></p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJU</tag>
      </tags>
  </entry>
  <entry>
    <title>前人栽树后人乘凉-配置自己的RSS</title>
    <url>/post/68913f78/</url>
    <content><![CDATA[<p><em>希望solo追星但是不愿意错过大粉物料的，速来！</em></p>
<span id="more"></span>



<h2 id="为何使用RSS"><a href="#为何使用RSS" class="headerlink" title="为何使用RSS"></a>为何使用RSS</h2><p>面对纷繁的信息和无穷无尽的粉丝撕逼（不是），我一直以来渴望一个收集器，只获取我需要的信息/idol物料。偶然间看到RSS，发现它完美符合了我的需求：</p>
<ul>
<li>主动抓取，我不需要跟在博主或者平台后面翻找</li>
<li>跨平台的整合 从微博到一些专业新闻网站</li>
</ul>
<p>使用现有的RSS平台（这里我用的是<a href="https://feedly.com/">Feedly</a>），加上一些<a href="https://docs.rsshub.app/">插件</a> 可以轻松完成跨平台的信息收集。如果需要更近一步的个性化配置，也可以自己搭建RSS服务。</p>
<h2 id="为何需要插件"><a href="#为何需要插件" class="headerlink" title="为何需要插件"></a>为何需要插件</h2><p>RSS 的全称是 Really Simple Syndication（简易信息聚合），简单说就是一个订阅网站更新的协议。被订阅的网站需要有对应的RSS链接，就像电话联系需要有电话号码一样。如果网站有，皆大欢喜，如果没有就需要配合插件使用。</p>
<p>目前我使用的插件是一个有规模的插件服务，支持非常多的原本不支持RSS的网站订阅。但是可能因为部分网站采取了反爬策略，有一些无法通过原本的服务器订阅。比如豆瓣和微博。</p>
<p>参照教程，在本地部署了RSS后，豆瓣小组的内容可以被爬取了。估计需要保持本地RSS运行才能及时获取消息？</p>
<p>但是微博依旧不可。</p>
<p>于是找到另一个<a href="https://rssfeed.today/weibo/">生成微博订阅的网站</a> 成功解决问题</p>
<p>更新：rsshub的服务器被twitter反爬了，所以找了<a href="https://uneasy.win/2020/05/rsshub%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%B2%E6%94%AF%E6%8C%81twitter/">别人的服务器</a> 现在只需要按照rsshub的手册写地址配参数的同时，把网址替换成博主提供的网址就可以了。</p>
<p>注意这里的twitter id是分享链接中尾部的标识符，也就是一般推特名字下方给的@号后的内容</p>
<blockquote>
<p><a href="https://rsshub.uneasy.win/twitter/user/YourTargetId">https://rsshub.uneasy.win/twitter/user/YourTargetId</a></p>
</blockquote>
<h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>虽然我也知道当代人面对纷繁的信息洪流，应当沉下心来读书，回归经典。高中的时候我曾经写过一篇随笔说明这个问题，那时候我的态度就是两手都要抓，两手都要硬。即时的信息也有它的意义，正是当下的点滴构成了如今我们所处的潮流。但是与经典书籍相比，信息/新闻的纷繁是它最大的弱点。RSS可以让人重新夺回面对信息流的主动权，从这个意义上说，构建这样一个信息茧房不是坏事。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Java实现简单Reactor</title>
    <url>/post/b5bd3a01/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Reactor最早是在<a href="http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf">这篇论文</a>中提出的 作为Java课程拓展阅读的笔记，主要分析老师给的<a href="https://github.com/caochun/java-server/tree/main/src/main/java">参考实现</a>和论文中介绍的组件的对应关系。</p>
<p>一张解释了各个组件之间关系的图：</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211134127551.png" alt="image-20211211134127551"></p>
<p>InitiationDispatcher （以下简称ID）是事实上监听事件的组件，其中使用NIO的实现方式，因为实际上一个Reactor中ID尽可能的使用单线程的方式实现，如果轻易阻塞会极大影响效率。同时具有一张用于分发的EventHandler表，在事件注册的时候进行初始化。SynchronouseEventDemultiplexer是用于通知ID的组件。</p>
<p>EvenHandler和Handle实际上实现了“Dispatch”（分发）的功能，事件注册时需要在ID中注册。</p>
<p>在看懂Reactor的代码之前，需要理解网络通信，以及了解NIO的实现机制。</p>
<h2 id="Reactor-Basic"><a href="#Reactor-Basic" class="headerlink" title="Reactor Basic"></a>Reactor Basic</h2><p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211135057739.png" alt="image-20211211135057739"></p>
<p>可以理解为Reactor统一处理请求，再将请求根据具体的任务分发到具体的acceptor，交给对应的处理函数执行（demultiplexing）代码对应single文件夹，其中包括了基础的组件。</p>
<p>Handler（Runnable）对应了论文中的EventHandler，其中需要初始化socket，并且设置为NIO模式（将会使用到select）。</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211135532346.png" alt="image-20211211135532346"></p>
<p>此外，最重要的是注册事件。注册事件实际上除了绑定到特定的selectkey上，还会在启动run的时候绑定具体的处理函数。</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211135554150.png" alt="image-20211211135554150"></p>
<p>特别的是，所有事件注册在同一个Reactor的socket上，因此Accept事件结束后要用interestOps注册下一个需要被处理的事件。</p>
<p>Reactor类中的run中的循环实际上对应着论文中的ID，进行监听，select实现了NIO，在监听到事件后进行分发。其中的dispatch函数就是提取之前注册在selectkey上的handler对应的具体的Runnable来执行。</p>
<p>Basic的缺点是，在执行任务的一侧，依旧是多线程，并没有解决最开始希望减少线程开销的目标。因此在Pool版中使用了线程池来有效管理资源。</p>
<h2 id="Pool-Reactor"><a href="#Pool-Reactor" class="headerlink" title="Pool Reactor"></a>Pool Reactor</h2><p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211140352313.png" alt="image-20211211140352313"></p>
<p>除了增加线程池相关，其他代码与basic没有太大差别。</p>
<h2 id="Multiple-Reactor"><a href="#Multiple-Reactor" class="headerlink" title="Multiple Reactor"></a>Multiple Reactor</h2><p>注意到上述两种，不同事件都注册在同一个selector上，在同一个线程中处理，而不同的事件处理时长可能不同，在同一个线程中可能会阻塞。因此考虑把事件分类，并用不同的selector处理。提高效率的同时增加了拓展性。</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211140628740.png" alt="image-20211211140628740"></p>
<p>示例代码中把事件分为连接事件和操作事件，MainReactor和SubReactor分别进行处理。在这种模式下，thread的使用模式（单线程/无限制的多线程/线程池）不受限制。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>字节iOS实习小结</title>
    <url>/post/67d81b79/</url>
    <content><![CDATA[<p>20220105-20220513 字节 iOS岗位实习</p>
<p>借用KISS框架做一个简单小结</p>
<h2 id="Keep-需要保持的"><a href="#Keep-需要保持的" class="headerlink" title="Keep-需要保持的"></a>Keep-需要保持的</h2><ul>
<li>相信自己有解决问题的能力，遇到技术/业务上不懂的地方先尝试自己弄懂；</li>
<li>学会提问，提问的时候介绍清楚背景和自己目前所做的努力；</li>
<li>分隔开工作学习生活，保持完全投入和完全抽离。在工作时间段只想工作中的事情，其他时间段保存精力或者专心处理其他，忙碌的时候这一点尤为重要，可以减少不必要的内耗；</li>
<li>留意工作中开发和学校中项目的不同，多反思多学习；</li>
<li>从要跳槽/写简历的角度看待自己的工作；</li>
<li>写代码的时候保持记录，写好文档；根据文档做代码收敛和优化；</li>
</ul>
<h2 id="Improvement-需要改进的"><a href="#Improvement-需要改进的" class="headerlink" title="Improvement-需要改进的"></a>Improvement-需要改进的</h2><ul>
<li><p>写代码尽可能遵照调研-技术方案-开发-自检-代码说明的流程，让代码思路设计更加完备，简洁，符合规范；</p>
</li>
<li><p>读原有代码的时候理解逻辑，做到和自己需求相关的闭包内容都了解清楚；</p>
</li>
<li><p>沟通！沟通！沟通！无论是业务需求、技术问题还是代码规范，自己有了思路以后不要埋头苦干，多向mentor以及对接的同学进行确认；</p>
</li>
</ul>
<h2 id="Start-需要开始的"><a href="#Start-需要开始的" class="headerlink" title="Start-需要开始的"></a>Start-需要开始的</h2><ul>
<li>工作之余借当前项目进行技术钻研，多读代码</li>
<li>在调研和写tech solution的阶段多咨询mentor</li>
</ul>
<h2 id="Stop-需要停止的"><a href="#Stop-需要停止的" class="headerlink" title="Stop-需要停止的"></a>Stop-需要停止的</h2><ul>
<li>停止假设对接人是完美的，停止“非我职责”的想法，遇到问题多问多push</li>
</ul>
<p>原本在四月初就应该离职回学校的，因为疫情滞留上海在学业和实习中苦苦又支撑了一个月。也算是因祸得福做了一个更大的项目。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Career</tag>
      </tags>
  </entry>
  <entry>
    <title>字节上海客户端面经一二三面</title>
    <url>/post/c9d2088f/</url>
    <content><![CDATA[<p>1115 内推投简历<br>1117 hr联系约19号面试</p>
<h2 id="1119一面"><a href="#1119一面" class="headerlink" title="1119一面"></a>1119一面</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul>
<li>进程线程</li>
<li>平常用线程编程过吗 举个例子？</li>
<li>刚刚提到互斥 怎么保证线程互不干扰？</li>
<li>死锁 </li>
<li>提到银行家算法就说一下具体实现</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>怎么用两个队列实现一个栈？</li>
<li>排序有了解吗 </li>
<li>说一个印象深刻的排序算法？（讲了快排）</li>
<li>快排既然有比较差的情况 怎么改进？</li>
<li>平均复杂度是nlogn 是怎么算出来的？</li>
<li>还有什么印象深刻的数据结构？ </li>
<li>（讲到树） 既然刚刚提到交换左右子树的题就写一下吧</li>
<li>一道算法题 交换左右子树 （一边写一边解释了思路 没有跑）</li>
</ul>
<h3 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h3><ul>
<li>基本的TCP UDP介绍一下？</li>
<li>刚刚提到TCP有保证稳定链接的机制 提到拥塞控制 详细说一下过程？（快恢复还是啥忘记名字了 面试官提示了一下）</li>
<li>拥塞控制中怎么知道网络的拥塞程度的呢（前面关于阈值和ccwindow名字想不起来了） </li>
<li>可以具体再说说吗（说到收到冗余3次和超时两种情况 会对应不同的处理方式</li>
</ul>
<h3 id="介绍一个课外项目"><a href="#介绍一个课外项目" class="headerlink" title="介绍一个课外项目"></a>介绍一个课外项目</h3><p>说了南小包 问了如何处理一些错误情况 异常 比如用户支付失败</p>
<h3 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h3><ul>
<li>如何实现随机播放音乐<ul>
<li>一个是均匀随机 面试官提示了洗牌算法</li>
<li>一个是权重 完整听到的歌加权重</li>
</ul>
</li>
</ul>
<h3 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h3><p>问了一下做什么业务<br>一般用什么语言</p>
<p>1119 晚上7点半 一面通过 </p>
<h2 id="1122下午四点二面"><a href="#1122下午四点二面" class="headerlink" title="1122下午四点二面"></a>1122下午四点二面</h2><ul>
<li><p>问了一些个人规划</p>
</li>
<li><p>为什么投iOS？（简历上写得多的是后端 我说看起来新手友好所以想试一下 面试官：”看来是做什么都可以对吧” 我：”是这样的“）</p>
</li>
<li><p>你觉得自己优势的能力？</p>
</li>
<li><p>做过最有挑战性的项目？（提到了大二上PA搞了我一个星期的bug）</p>
</li>
<li><p>这个bug为什么花了一个星期 最后怎么解决的 最后有和同学交流吗</p>
</li>
<li><p>现在让你debug你会怎么做？</p>
</li>
<li><p>一个电商平台你会如何设计？</p>
<ul>
<li>写一个计算满减的结算函数？</li>
</ul>
</li>
</ul>
<blockquote>
<p>基本没问啥算法 都是软问题</p>
</blockquote>
<h3 id="反问-1"><a href="#反问-1" class="headerlink" title="反问"></a>反问</h3><p>实习生培养？</p>
<p>1123 二面通过 约三面</p>
<h2 id="1124晚上七点三面"><a href="#1124晚上七点三面" class="headerlink" title="1124晚上七点三面"></a>1124晚上七点三面</h2><ul>
<li>问了个人规划 为什么这个时候投实习（说计划本科出来工作所以来试试）</li>
<li>不打算读研吗  </li>
<li>对什么方向感兴趣（因为我感兴趣的方向我也不是太懂 就说还需要探索）</li>
<li>介绍一下做的app应用吧——被问了一堆业务端逻辑设计给我问傻了 主要是写一些request和response流程</li>
<li>社交app好友列表 怎么在手机上第一次获取好友列表</li>
<li>在pc上添加了好友 在手机需要怎么同步<ul>
<li>说想要添加删除的信息 说成了log 给了提示 设备上可以获取与某个好友加好友的时间 还有另一个条件我忘了因为不理解 然后说了一下用加好友的时间倒序检查手机上没有登陆更新的这段时间的好友添加时间然后更新 </li>
<li>时间快到了就没多问 感觉确实盲区了55</li>
</ul>
</li>
<li>平常除了课本还看什么技术内容吗<ul>
<li>提到在看拓展阅读读到java虚拟机相关+垃圾回收 但是不熟 属于把自己坑到了</li>
</ul>
</li>
<li>大三什么时间方便实习 上课怎么办？</li>
</ul>
<h3 id="反问-2"><a href="#反问-2" class="headerlink" title="反问"></a>反问</h3><p>怎样学习客户端设计逻辑？</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>1125口头offer 1129隔了一个周末邮件正式offer确认 </p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>微软实习小结</title>
    <url>/post/6f29a5ac/</url>
    <content><![CDATA[<h2 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h2><p>实习开始前有一个有意思的小插曲，我申请过一次换组。微软暑期实习分组和项目本身是开盲盒，算法分到开发的也大有人在。可能是因为我上一段实习主要做客户端开发的工作，最开始发邮件给我分到的组主要是做前端的。于是我发邮件问组里有没有后端的项目能让我去做，对方虽然答复我说组里主要做前端没有后端项目，但是愿意帮我去向大老板申请能不能给我换组。于是后来我成功换到了我后来实习的组。我的manager也知道我想要做后端于是让我的mentor给我安排了相关的任务。</p>
<p>我得到的经验是还是需要尽力去争取，说不定就成了呢。这件事还给我的manager留下了我”明确知道自己喜欢什么并且勇于争取“的印象。算是一种肯定（？）</p>
<p>我们组是一个新组，文档有，但是要么基于其他组，要么不够完善，所以基本只能看个大概有所了解。更直接的方式是问mentor和同事们，比如我在第一天参加站会的时候就请大家介绍了一下组里在做的产品，有了个大概的认识。可以说作为新人，我是在和大家一起成长的。但好在同事之间非常欢迎互助，不止一个不是我mentor的同事鼓励我多多提问。</p>
<p>对于有点自闭社恐的人来说，还有一个了解组里技术背景的方式是站会。一个能对新人暴露足够多信息的站会在我看来需要包括以下要素：</p>
<ul>
<li>每个人需要提到自己的block和进度，详细到技术名词</li>
<li>谈到自己的任务的时候会提及上下文，即任务的上下游部门是哪些，采用了什么技术，达成什么目标，正在与谁协作</li>
<li>提到的技术工具 组里有文档或者群聊记录有提及</li>
</ul>
<p>我重构信息的方式是，先不求甚解，尝试通过大家讨论block的时候的信息在脑子里画一个依赖图，对于能查到文档的或我自己的项目也用到的技术，去看看文档；听到新的技术名词的时候问问自己，猜想这是用来解决什么问题的，必要的时候直接问。经过大概两周的时间，我就能描述出组里做什么，每个同事做什么模块。这对定向求助以及理解自己在组里的位置非常有帮助。</p>
<p>组里主要是基于Scrum流程来安排工作的。除了每天的站会之外。每周会有一些固定会议，大家一起讨论当前遇到的问题，基于Azure DevOps看板盘点当前大家的任务进度并分配新的任务；还会安排专门的knowledge sharing和happy hour供大家交流学习和团建。</p>
<p>和学校里非常不同，工作当中沟通讨论的时间和写代码的时间可以说是对半。写代码的时候为了写代码而准备的时间有时候又比写代码本身要长。所以，写代码很重要，但是不是工作的全部。</p>
<h2 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h2><p>对新人来说最重要的是学习，又可以分为基于任务的快速学习和系统学习。</p>
<p>基于任务的快速学习的关键是模仿、学习和从少到多的实践。一开始mentor给我安排的是debug的任务，让我可以了解组里现有的代码架构，学习有经验的同事的代码写法。之后再通过阅读类似任务的代码和工具手册来设计自己任务的方案，不会的就多查多问。看到一个观点，说小成功才是成功之母，人对自己的信心是从一点一滴开始建立的。如果能看懂原有的代码，简单的任务能够上手，那么面对新工作自己是否能胜任的担忧也会慢慢消失的。</p>
<p>二八法则在这里再一次适用了。尽管大部分时间花在快速学习，大部分问题都能通过快速学习解决，但是系统的学习仍然是非常重要的部分。我自己在实习期间没有能系统的学习感兴趣的技术和话题，但是我的同事有谈到自己的经验，系统学习能让人在关键时刻抓到重点。比如，由于我在学校学习过Java（和C#很多机制类似，包括微服务的部分），而我有一位新入职的校招同事以前主要使用的是C++，我发现自己过去系统学习的知识能够在一些关键点上促进理解。我猜这就是为什么大组每个月都会空出一个周一给工程师们做Learning Day。</p>
<h2 id="转正面试趣闻"><a href="#转正面试趣闻" class="headerlink" title="转正面试趣闻"></a>转正面试趣闻</h2><p>面试官似乎很看重对产品逻辑、用户需求的理解，引导我往这方面思考和讨论了很多。印象最深的是被问到，To B产品在用户规模扩张的时候，随之需要投入的各种资源增长的速度比To C的快很多——比如羊了个羊游戏，用户增加的时候需要增加的可能只是服务器资源，但是对于ToB产品来说会复杂很多——那么有什么办法能压平规模增长下成本随之增长的曲线？（这个问题真的很难，我到现在都还没有很好的想法）</p>
<p>实习小结我因为种种原因拖了将近两个月才写完。转正虽然挂了，但是还是依旧感谢这三个月的时间。我意识到原来每天早上可以因为期待去上班而不赖床速速起身，原来工作可以是一件有成就感的事情。想要带着这份珍贵的回忆继续前行。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Career</tag>
      </tags>
  </entry>
  <entry>
    <title>怨种23届本科生秋招实录</title>
    <url>/post/d5aef8f3/</url>
    <content><![CDATA[<h4 id="我的背景"><a href="#我的背景" class="headerlink" title="我的背景"></a>我的背景</h4><p>本科CS科班，无竞赛无比赛绩点在中游保研边缘，简历上主要是偏后端底层的课设，有一段4个月字节iOS客户端实习经历，秋招开始的时候在微软暑期实习，做的后端相关，时长3个月。</p>
<h4 id="Offer情况和时间线"><a href="#Offer情况和时间线" class="headerlink" title="Offer情况和时间线"></a>Offer情况和时间线</h4><p>7月底暑期实习期间就开始同步秋招，在9月份初拿到了宁德时代的offer，因为薪资不满意+觉得秋招还有机会拒了，9月中旬拿到了Thoughtworks年包税前不到20w的offer，之后屡战屡挂，10月中下旬进了菊花厂大鱼池，微软暑期转正最终因为没有hc在11月被挂了，12月初侥幸被捞上岸拿到了阿里后端年包40w的offer</p>
<p>面试了大概30+场，笔试次数大概不相上下，面过的企业包括国内外科技大厂，国内外金融机构，新能源/汽车/传统行业也有涉及。</p>
<p>插播一个地狱笑话：</p>
<blockquote>
<p>我一位在大厂实习过的朋友有一次神神秘秘的说自己和HR聊天得到了一个行业内幕。让ta讲的时候，ta先问了我一个问题：假如你是一个小团队的leader，如果你想了解竞争对手类似部门的组织架构，你会怎么办呢？</p>
<p>我说，我会让HR或者猎头挖竞争对手同类部门的大头兵或是senior程序员的墙脚，面试的时候提问我想要知道的问题。我朋友接着问：可是你们部门没hc怎么办？我说那就在最后一轮或者HR面提高面试难度挂掉对方。我朋友大惊，说你怎么知道HR就是这样说的。</p>
<p>那会我还在秋招中挣扎，我只能苦笑说这都是我被疯狂捞起涮面试KPI养成的直觉。</p>
</blockquote>
<p>今年情况并不乐观，失败是家常便饭，但是失败不意味着结束，每一次面试都能让我更熟悉招聘的套路，也更熟悉我的优势和缺点，让我明确我不能接受怎样的企业风格。只有不怕失败才能不断的去尝试，修正、确认自己的策略。</p>
<h2 id="我稳住求职季心态苟到最后年包翻番的tips："><a href="#我稳住求职季心态苟到最后年包翻番的tips：" class="headerlink" title="我稳住求职季心态苟到最后年包翻番的tips："></a>我稳住求职季心态苟到最后年包翻番的tips：</h2><h3 id="第一目标是不失业"><a href="#第一目标是不失业" class="headerlink" title="第一目标是不失业"></a>第一目标是不失业</h3><p>所以要找个保底，但是保底能不坑就不坑</p>
<ul>
<li>拒掉宁德时代的offer是因为我认为不太符合我的职业路径+开的实在太低+看两方协议以及网上风评感觉太坑不方便以后跳槽+当时秋招刚刚开始，所以拒了</li>
<li>真正保底的offer实际上也是有风险的，但是有符合我职业路径的地方+面试的时候感觉还可以，并且应聘者中似乎没有我的校友，使得我能够延缓签三方的时间没被逼签，继续骑驴找马</li>
<li>决定拒掉还是接一个offer保底应当取决于自己的职业规划，比如地域/赛道/做的工作内容/公司名誉对简历的加持 etc <strong>内心有个明确的原则顺位会更好做决定</strong></li>
</ul>
<h3 id="摆正心态"><a href="#摆正心态" class="headerlink" title="摆正心态"></a>摆正心态</h3><p>如果能接受最坏的结果，那么就能减少情绪内耗，把精力花在做好准备抓住机会上。</p>
<ul>
<li>心情不好就多冥想<strong>专注当下</strong>，或者出门走走，看展、和朋友吐槽</li>
<li>实习的时候我意识到：工作以后一些东西的光环会消失，比如学历、 过去的项目和实习，但是这也意味着限制消失了。社招很难，但是如果有机会还是可以翻身。<strong>市场会冷未来就会热，经济是有周期的</strong>，职业生涯还很漫长，所以没能去到最理想的公司也不是世界末日（我当时是这样安慰自己的）。比如，我在微软实习的时候遇到的一位有一年经验的同事是从小厂跳到外企的。<strong>只要苟着，来日方长</strong>。</li>
</ul>
<h3 id="骑驴找马-持续面试-总结经验"><a href="#骑驴找马-持续面试-总结经验" class="headerlink" title="骑驴找马 持续面试 总结经验"></a>骑驴找马 持续面试 总结经验</h3><ul>
<li><p><strong>每一次面试邀约，哪怕我觉得可能会被当kpi都去尝试了。</strong>所以我很庆幸自己没有因为被反复毒打的怨气和下午起床的起床气而拒绝最后一个面试机会，而是抱着试试也不会损失任何的心态去面试，从而最终取得满意的结果。</p>
</li>
<li><p>反复面试能把人涮成面试老油条，<strong>对面试内心毫无波澜就像吃饭一样自然（什么），我到后期甚至能</strong>准确分辨KPI面试，识破面试官和HR套路从而预测面试结果</p>
<ul>
<li>在三方下发后，不同面试流程之间的互相交叉竞争，如果能够分辨出哪些offer把握大，符合自己心意，那么在回答“是否有其他offer”这个问题的时候，就能最大程度的稳住最想要的offer，打探不太稳定的offer的口风。</li>
</ul>
</li>
<li><p><strong>11，12月会有少量岗位</strong>因为其他候选人（大佬）拒绝而放出岗位，我就是在这个时间点被捞的。一般来说被人拒的岗位可能并不是十全十美符合预期的，但是这也是机会。因此尽管这个时间点很多企业招聘都接近尾声，但是不要放弃。</p>
</li>
</ul>
<h3 id="重视风吹草动"><a href="#重视风吹草动" class="headerlink" title="重视风吹草动"></a>重视风吹草动</h3><p>多看多问多交流，抓住信息差</p>
<ul>
<li>7月中旬，实习同学之间开始流传锁hc的消息，尽管去年的转正有手就行，在听到这样的消息之后我不敢再完全指望转正，于是速速开始海投</li>
<li>10月下旬11月初的时候听说了菊花厂的冷气，于是当这个还在鱼池里的offer不存在，做好了找不到马只能骑驴的准备</li>
<li>同学、学长学姐、论坛都是很好的资源，但是具体可以多结合股价、财报、商业新闻等判断。<ul>
<li>我的暑期实习mentor在吃饭的时候偶然提到了公司的财报不够理想，后来的hc紧张的消息的确和财报紧张吻合了。<strong>互相验证的证据可以帮助决策。</strong></li>
</ul>
</li>
</ul>
<h2 id="Tech面试的108种套路"><a href="#Tech面试的108种套路" class="headerlink" title="Tech面试的108种套路"></a>Tech面试的108种套路</h2><h3 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h3><h4 id="国内大厂"><a href="#国内大厂" class="headerlink" title="国内大厂"></a>国内大厂</h4><ul>
<li>算法题：我没有做很多，leetcode上的记录也就大概200+。因为时间有限我主要反复刷经典题型，目标是短时间内用基本思路解决新的问题并且讲明白思路写出可运行甚至bug-free的代码。一定概率遇到层层递进像思考题一样的拓展算法题</li>
<li>八股文：面多了会发现有些就是会反复问的，以及要对自己简历上的项目足够了解。另外我发现如果对方诚心想要你是有可能会根据你的掌握情况来调整题目难度的（阿里最后两次面试都让我有这种感觉）；而不怎么缺人甚至是缺乏基本面试培训的企业就会卡得很死。我曾经经历过因为没见过一些系统设计的八股，想逐步讨论解法但是面试官不仅不给提示还屡屡打断我的情况；面试中途费老大劲忍住不离场，最后被挂意料之中，我也非常不喜欢该企业（一个做驾驶相关的中厂）的野蛮风格，算是排雷了。</li>
<li>如果面海外岗位大概率需要全英文回答问题，具体可以见<a href="https://august0830.github.io/post/4250e502/">碎片时间学英语-程序员的口语练习</a></li>
</ul>
<h4 id="外企"><a href="#外企" class="headerlink" title="外企"></a>外企</h4><p>我见过的外企面试形式比国内的要灵活一些。</p>
<ul>
<li>转正的时候面我的人主要问了我的实习体验收获自我评价，还问了对部门产品的看法和分析</li>
<li>面试保底公司的时候有英文pre分析技术热点和阅读takeaway代码面试加功能的形式</li>
<li>亚麻和瑞士银行的模拟工作场景的BehavioralQuestion也挺有意思的，有点像在玩扮演角色游戏，但是主要还是考察工作态度</li>
<li>需要准备用英语回答常见的BQ，以及自我介绍</li>
</ul>
<h4 id="银行"><a href="#银行" class="headerlink" title="银行"></a>银行</h4><p>总体上感觉技术内容稍微少一些</p>
<h5 id="外资银行"><a href="#外资银行" class="headerlink" title="外资银行"></a>外资银行</h5><ul>
<li>有很多录英语视频回答BQ、讲解题目的部分</li>
<li>瑞士银行的笔试题还包括读金融材料做选择题</li>
<li>Morgan Stanley终面是车轮战至少3个小时的全英文技术面，但是内容都很基础。在此之前还会有一个电话英文简历面</li>
</ul>
<h5 id="国内银行"><a href="#国内银行" class="headerlink" title="国内银行"></a>国内银行</h5><ul>
<li>看情况，我舍友说她面的基本只问了一些简历上的项目，并且不深入问技术问题。但是我面一个据说风格最接近互联网的银行技术中心基本和大厂面试风格没差别</li>
</ul>
<h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><p>其实我没进过几次，但是能明显感觉到自己是被当kpi了还是对方的确有诚意，我的直觉也与最后结果吻合了。<strong>由于样本大小有限，以下经验仅供参考</strong></p>
<h4 id="有诚意的hr面："><a href="#有诚意的hr面：" class="headerlink" title="有诚意的hr面："></a>有诚意的hr面：</h4><p>简单问了一些过去经历，为什么选这个岗位，之后交流的比较多的是职业规划如何与这个职位匹配，也讲到了我想了解的团队/岗位基本情况，整体氛围都比较像是交流而不是问答。两场面试一场是最后我拿到offer的阿里的HR面（HR效率很高迅速走完了后续流程），一场是面新加坡TikTok iOS开发的时候，Hr面通过但是挂在排序上（估计是因为海外base岗位考虑签证的问题，不过那个岗位做的内容也不是我最想做的，可能被HR看出来了）</p>
<blockquote>
<p>PS：本来TikTok HR给我说我的背景拿到EP没问题，但是最后命运替我做了选择。今年再看新加坡的打分制度，十有八九我是够不上的。还好是被拒了接了阿里的offer。从职业路径来说阿里做的内容也是我更喜欢的。命运弄人哇。</p>
</blockquote>
<h4 id="像KPI的面试："><a href="#像KPI的面试：" class="headerlink" title="像KPI的面试："></a>像KPI的面试：</h4><p>非常模板化，问了很多性格/经历，甚至问了绩点以及为什么没有竞赛、科研。有HR上来就问我认为怎样的作息算是加班，甚至有问我为什么这个时间点（11月中下旬）还在面试<del>（我心想你们不也还在招人凭什么用质问我）</del>。谈到工作节奏和薪资的时候明显感觉双方都有不满意。后来果不其然两个让我不适的HR面都挂了。<del>你不挂我我也会挂你的</del></p>
<h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><p>兜兜转转还是最感谢没有放过每一次机会坚持直到得到想要结果的自己。失败是为更好结果所做的铺垫。毕竟高考结束以后不再有什么机会是一生只有一次的了，所以不能放弃，时间线拉长一些，总能得偿所愿的。</p>
<p>接下来的小目标就是不被裁员了（orz</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Career</tag>
      </tags>
  </entry>
  <entry>
    <title>恢复特定文件到过去版本的解决办法</title>
    <url>/post/ca390c6f/</url>
    <content><![CDATA[<p>事情的起因是提交java作业的时候，因为有一个模板文件被改动而无法merge。于是需要把这个文件还原到最初下载时的样子</p>
<p>首先是查询特定文件的git log记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> ./folder/filename</span><br></pre></td></tr></table></figure>



<p>在windows的git bash中，是无法通过 <code>git reset --hard 版本哈希 filename </code> 来回退的</p>
<p><a href="https://www.jianshu.com/p/caae5b928173">搜索</a>后发现应该用<code>checkout</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 版本<span class="built_in">hash</span> filename</span><br></pre></td></tr></table></figure>

<p>可以避免影响已经完成的作业</p>
<p>但是这样是无法直接push的，因为有文件回退到了过去的版本。<a href="https://stackoverflow.com/questions/30471557/git-push-master-fatal-you-are-not-currently-on-a-branch/30471627">会出现 you are not currently on a branch</a></p>
<p>可以通过 <code>git push origin HEAD:master --force</code> 来强制执行</p>
<p>成功！</p>
<p>Stackoverflow 好用！</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>打开ObeoDesigner出现&#39;Failed to load jvm.dll&#39;问题</title>
    <url>/post/87e0a4be/</url>
    <content><![CDATA[<p>打开ObeoDesigner的时候跳出了一个弹窗，在网上搜索发现解决方案都与Java编辑器Eclipse有关。仔细看发现文件夹下确实有Eclipse，应该是需要Java和Eclipse支持。</p>
<p>参考了<a href="https://www.crifan.com/eclipse_failed_to_load_the_jni_shared_library_jvm_dll/">这篇文章</a>，x86是32位的软件，实际上jvm.dll是存在的，但是版本不匹配，于是重新安装一个64位的版本。并修改了环境变量。修改之后检查了一下vscode的java环境，没有问题。</p>
<p>修改环境变量麻烦的就在于担心其他环境不适配。如果能用服务器或者虚拟机做隔离就更好了。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>新世界大门大开-几款编程相关工具</title>
    <url>/post/c0898a4d/</url>
    <content><![CDATA[<h2 id="plantuml"><a href="#plantuml" class="headerlink" title="plantuml"></a>plantuml</h2><p>一个绘制类图，时序图的在线<a href="https://plantuml.com/zh/starting">网站</a>，支持生成在线的url，无需登录。</p>
<p>和其他工具不太一样的是，输入主要依靠代码描述，和拖拽相比感觉很酷（x</p>
<h2 id="asciinema"><a href="#asciinema" class="headerlink" title="asciinema"></a>asciinema</h2><p><a href="https://asciinema.org/">终端录制工具</a>，可以把终端的动画保存在网站云端，可以获取url插入markdown，但是大小有限制，超过5M左右就无法顺利上传。邮箱可以直接注册登陆。</p>
<p>可以在命令行安装，但是不支持windows，macOS和linux都可以。</p>
<h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>一个图床工具，支持github，gitee，七牛腾讯等等云床，可以内嵌进入markdown。</p>
<h2 id="localtunnel"><a href="#localtunnel" class="headerlink" title="localtunnel"></a>localtunnel</h2><p>在自己本地测试服务器的时候，如果需要外部网络访问被测试的网站和服务器，可以用这个<a href="https://localtunnel.github.io/www/">工具</a>生成网址。</p>
<p>先安装，然后启动工具获得外网网址</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title>暑期实习面经</title>
    <url>/post/155d23b4/</url>
    <content><![CDATA[<h1 id="谷歌"><a href="#谷歌" class="headerlink" title="谷歌"></a>谷歌</h1><h2 id="投递"><a href="#投递" class="headerlink" title="投递"></a>投递</h2><p>同样是偶然在公众号看到。第一次用国内邮箱发送邮件被退回；但改用谷歌邮箱以后依旧没成功，最后请人内推。谷歌是滚动制，投递越早越好，然而正好与考试周冲突，可能投递完了只收到上海base的面试邮件。</p>
<p>面试用的自然语言（中英语）和计算机语言都可以在问卷中自选。</p>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ul>
<li><p>给定开心数的定义：各个位上数字的平方之和计算得到新的数，一直计算下去如果能得到1就是开心数，如果进入循环，即有计算得出的数重复出现，则不是。判断一个数是否是开心数。</p>
</li>
<li><p>追问：（我使用的是Java，并且用哈希表来解决）</p>
<ul>
<li><p>为什么要使用hashset？</p>
</li>
<li><p>hashset插入和查询的复杂度</p>
</li>
<li><p>哈希表底层原理？</p>
</li>
</ul>
</li>
<li><p>（有点答不上来于是换了进阶算法） 给定一个10^6以内的数，返回有多少个小于给定数的开心数？</p>
<ul>
<li>类似NP问题的思路（？） 被提示：有些数字进行一次各个位数字平方和就可以得到1，有些需要两次，即第一次先得到到1只有一步开心数计算的数字，以此倒退。</li>
</ul>
</li>
</ul>
<h1 id="微软提前批"><a href="#微软提前批" class="headerlink" title="微软提前批"></a>微软提前批</h1><h2 id="投递时间"><a href="#投递时间" class="headerlink" title="投递时间"></a>投递时间</h2><p>12月底偶然发现公众号更新了提前批相关信息，苦于当时在考试，在跨年夜当天晚上投递了，在1月3号投递ddl当天收到了意向征集的表格。</p>
<h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h2><ul>
<li>中英文自我介绍<ul>
<li>中文介绍结束后，英文自我介绍的时候被提醒介绍些简历之外的信息，于是回答了为什么想要来投递，被追问了原因。（对自己说的每一句话都要有圆回来的能力）</li>
</ul>
</li>
<li>项目<ul>
<li>选一个印象深刻的项目介绍。</li>
<li>三个问题：<ul>
<li>what：一个怎样的项目，实现了怎样的效果</li>
<li>why：为什么要做这个项目</li>
<li>how：如何实现的，有什么印象深刻的问题，是如何解决的</li>
</ul>
</li>
</ul>
</li>
<li>算法<ul>
<li>给定一个整数数组，要求把奇数放在数组左侧，0在中间，非0整数放在右侧</li>
</ul>
</li>
<li>反问：介绍苏州组的业务?</li>
</ul>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ul>
<li>项目<ul>
<li>java项目中的多机联网是怎样做的？服务器和客户端是怎样交互的？</li>
<li>突然有一方掉线了如何处理？如何确认对方依旧在线？</li>
</ul>
</li>
<li>算法<ul>
<li>有无限枚面值分别为1，2，4，8的硬币，给定一个数值给出有多少种兑换方式（提示：利用bfs/dfs思考，对每种面值，确定该兑换方法下兑换多少枚）</li>
</ul>
</li>
<li>反问&amp;其他<ul>
<li>面试官问：对自己的未来如何打算的？（因为简历上的方向和目前实习的方向不完全一致）</li>
<li>反问：如何找到自己的方向？提升的通用方法？</li>
</ul>
</li>
</ul>
<h2 id="终面"><a href="#终面" class="headerlink" title="终面"></a>终面</h2><ul>
<li><p>项目</p>
<ul>
<li>模拟计算机的项目是独立完成的吗？任务量大概多大？（面试官恰巧是校友）</li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li>给定一个有随机指针的链表，已知随机指针可能为空或者指向任意一个不是本节点的链表上的节点，对该链表进行深拷贝。（时间允许的情况下完整写完代码并进行了测试）</li>
</ul>
</li>
<li><p>反问</p>
<ul>
<li>实习生的培养方式？上班时间和节奏？</li>
</ul>
</li>
</ul>
<h1 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h1><p>固定节目是：自我介绍，问项目，算法题；保留节目是反问。</p>
<p>自我介绍可以复述简历上的技能，但是也有面试官严格一些会追问。我选择介绍投递该岗位的理由。（因为剖析自己性格优缺点我实在是说不出口，尽管论坛里很推荐）</p>
<p>项目需要记住自己做了什么，怎样做的，最终效果。最好多想想有什么优化的地方，并且对用到的技术思路有所了解，面试前可以把认真写的实验报告拿出来复习。（微软二面危在此处的血泪教训）</p>
<p>算法题，体感谷歌问的题目有点智力题的感觉，不是太依赖技巧，而且需要知其所以然，所谓”基础扎实”。做完热题100/剑指offer合集会有个大概认知，遇到新题不能说见过但是会有一些基础分析思路。</p>
<p>反问是一个很好的了解公司的环节。如果感觉不好一般问如何提升（显示我知道自己菜虚心学习），太尴尬了就不问；感觉还可以就会问工作内容/工作节奏/培养方案。</p>
<p>两家外企的面试节奏都比较慢，投递邮件4-7天后得到面试通知（春节前），面试结束后，如果有接下来的面试，微软是2-3天得知结果并且收到下一轮面试邮件；最终结果都是在大概5-7天后邮件发送。</p>
<h1 id="一些马后炮"><a href="#一些马后炮" class="headerlink" title="一些马后炮"></a>一些马后炮</h1><p>最开始想着主攻外企，于是只投了这两家知名外企。但是等待中发现这样做太过冒险，国内大厂的暑期实习面试启动时间基本在年后，年后开学再准备投递其他家时间就太紧了，应该至少再海投几家外企。还好最后被微软捞了，不然任务栈会直接爆炸。</p>
<p>准备期间也不是100%精力投入，依旧有遗漏的地方，所以遗憾被谷歌拒了。面试无论是八股还是算法知识点都不少，做成知识地图或许能更好的查漏补缺。</p>
<p>其实很难有完全准备好的时候，不同的时间总是有事要忙。因此每次快要开始前和等待结果的时候都最紧张，但是一旦开始，或者已经不能改变结果只能等待的时候，就投入手头的事情就好了。海投也很锻炼心态。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>更换设备后追踪仓库更新</title>
    <url>/post/3a3e4295/</url>
    <content><![CDATA[<p>原本是在windows上git clone的github仓库，在原仓库有一次较大改动（发布新作业）之后，因为环境问题需要换到linux虚拟机上做，于是需要把仓库也clone到虚拟机上，但是直接git clone我fork过后的仓库只能下载提交后原仓库更新前的代码，需要更新。</p>
<p>首先检查upstream是否有对应的远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>如果只有两行origin，说明新设备上的仓库还没有与原本的仓库挂钩，需要添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add remote-original.git</span><br></pre></td></tr></table></figure>

<p>之后再次检查upstream，出现upstream两行就可以了</p>
<p>记得根据upstream的提示切换分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout upstream/main</span><br></pre></td></tr></table></figure>

<p>否则就会依旧停留在旧的版本（在这里卡了很久以为弄错了）</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>碎片时间学英语-程序员的口语练习</title>
    <url>/post/4250e502/</url>
    <content><![CDATA[<h2 id="我经历过的英语面试"><a href="#我经历过的英语面试" class="headerlink" title="我经历过的英语面试"></a>我经历过的英语面试</h2><table>
<thead>
<tr>
<th>面试</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>微软暑期实习二面</td>
<td>英文自我介绍 回答了面试官的追问</td>
</tr>
<tr>
<td>Morgan Stanley 电话简历面</td>
<td>简单Java八股，通过本场面试</td>
</tr>
<tr>
<td>Morgan Stanley 3轮技术面试</td>
<td>算法题+技术问题 磕磕绊绊解释思路</td>
</tr>
<tr>
<td>TikTok Singapore 技术面+HR面</td>
<td>3场技术面中有一半时间用英文介绍项目，解算法题，回答追问，进行反问；HR面全程用英语回答问题表达诉求</td>
</tr>
</tbody></table>
<p>以上所有面试并除了Morgan Stanley因为技术问题没回答好挂了之外其他都通过了面试本身。英文的技术面试重点依旧是技术，但是经过我的练习，我至少可以做到尽可能减少表达不流畅带来的负面影响。</p>
<p>我训练的主要目标是提升表达的流畅度，对口语的口音没有太多要求。</p>
<h2 id="碎片时间利用的方法"><a href="#碎片时间利用的方法" class="headerlink" title="碎片时间利用的方法"></a>碎片时间利用的方法</h2><h3 id="英语刷算法题"><a href="#英语刷算法题" class="headerlink" title="英语刷算法题"></a>英语刷算法题</h3><p>英文面试中手撕算法题的关键依旧是讲清楚算法题，只不过多了一个附加条件——用英语。我在原来写自己的题解、梳理思路的基础上只是替换了语言。先保证自己能用中文清晰的写出算法题思路和需要注意的要点。</p>
<p><strong>做英语算法题，看英语题解，用英文关键词搜索</strong> 尽可能营造沉浸式环境，同时减少对英语的陌生感和恐惧感，避免看到英语算法题就头晕。还可以学习相关术语。</p>
<p><strong>大胆写 不需要在意语法 是Broken English也没关系</strong> 如果一开始觉得直接说很困难可以先写出来，作为缓冲。写的时候可以不在意语法，不一定要是完整的句子，把要点写出来，再考虑连起来。</p>
<p><strong>模仿学习矫正是必须要下的功夫</strong> 参考母语者是如何讲题的可以帮助自己修正讲题的方式。我参考的是<a href="%5BNeetcode%5D(https://neetcode.io/)">NeetCode</a>。他擅长用样例讲解算法，并且用语非常基础，易于模仿。在学习模仿的过程中也可以积累常用的讲解算法题的表达。</p>
<p><strong>“我讲明白了吗”</strong> 可以用 <em>录音回放</em> 来检查。至少自己要听得懂。有条件也可以找朋友结伴，给对方用英语讲题。</p>
<h3 id="面试前简历准备"><a href="#面试前简历准备" class="headerlink" title="面试前简历准备"></a>面试前简历准备</h3><p>和算法题准备类似，首先我要保证用中文能复述出简历上项目的要点，能应对追问。然后在准备过程中找到合适的英文术语来替换成英文。</p>
<p><strong>最好写好稿子背熟。</strong>有条件最好能Mock。因为实际面试中会遇到出乎意料的提问，用英语临场应变是需要训练的。</p>
<p>碎片时间系列：</p>
<p><a href="https://august0830.github.io/post/cda728a4/">碎片时间学英语——日常阅读</a></p>
]]></content>
      <categories>
        <category>Language Learning</category>
      </categories>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>碎片时间学英语——日常阅读</title>
    <url>/post/cda728a4/</url>
    <content><![CDATA[<p><em>原文是我外刊时文共读的作业，但是我认为这门课让我学到的东西可以拓展写一下，于是改写成了这篇文章。关于碎片化学习英语，应该会写一个系列，覆盖近一年来关于听说读写这四个方面我的练习。</em></p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>过去的三年时间里，除了大一还有英语必修课使我能在繁忙的专业课程之余专门留出时间给英语学习，我总是很难在专业课夹击中找到如上大学之前那样集中学习英语的时间，连四六级英语考试都是匆忙上阵的。</p>
<p>系统有意识的学习英语多半是在课堂上：有专门主题的教材，有系统的笔记，有及时的作业和反馈。这并不是说我在平常不会接触、练习、使用英语；但是与课堂相比，总是缺少刻意练习和记录，因此我总是把系统、刻意练习的期待寄托在完整的、可以像课堂一样的时间段，寄希望于教材这样系统的学习材料。但是实际上，这是一种会阻碍我前进的“完美主义”。<strong>学习任何事情都不需要等到一切就绪</strong>。</p>
<h2 id="Learning-in-Pieces"><a href="#Learning-in-Pieces" class="headerlink" title="Learning in Pieces"></a>Learning in Pieces</h2><p>语言原本就是思想的载体，是交流的工具；我所学习、所练习的一切，原本就是为了更好的倾听他人的观点，表达我的想法。因此即便是对不同主题，基于不同体裁看似零散的练习，也总是有相通的地方；而能从多种多样的文章中找到共同的部分——比如国际顶尖媒体写作者都是怎样导入，怎样吸引读者注意，引起读者思考——也同样是一种能力。对于我这样有阅读英语原文——包括新闻和技术文章——的习惯的人来说，实际上每一篇文章都是一次学习的好机会。</p>
<p><strong>饭是一口口吃的，但是每一口吃什么，可以根据此时此地的情况定制。</strong>读什么样的文章，读文章的时候注意什么，都可以通过不同的选择来激发自己的学习兴趣。比如对同一篇文章，可以着重积累词汇，也可以学习作者安排文章结构的方式，或是观察作者如何导入一个主题、事件、专业名词；或者对不同的文章，采取不同的策略。对于略读的文章，可以扫几眼概览架构；对于精读的文章，可以掏出小本本记单词分析句子。总之可以灵活安排，就可以一定程度上减少“等我有时间再做”这样的无效flag。</p>
<p>我时常会有阅读专业相关的英语博客的时候，这种时候除了注意专业知识，我还可以积累一些常用专业术语的表达，并且观察写作者是如何让文章保持简明易懂的。而对于商业、时事新闻，我可以多积累一些常用名词，以及一些通俗搭配，了解一些文化背景知识。</p>
<h2 id="Make-some-Output"><a href="#Make-some-Output" class="headerlink" title="Make some Output"></a>Make some Output</h2><p>上外刊课程的时候，系统整理好的笔记和选择题答题记录是作业的一部分。不过这也倒逼了我输出笔记。输出倒逼输入的好处就不再赘述了，个人觉得还是非常大程度的避免我偷懒or忘记学到的东西了。</p>
<p>意思是这里立Flag，看到有意思的英语会写文章记录一下。</p>
<p>可能会记录生词短语，可能会分析写法结构，也可能会拓展记录一些背景知识。总之开始写了就好了。</p>
<p>碎片时间系列：</p>
<p><a href="https://august0830.github.io/post/4250e502/">碎片时间学英语-程序员的口语练习</a></p>
]]></content>
      <categories>
        <category>Language Learning</category>
      </categories>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>配环境有感</title>
    <url>/post/fbfaa019/</url>
    <content><![CDATA[<p>配环境有感<br>配环境是接触一门新语言/一个新框架的启蒙老师！</p>
<p>连续配了Android开发和php网页段的环境。发现为了跑demo实际上掌握了关于一个新技术大致的运行方式。比如Android需要Java底层的支持和很多在线组建的支持 还有php需要配合服务器而不仅仅是一个网页文件</p>
<p> 在配环境的过程中 经常会出现按照教程走了却没有得到想要的结果的情况 在解决这种不一致的过程中 必须要去了解原因 也因此会学习关于这门语言或者技术框架的运行原理 这样遇到问题才能分析出原因 配环境的这几个小时不算白搭</p>
<p>另外 在没有现成demo教程的情况下 学会问问题而不仅仅是一遍遍机械重复的尝试变得非常关键 比如我在配php环境的时候一直跑不出更加复杂的他人的项目demo 搜索了如何在浏览器显示php才发现是我想的太简单了 同时也意识到这一套体系是用来模拟网站而不仅仅是网页运行的 解决这一点之后demo丝滑运行了</p>
<p>不过必要的时候还是要寻求帮助 不过要在尝试所以能尝试的 能提问搜索的之后 </p>
<p>还有不得不说 Google永远的神 拥有谷歌的人解决问题的概率比没有的人高了不知多少 stackoverfkow也是好东西 看多了加上逼不得已 英文就不再成为阻碍了 而且也能锻炼快速抓重点的能力</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title>DP IS EASY —— 如何切入动态规划问题</title>
    <url>/post/70b45bc3/</url>
    <content><![CDATA[<blockquote>
<p>是对<a href="https://leetcode.com/problems/target-sum/solutions/455024/DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions">DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions</a>的翻译记录，原题是 <a href="https://leetcode.cn/problems/target-sum/solution/DP-IS-EASY/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china">Target Sum（目标和）</a></p>
</blockquote>
<h2 id="DP很容易！5步思考DP问题"><a href="#DP很容易！5步思考DP问题" class="headerlink" title="DP很容易！5步思考DP问题"></a>DP很容易！5步思考DP问题</h2><p><strong>注意</strong>：这不是一个规范化、完美优化的DP解决方案。我们已经有足够多这样的东西了。这篇文章将带领你了解动态规划背后的思考过程，让你能够自己解决这些问题。</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>大多数动态规划问题可以归结为几个类别。识别类别很重要，因为它允许我们将一个新问题转化成我们已知的问题。转化意味着使用框架，而不是将另一个问题的解决方法复制到当前问题中。你必须明白每个DP问题都是不同的。</p>
<p><strong>问题</strong>：在继续之前将此问题标识为以下类别之一。</p>
<ul>
<li>0/1背包</li>
<li>无界背包</li>
<li>最短路径（例如：独特的路径I/II）</li>
<li>斐波那契数列（例如：房子小偷，跳跃游戏）</li>
<li>最长公共子串/子序列</li>
</ul>
<p><strong>答案</strong>：0/1背包</p>
<p>为什么是0/1背包？我们的“容量”是我们想达到的目标“S”。我们的“物品”是输入子集中的数字，物品的“重量”是数字本身的值。这个问题遵循0/1背包而不是无界背包，因为我们只能使用每个数字一次。</p>
<p>变化是什么？这个问题与标准背包问题的变化在于，我们必须将子集中的所有物品添加到我们的背包中。我们可以将问题重新构成为将当前数字的正值或负值添加到我们的背包中，以达到目标容量“S”。</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>我们需要跟踪哪些变量才能达到最佳结果？这篇Quora文章很好地解释了状态，请参考这个链接（如果你感到困惑）：**<a href="http://www.quora.com/What-does-a-state-represent-in-terms-of-Dynamic-Programming">www.quora.com/What-does-a-state-represent-in-terms-of-Dynamic-Programming</a>**</p>
<p><strong>问题</strong>：确定状态变量。</p>
<p><em>提示</em>：作为一般规则，背包问题至少需要2个状态。</p>
<p><strong>答案</strong>：索引与当前总和</p>
<p><em>为什么是索引？</em></p>
<p>索引代表我们正在考虑的输入子集的索引。这告诉我们哪些值我们已经考虑过，哪些值我们还没有考虑过，以及我们当前正在考虑的值。一般规则是，在几乎所有的动态规划问题中都需要索引状态，除了最短路径，它的状态是行和列而不是单个索引，但我们会在另一篇文章中介绍这个问题。</p>
<p><em>为什么是当前总和？</em></p>
<p>这个问题是问我们是否可以对子集中的每个数（该数的正值或负值）求和以达到目标值。 Current Sum 为我们提供了迄今为止我们已处理的所有值的总和。 我们的答案围绕着 Current Sum 等于 Target。</p>
<h3 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h3><p>动态规划就是做出最佳决策。 为了做出最佳决策，我们必须首先尝试所有决策。 MIT 关于动态规划的课程讲义（The MIT lecture on DP）（强烈推荐）将此称为猜测步骤。 我的大脑更擅长将此称为决策而不是猜测。 决策必须使我们更接近基本情况（Base Case），并引导我们找到我们想要回答的问题。 基本情况在第 4 步中涵盖，但实际上与决策步骤协同工作。</p>
<p><strong>问题</strong>：在每次递归调用时我们必须做出什么决定？ <em>提示</em>：一般来说，背包问题需要 2 个决定。</p>
<p><strong>答案</strong>：这个问题要求我们在输入子集中获取所有数，因此在每一步中我们都会向背包中添加一个数。 请记住，我们在第 2 步中声明“该问题询问我们是否可以对子集中的每个数（该数的正值或负值）求和以达到目标值。” 决策包括：</p>
<ul>
<li>我们应该添加当前数字的正值吗</li>
<li>我们应该添加当前数字负值吗</li>
</ul>
<p>请注意，背包问题通常不需要我们拿走所有物品，因此通常的背包决定是拿走物品或留下物品</p>
<h3 id="基本情况（Base-Case）"><a href="#基本情况（Base-Case）" class="headerlink" title="基本情况（Base Case）"></a>基本情况（Base Case）</h3><p>基本情况需要与我们正在寻求的答案所需的条件直接相关。 这就是为什么我们的决策朝着我们的基本情况努力很重要，因为这意味着我们的决策正在朝着我们的答案努力。</p>
<p>让我们重新审视我们的答案的条件：</p>
<ul>
<li>我们使用输入子集中的所有数字。</li>
<li>所有数字的总和等于我们的目标“S”。</li>
</ul>
<p><strong>问题</strong>：确定基本案例。 <em>提示</em>：有 2 个基本案例。</p>
<p><strong>答案</strong>：我们需要 2 个基本案例。 一种用于当前状态有效时，一种用于当前状态无效时。</p>
<ul>
<li>有效：索引超出范围且当前总和等于目标“S”</li>
<li>无效：索引越界</li>
</ul>
<p><em>为什么索引越界？</em> </p>
<p>我们答案的一个条件是我们使用输入子集中的每个项目。 当索引超出范围时，我们知道我们已经考虑了输入子集中的每个项目。</p>
<p><em>为什么当前总和等于目标？</em> </p>
<p>我们的答案的一个条件是在我们的输入子集中使用的数的正值或负值的总和等于目标总和“S”。</p>
<p>如果我们已经考虑了输入子集中的所有数并且我们当前的总和等于我们的目标，那么我们已经成功地满足了我们答案要求的两个条件。</p>
<p>另一方面，如果我们已经考虑了输入子集中的所有数，并且我们当前的总和不等于我们的目标，那么我们只满足了答案所要求的条件之一。说明无最终答案。</p>
<h3 id="写代码吧"><a href="#写代码吧" class="headerlink" title="写代码吧"></a>写代码吧</h3><p>如果您已经考虑了所有步骤并理解了问题，那么编写实际解决方案的代码就很简单了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums, S</span>):</span></span><br><span class="line">     index = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">     curr_sum = <span class="number">0</span></span><br><span class="line">     <span class="keyword">return</span> self.dp(nums, S, index, curr_sum)</span><br><span class="line">     </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">self, nums, target, index, curr_sum</span>):</span></span><br><span class="line"> 	<span class="comment"># Base Cases</span></span><br><span class="line">     <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">and</span> curr_sum == target:</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">     <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">     </span><br><span class="line"> 	<span class="comment"># Decisions 决策</span></span><br><span class="line">     positive = self.dp(nums, target, index-<span class="number">1</span>, curr_sum + nums[index])</span><br><span class="line">     negative = self.dp(nums, target, index-<span class="number">1</span>, curr_sum + -nums[index])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> positive + negative</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>一旦我们引入记忆化（memoization），我们将只解决每个子问题一次。 我们可以完全删除递归，并通过引入制表来避免开销和堆栈溢出的可能性。 重要的是要注意自上而下的递归和自下而上的制表方法执行完全相同的工作量。 唯一不同的是内存。 如果他们执行完全相同的工作量，转换只需要我们指定解决问题的顺序。 这篇文章现在真的很长，所以我不会在这里介绍这些步骤，可能会在以后的文章中介绍。</p>
<p>使用记忆化的方案供参考</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums, S</span>):</span></span><br><span class="line">        index = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        curr_sum = <span class="number">0</span></span><br><span class="line">        self.memo = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> self.dp(nums, S, index, curr_sum)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">self, nums, target, index, curr_sum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (index, curr_sum) <span class="keyword">in</span> self.memo:</span><br><span class="line">            <span class="keyword">return</span> self.memo[(index, curr_sum)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">and</span> curr_sum == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        </span><br><span class="line">        positive = self.dp(nums, target, index-<span class="number">1</span>, curr_sum + nums[index])</span><br><span class="line">        negative = self.dp(nums, target, index-<span class="number">1</span>, curr_sum + -nums[index])</span><br><span class="line">        </span><br><span class="line">        self.memo[(index, curr_sum)] = positive + negative</span><br><span class="line">        <span class="keyword">return</span> self.memo[(index, curr_sum)]</span><br></pre></td></tr></table></figure>

<p>对您希望此类帖子在下一篇文章中遇到的 DP 问题发表评论，如果您觉得有帮助，请为该解决方案点赞。 我想把它推到首位，因为我真的厌倦了看到直接优化的表格解决方案，背后没有任何思考过程。</p>
<p>DP IS EASY!</p>
<p>谢谢。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Algo</tag>
      </tags>
  </entry>
  <entry>
    <title>实习就业分享</title>
    <url>/post/af204ca1/</url>
    <content><![CDATA[<blockquote>
<p>之前分享时间有限，文字稿整理了更多内容</p>
</blockquote>
<h1 id="我的背景"><a href="#我的背景" class="headerlink" title="我的背景"></a>我的背景</h1><ul>
<li>无亮眼绩点——40%上下浮动</li>
<li>无竞赛——美赛只有一个水奖，没有ACM、花旗杯、大创</li>
<li>进组经历——无 第一次接触科研是在毕设期间</li>
</ul>
<p>如果把找实习找工作比做牌桌，我猜我的开局应该和大部分人都是比较相似的，希望大家到最后不会觉得“我做不到”，而是“听起来我也行”。</p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>找实习和秋招春招的思路大致都是相似的。市场行情、你的期望等等因素都会有变化，所以对我来说授人以鱼不如授人以渔，对在座的各位来说，具有可成长的思维比照搬经验更重要。</p>
<p>具有如下心态会对你的找工之旅有些帮助：</p>
<ul>
<li>忌刻舟求剑。和往年人对比是不现实的，因为这两年情况变化很快，和身边人对比也不是一个好主意，因为你们偏好的职业路径、面对的机会与挑战不尽相同。把别人当成参照物会徒增自我怀疑。如果羡慕别人的offer的话，把别人当成可以对齐模仿的案例才是成长性的思维。</li>
<li>不要把面试结果当成是一种评判（Judgement），而应该是一种反馈（Feedback）面试是否能通过取决于很多因素，比如面试的部门是否急需人，你们气场是否相合。评判可能是一种噪音，但是反馈是应当是有利于你调整的信号。每一次面试都可以学到东西，不管是面试技巧上的、技术上的还是对行业的理解上。</li>
<li>抓住每一次机会，不要等到做好准备。很多时候大家可能会觉得自己没准备好或者不足以去投一些看起来很高大上的大厂。但是不投怎么知道自己没机会呢？而且投简历和面试是一件投入极小但是回报极大的事情，大不了当别人免费给你做面试训练。看到内推就大胆去问、看到岗位招聘就尝试去投，来了面试就面。适应面试套路需要时间，尝试的越多，在机会来临的时候就越有机会抓住。 </li>
<li>资源是有限的，需要权衡取舍。很多公司只允许你投递有限数量的岗位，或者是有优先级顺序；你自己的时间精力也是有限的。勇气不等于莽撞，在争取之前，需要确认自己是否真的愿意为此下注。这需要你了解你面对的机会能打开怎样的大门，以及你自己想要什么。</li>
</ul>
<h1 id="写简历-投递"><a href="#写简历-投递" class="headerlink" title="写简历+投递"></a>写简历+投递</h1><p>写简历是了解自己的过程，投递是了解市场行情的过程。</p>
<p><em>插播广告一条：<a href="https://august0830.github.io/post/cbfb1047/">从零开始写简历</a></em></p>
<p>写简历的时候，可以回想你在做什么项目的时候会觉得有意思，对什么框架比较熟悉。这种熟悉是相对的，不用觉得自己什么都不熟，毕竟是本科生，不需要对自己有太大压力。如果没有特别喜欢的怎么办？没关系，找你不讨厌的，反过来想就会有很多选择了。</p>
<p>投递的时候可以很直观的在招聘软件上看到什么样的岗位需求量大，以及这些岗位需求都来自于哪些企业。JD上一般会提到一些技术框架，实话实说不需要完全满足，有几条符合就可以去投递了——不试白不试。试的前提是你确认自己不要对这个领域完全不懂也不感兴趣。可以搜寻一下相关技术框架的科普文章和面经，看看是否符合自己的兴趣。或是至少不讨厌，不会看着就完全失去了解的欲望。</p>
<p>广泛投递的同时最好善用excel、notion等工具管理进度。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>关于不同公司的面试风格，有总结。总体上都包括三个方面：算法题，基础知识（八股文），Behavior Question</p>
<p>Behavior Question：可以理解为是软实力，问题五花八门，不只是外企才有（相对来说外企更重视这些）。我被问过的问题就包括为什么投递我们公司、你面对挫折/团队冲突/难题的态度，你认为自己的优点和缺点。但是宗旨无非就是你是一个怎样的人，与你面试的公司/部门/组是否气场相合。</p>
<p><em>再次插播一条广告：更多内容请移步<a href="https://august0830.github.io/post/d5aef8f3/">秋招实录</a></em></p>
<p>应对思路：以不变应万变，经典思路+你的想法与个人风格。</p>
<p>算法题为例：刷多少题不是关键，重要的是你掌握了多少种经典问题作为工具箱来帮助你切入新的问题</p>
<p>基础知识为例：经常会问拓展问题，你之前没想到也不要沉默，重点是如何向经典框架或者实现靠近来解决，给面试官展现你解决的思路。毕竟遇到新问题是工作中经常出现的场景。</p>
<p>举例：我的<a href="https://august0830.github.io/post/155d23b4/">微软实习二面</a></p>
<ul>
<li>Java项目中的多机联网是怎样做的？服务器和客户端是怎样交互的？</li>
<li>突然有一方掉线了如何处理？如何确认对方依旧在线？</li>
</ul>
<p>我说实话之前没想过，但是想了下操作系统里确认任务是否完成，是在一种你不知道什么时候结束的状态下，经典的思路是使用轮询，“久不久探测”，面试官说我回答的接近了，提示我可以之后去查心跳机制。</p>
<p>BQ为例：树立好你的工作人设，基于人设出发回答问题。为什么强调是工作人设？因为你需要展现出你能够成为这个部门/团队的助力。</p>
<p>举例，阿里HR面问我缺点，我说：内向不爱问问题，喜欢自己先钻研，但是我回答的重心是强调我知道这会影响工作效率，我做出的平衡是先自己尝试搞清楚问题上下文，整理好我目前对问题的认识和尝试过的办法，然后自己折腾超过一定时间立马求助，保证自己能有效的提供信息帮助解决问题。比起强调个人视角的感受，我会同时强调这在工作上可能带来的影响。</p>
<h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>做选择是一个加权平均数，每个人给自己人生赋予的权重不一样，经验分享能让大家看到的其实主要是“包括哪些项”，而不是告诉你应该选什么。</p>
<p>写简历和投递的时候收集的信息在此刻非常重要。不管是决定接不接，接哪家，都需要你判断现在有的选项是否符合你的预期，外界现实和内在预期是否匹配，再做出选择或者去争取。</p>
<p>微软实习小故事： 发邮件问分配到的组里的工作内容 → 不是我想做的方向，是上一段实习的偏客户端的方向，询问是否能换内容 → 被告知如果要换内容，需要换组 → 坚持要换，换到了我后来实习的组 → 给老板留下了深刻印象并且老板指派了我感兴趣的相关内容。</p>
<p>常见的影响因素：岗位工作内容，业务部门，公司title，城市，潜在转正的可能，工作节奏。</p>
<p>反问环节可以询问一些在jd和论坛上看不到的内容。我问过的问题：<strong>请面试官描述一下工作的一天</strong>。</p>
<p>会有面试官问我是不是想问加班情况，我一般不会否认，但是我会说我还想知道更多关于工作体验的细节。可以有个大概感受。除了是否加班这样的工作节奏，还有比如开会、写周报的频率、和其他部门对接的方式。如果是基建部门和业务部面对接的时间会很多，业务部门有时候会有一些不依赖其他业务部门的需求。</p>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>祝大家都能得偿所愿，即便遇到不顺也最终只是或早或晚的区别。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Career</tag>
      </tags>
  </entry>
  <entry>
    <title>毕设实录</title>
    <url>/post/7d3f17d0/</url>
    <content><![CDATA[<h2 id="关于选题"><a href="#关于选题" class="headerlink" title="关于选题"></a>关于选题</h2><p>事实上在做毕设之前我从来没有接触过机器学习相关的科研或者项目，实习做的也不是这个方向。是在和导师沟通的过程中，觉得这个题目有点意思，加上之前没怎么做过研究，于是脑子一热答应选了这个如导师所言”有挑战性”的选题。</p>
<p>虽然做的过程中经常要死要活，也一度非常迷茫自己到底能不能做完，但是因为最开始的确是对选题感兴趣，所以倒也有不少苦中作乐或者惊觉“Eureka”的时刻。毕竟本科生比较少会在毕设上被为难，所以抱着“只要认真做了一定能过”的心态，去做些自己感兴趣的尝试，也不枉费投入的时间与精力。</p>
<h2 id="从零开始快速恶补机器学习——面向毕设学习机器学习"><a href="#从零开始快速恶补机器学习——面向毕设学习机器学习" class="headerlink" title="从零开始快速恶补机器学习——面向毕设学习机器学习"></a>从零开始快速恶补机器学习——面向毕设学习机器学习</h2><ul>
<li><p>系统性的阅读：找一本教材。能动手跟着做练习最好，如果时间有限，其实重点熟悉与自己的毕设有关的方面就够了，其他的反正一时半会用不上，用到了再说。</p>
</li>
<li><p>论坛：（eg：Reddit，Stackoverflow）找更亲民、短平快、面向具体毕设主题的材料。</p>
</li>
<li><p>Chatgpt：学习一些基本的概念，或者是复习。注意：GPT只能说人话，不能保证正确，留个心眼，在实践中验证。对于基础知识，大概率材料已经在它的训练数据里，所以拿不准的时候还是会问它。</p>
</li>
</ul>
<p>因为我的毕设本质做的是优化问题，所以针对毕设问题来学习对我来说就是：关注性能优化，可以少看公式，多关注性能衡量指标的原理，具体方法的原理先放一放。</p>
<h2 id="阅读文献"><a href="#阅读文献" class="headerlink" title="阅读文献"></a>阅读文献</h2><ul>
<li>Zetero：读文献的时候划重点，做批注，对文献类型分类，导出引用都很方便。</li>
<li><a href="https://www.chatpdf.com/">ChatPDF - Chat with any PDF!</a>：在读文献初期，对所做领域所知甚少的时候，通过交互式的提问可以更快了解一篇论文是否对自己的毕设有帮助。</li>
<li>学会读摘要：<ul>
<li>背景是什么：与你的毕设题目是否相关</li>
<li>过去的研究局限是什么：补充关于现有研究的知识，可能会启发思路</li>
<li>该论文提出的解决方案是什么：对你的主题是否有启发</li>
</ul>
</li>
</ul>
<p>对我来说：因为我的毕设本质是一个已有方案的优化问题，所以读文献花了很长时间。原因是需要了解：我的问题场景下已经有什么优化方法、是否有效、是否适用于已有方案。</p>
<h2 id="做实验"><a href="#做实验" class="headerlink" title="做实验"></a>做实验</h2><p>从配环境开始到复现代码再到改自己的方案，可以说每一步都是血汗泪，比如我就是一个配环境赔了一个星期的冤种。因为旧方案当中的很多依赖包已经被更新了，导致安装的环境兼容问题很多。算是写代码过程中的必经之路吧。记录了一些心路历程和经验教训如下：</p>
<ul>
<li>配环境的时候发现问题越来越复杂，遂重开，仔细想想很多事情都符合这样的道路</li>
<li>脚本跑不动——先检查单行命令</li>
<li>等实验完成的时候可以整理下笔记思路。如果是在debug的过程中，可以搜索问题其他可能解法，假如当前措施失败了还有得替换。</li>
<li>心流是好事。但是面对问题需要经常跳出思路，偶尔起来走一走，吃吃水果泡泡茶，有助于打开思路</li>
<li>面对新领域出现的报错 建议是先用chatgpt等解读报错信息 大概了解问题的上下文 当chatgpt提供的信息越来越模糊的时候 可以及时切换到搜索引擎去看更具体的个人经验 有了前面的铺垫不至于看不懂 又能得到更有针对性的信息</li>
<li>看到报错不要慌 先认真看上层调用 看上下文 推断可能出现的问题 再打断点或者是加输出来显示程序的状态 在运行程序是需要一定代价（例如时间）的情况下，审慎的推断比无头苍蝇式的重启更有效 磨刀不误砍柴工</li>
<li>改动框架的时候会出现一些意料之外的错误，这个时候需要找到报错点和上下文，打出想要的信息。如果有可以参照的调用，把参照的调用信息也打印出来，对比着看程序状态是哪里不一致导致了问题</li>
<li>实验需要时间 在这个过程中可以头脑风暴 切换思路 或者记录当前的进度 切换线程比切换进程容易 最好还是做相关的事情</li>
<li>梳理好框架 调用模块之间的关系 再写代码事半功倍</li>
<li>没有报错的bug，可以通过是否有输出来判断是否有问题——被迫使用了二分法debug，最后发现是运行时间过长的问题。</li>
</ul>
<p>做实验是一个不断失败、调整、再试验的循环，尤其是对于一个优化问题来说，光做出一个方案是不够的，目标是做出一个“更好”的方案。在这个过程中，不断碰壁也是值得记录的，因为排除了种种不可行不够好的方案，才能得到最后的方案，而这些都可以作为论文的写作素材。</p>
<h2 id="写论文"><a href="#写论文" class="headerlink" title="写论文"></a>写论文</h2><p>我，是一个五月初还在改代码但是在最终方案确定后在两天写了近一万字的苦命毕设人。能在短时间内爆肝一万字，靠的是过去几个月时间里的积累，一个迫在眉睫的ddl（因为我要在去看演唱会之前写完初稿），和一丢丢写作小技巧。</p>
<p><strong>写论文时不同的任务优先级：</strong></p>
<ul>
<li>决定好要写什么：列要点，整合材料</li>
<li>根据要点组织内容与遣词造句，画图</li>
<li>审阅修改，美化图像</li>
<li>调公式版型，加引用</li>
</ul>
<p>人不可能一直都精力旺盛，所以在精力水平高的情况，我会优先做比较费脑子的任务；在感到疲惫的时候就调一调格式，画一画图，放松的同时梳理了思路。</p>
<p>如果觉得下笔很难，不需要强求自己写一个完整的、通顺的句子，可以先列大纲，列出你想要写的关键词、关键句，甚至只是把你脑海中的想法、你做实验过程中遇到的问题写下来，都是一个很好的开始。和创作差不多，在有东西可写（例如你已经阅读了大量论文，做了笔记，或者在做实验的时候吃了很多苦头，积累了很多失败经验）的情况下，不要因为觉得自己脑海里的东西很模糊很混乱就拖延：重点是先把脑子里的想法写出来。有了初步的素材，再进行整理与优化会方便很多。</p>
<p><strong>如何很高明地水字数：</strong></p>
<ul>
<li>最后没用上的前人工作也可以利用起来：<ul>
<li>和背景有什么关系，</li>
<li>为什么没用上，</li>
<li>如何启发了你寻找现在的新思路</li>
</ul>
</li>
<li>用上的前人工作：<ul>
<li>做了什么，</li>
<li>有什么不足，</li>
<li>和你的工作有什么关系，前人工作提出了什么问题</li>
</ul>
</li>
<li>a → c 可以扩写成a到b，b到c：<ul>
<li>梳理思路的同时，确认逻辑链</li>
<li>向阅读者解释前因后果，在自己的领域做多了会忘记一些结论对于初次看论文的人来说并不显然</li>
</ul>
</li>
<li>逻辑连词的使用：<ul>
<li>‘即’字的使用：换一种说法，比如把一个抽象的概念转换为具体的、可观测的指标</li>
</ul>
</li>
</ul>
<h2 id="答辩"><a href="#答辩" class="headerlink" title="答辩"></a>答辩</h2><p>我是如何在看演唱会期间做的答辩准备，使得我在6min内讲完ppt并且流畅地回答了答辩组老师提出的问题？</p>
<p>其实大头功夫在平时付出的时间精力，以及对所作内容的记录与梳理。只要是自己认真做的毕设，对自己毕设的来龙去脉足够了解是不成问题的。我在网上大概搜索了一些答辩经验，花了20min根据自己的论文结构列了大纲。做ppt的时候从论文里搬运了一部分代码架构示意图充实内容。</p>
<p>如果答辩有时间限制，初步做好ppt以后掐表试讲再修改，心里会更有底。</p>
<p>最后，毕设完结撒花！谨以此文做一个小小的总结回顾。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
</search>
