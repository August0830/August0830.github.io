<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021秋开学前鸡汤</title>
    <url>/post/d050af8b/</url>
    <content><![CDATA[<p>开学前在西西弗随手翻了两本书，因此做一个读书笔记与反思调整。</p>
<h2 id="如何成为一个会学习的人"><a href="#如何成为一个会学习的人" class="headerlink" title="如何成为一个会学习的人"></a>如何成为一个会学习的人</h2><p>从学习当中发现乐趣</p>
<blockquote>
<p>比如说做GRE阅读题的时候发现自己能够准确梳理文章逻辑，享受抽丝剥茧的乐趣</p>
</blockquote>
<p>设置简单的反馈目标</p>
<blockquote>
<p>不仅是肯定自己完成了某件事，还应当肯定自己从中学到了什么</p>
</blockquote>
<p>遇到困难先做一点点</p>
<blockquote>
<p>比如说不想看书的时候先尝试看5页 或者遇到代码题先考虑分析一下思路再看解析</p>
</blockquote>
<p>重点是投入</p>
<blockquote>
<p>及时隔离包括手机在内的各种干扰源，如果有玩耍的念头 想想无数个恨铁不成钢的时刻，以及投入之后心流的愉悦</p>
</blockquote>
<p>可以对目标先妥协 只要坚持下去</p>
<blockquote>
<p>并不是每次都能准确的预估目标，及时改进比懊恼更有用</p>
</blockquote>
<p>回顾</p>
<ul>
<li>每1 2页回顾一次</li>
<li>每个项目回顾一次每章回顾一次</li>
</ul>
<blockquote>
<p>看书的时候回顾之后要及时回到书本本身 不然容易半途而废</p>
<p>在学习过程中可以利用周末的时间做简单的梳理，上课觉得讲的慢或者不想听的时候也可以利用康奈尔笔记</p>
</blockquote>
<p>散步</p>
<ul>
<li>活动一下 走新的路 </li>
<li>不要路上玩手机 </li>
<li>走20min以上</li>
</ul>
<p>听音乐进入状态 进入状态就可以关掉了</p>
<blockquote>
<p>歪打正着的在上个学期期末非常懒惰不想复习的情况下使用了这个方法 不过注意保护耳朵</p>
</blockquote>
<p>自问自答 可以用录音的方式强化</p>
<blockquote>
<p>比如一些面试问答题 以及背单词</p>
</blockquote>
<p>睡前复习 一页A4纸记录 </p>
<ul>
<li>具体问题或者索引 </li>
<li>可以强化不懂的东西 当然也可以放到第二天再解决</li>
</ul>
<blockquote>
<p>可以作为睡前放松的一种方式 也可以用来避免第二天早上难以进入状态 毕竟还有事情需要解决</p>
</blockquote>
<p>在有成果的时候播放音效激励自己<br>边走路边背书<br>速读 母语+外语</p>
<blockquote>
<p>这个方法应该可以大大提高阅读课外书的速度 虽然目前速度会出现读漏信息的情况，但是也可以帮助我有意识的锻炼按照自己的思维重组内容的能力</p>
</blockquote>
<p>细化学习成果的记录。</p>
<blockquote>
<p>不仅是做了什么 还有学到了什么</p>
</blockquote>
<p>保持专注的三个要求</p>
<ul>
<li>可以控制</li>
<li> 快速反馈 </li>
<li>保持平衡：目标与能力之间的匹配度</li>
</ul>
<p>想办法享受学习</p>
<blockquote>
<p>同上，从学习中找到掌握感和满足感 </p>
</blockquote>
<p>要赚回 成本</p>
<blockquote>
<p>比如说GRE交了钱当然要好好学习</p>
</blockquote>
<p>一些可以采用的学习方法</p>
<ul>
<li>多元思维模型<ul>
<li>具体还需要阅读更多书籍</li>
</ul>
</li>
<li>费曼学习法<ul>
<li>通过写博客来输出 如果时间不支持就在整章或者整本书结束之后写博客总结</li>
</ul>
</li>
<li>康奈尔5r笔记<ul>
<li>上课可以随手记</li>
</ul>
</li>
</ul>
<h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><p>二维的时间衡量尺度</p>
<ul>
<li>成果=专注力*时间</li>
</ul>
<p>了解脑科学 把重要的事情放在早上<br>在疲惫之前休息</p>
<blockquote>
<p>把握好休息时间</p>
</blockquote>
<p>好好睡觉</p>
<p>提高效率 是为了留出更多休息/自由时间<br>专注时间 15 45 90</p>
<blockquote>
<p>意思是人的专注时间是以15min为单位的，可以按照这个周期来组织休息</p>
</blockquote>
<p>限制时间</p>
<blockquote>
<p>给自己的每一小段时间设置ddl 但是我的问题在于不肯及时抽身</p>
</blockquote>
<p>早上效率最高</p>
<p>起床以后：</p>
<ul>
<li><p>睁着眼睛不要睡</p>
</li>
<li><p>不要玩手机</p>
</li>
<li><p>一起来就利用好时间 学习新东西或者看书（背背单词也可以）<br>正式的一天开始前（书中指上班）的时间是自我充电的最佳时间</p>
</li>
</ul>
<blockquote>
<p>计划刷leetcode 或者读一小篇英语文章 或者背单词</p>
</blockquote>
<p>午饭时间</p>
<ul>
<li>出去走一走 </li>
<li>尝试新的菜式 细嚼慢咽。</li>
<li>午睡三十分钟 睡前喝茶或者咖啡</li>
</ul>
<p>下午</p>
<ul>
<li>穿插低消耗的工作</li>
<li>更换场景休息 </li>
</ul>
<p>高效休息</p>
<ul>
<li>不要玩手机 </li>
<li>也不要启动视觉 闭目养神或者走走 听音乐 正念</li>
</ul>
<p>规定离开的时间 “后有约定”</p>
<blockquote>
<p>不要为了工作/任务无限妥协 该休息的时候就休息</p>
</blockquote>
<p>运动可以提高效率 一周至少运动一次 但是不要太累</p>
<p>不要让压力和疲惫过夜 当天恢复不要压到周末</p>
<blockquote>
<p>所以需要养成读感兴趣的书这样平静的放松习惯 避免干扰正常的睡眠</p>
</blockquote>
<p>交流是一种很好的放松 尤其是面对面<br>重视休息 就像重视工作 不要加班</p>
<p>睡前两小时 放松下来才能保证睡眠</p>
<ul>
<li><p>不要高强度工作 </p>
</li>
<li><p>不要玩手机 </p>
</li>
<li><p>不要运动 </p>
</li>
<li><p>不要吃东西</p>
</li>
</ul>
<p>睡前1到2小时是记忆的黄金时间 应该多做些回顾（学习上小结） 记录有趣的事情（不管是基于sns还是日记）</p>
<blockquote>
<p>可以在睡前做一天的学习回顾 写日记</p>
</blockquote>
<p>利用周末</p>
<ul>
<li>睡懒觉也不要超过平常起床时间的两个小时 平常睡好好过补觉</li>
<li>越是疲惫越应该运动</li>
<li>互补休息法 在周末做和平常不一样的事情</li>
</ul>
<p>高效工作</p>
<ul>
<li>不是到什么为止 是什么时候做</li>
<li>能两分钟解决的事情就现在做</li>
</ul>
<p>并行做事 另外一件事一定要是低精力消耗的</p>
<ul>
<li>移动读书（携带电子书 有输出）</li>
<li>利用耳朵 听书听听力</li>
<li>边走边想</li>
</ul>
<p>自由时间</p>
<ul>
<li>投资自己 不仅仅是加班</li>
<li>主动娱乐<ul>
<li>读书是主动娱乐 有助于提高专注力 </li>
<li>玩手机是被动 会降低专注力</li>
<li>有时间再看—-拖着拖着就不想看了<br>带着目的去做</li>
<li>专注工作和专注于娱乐本质是一样的</li>
</ul>
</li>
</ul>
<blockquote>
<p>深有同感 反复切换无法享受会拉高感到快乐的阈值 </p>
</blockquote>
<p>把玩乐写成todo 避免纠结</p>
<blockquote>
<p>面对浩如烟海的追星物料我是这样做的</p>
</blockquote>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>FAT12 File System</title>
    <url>/post/7f6e4fde/</url>
    <content><![CDATA[<h1 id="FAT12-File-System"><a href="#FAT12-File-System" class="headerlink" title="FAT12 File System"></a>FAT12 File System</h1><h2 id="DAY-3-1"><a href="#DAY-3-1" class="headerlink" title="DAY-3~1"></a>DAY-3~1</h2><blockquote>
<p>出现负数是之前的时间一直在厘清思路，并没有很大的进展</p>
</blockquote>
<p>大致框架：在main函数内初始化一个模拟磁盘的数据结构，作为FAT12文件系统，在支持输入和输出。目前给定的测试目标是存入文件并且读取。</p>
<p>由于使用的是内存的堆栈的空间，实际上在每次退出程序之后模拟文件系统中的内容都不会保存。阅读别人的代码以后，进行改进：把模拟磁盘的内容使用文件读写写进一个二进制文件（镜像），在程序运行的时候进行装载。</p>
<blockquote>
<p>不要想着一口吃成胖子！可以先入手的是固定数据结构的实现</p>
</blockquote>
<p>运行逻辑：main函数内接受指令，对模拟磁盘进行操作（模拟磁盘是一个大小与为1.44MB的char型数组，这就意味着以字节为单元），在程序结束时将该模拟磁盘数组的内容写入指定的二进制文件，在程序开始时反之装载二进制文件的内容到模拟磁盘数组。</p>
<p>对连续空间的操作：逐个字节搬运数据；在设计数据结构的时候使用union，使得结构同时具有字符数组的形式，通过对每个字节进行操作来完成读写盘。（ICS的pa中其实有类似的思路，文艺复兴！）</p>
<p>首先实现的读写操作如下：</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将bootsector结构体中的数据写入缓存磁盘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write_rmdisk_bootsector</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ramdisk,<span class="keyword">const</span> BootSector* mbr)</span></span>;</span><br><span class="line"><span class="comment">//从缓存磁盘中读出数据到bootsector结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read_rmdisk_bootsector</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*ramdisk,BootSector*mbr)</span></span>;</span><br><span class="line"><span class="comment">//从磁盘中指定块读出一个数据块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read_rmdisk_block</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* ramdisk,<span class="keyword">unsigned</span> <span class="keyword">int</span> index,<span class="keyword">unsigned</span> <span class="keyword">char</span>* block)</span></span>;</span><br><span class="line"><span class="comment">//将一个数据块写入到指定块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write_rmdisk_block</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ramdisk,<span class="keyword">unsigned</span> <span class="keyword">int</span> index,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*block)</span></span>;</span><br><span class="line"><span class="comment">//将缓存磁盘的数据写入到磁盘文件中 成功返回0 否则-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Write_rmdisk</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ramdisk,string diskname)</span></span>;</span><br><span class="line"><span class="comment">//从一个磁盘文件中读取数据到缓存磁盘中 返回成功从文件中读入的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Read_rmdisk</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ramdisk,string diskname)</span></span>;</span><br><span class="line"><span class="comment">//打印bootsector的信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_bootsector</span><span class="params">(<span class="keyword">const</span> BootSector* mbr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>进行简单的测试，头部变化较少，相对数据区更加简单，先装载头部进行测试：</p>


<p><img src="/post/7f6e4fde/image-20210713152438835.png"></p>
<p><img src="/post/7f6e4fde/image-20210713152455925.png"></p>
<p>在编写过程中首次独立编写简单的makefile，学习在脱离vs这类保姆式开发环境的情况下独立编译模块组合。</p>
<p>关于字符串的bug调了很久，const char*需要逐个赋值，后来被迫动手改造strcpy，注意strlen计算的是终止符之前的字符个数，所以未赋值的静态字符数组是无法通过strlen获得预定分配的空间的</p>
<p>优先实现具有代表性的个命令</p>
<ul>
<li>mkdir: 创建文件夹 实际上包含再已有情况下新建和直接新建两种情况，对应着查找指定目录和新建目录两个任务<ul>
<li>分解路径，根据当前路径名找到对应的cluster，在当前cluster继续查找，直到无法找到为止（目标是支持建立不止一层新文件夹 即在只有./a的情况下mkdir ./a/b/c也支持）如果能找到说明已经存在</li>
<li>在父文件夹cluster下补充信息，即新建新的entry，有必要就使用新的cluster（似乎应当交给函数封装实现）</li>
<li>分配新的cluster给将要建立的子目录</li>
</ul>
</li>
<li>touch 新建文件<ul>
<li>同上 分解路径 找到最近一级存在的父目录</li>
<li>如果是需要建立目录，那么同上；最后一段被<code>/</code>分割的默认为文件名，无论是否有<code>.</code>做分割</li>
</ul>
</li>
<li>edit 编辑文件<ul>
<li>根据文件路径 逐步拆分找到入口cluster并逐步遍历找到最后一个cluster</li>
<li>从标准输入读入 存放在临时空间中，根据偏移量判断是否需要新的cluster来存放</li>
</ul>
</li>
<li>cat 输出文件<ul>
<li>根据文件路径拆分找到入口cluster 一边遍历一边输出 直到计数器等于文件大小</li>
</ul>
</li>
</ul>
<p>实现过程：</p>
<p>0718</p>
<p>从mkdir开始实现 对位操作不太熟悉（之前ICS PA基础还不够扎实）对具体的模块也没有头绪 借鉴了代码 补齐了一些按照给定数据结构读写磁盘内容的基本操作，本质是把结构体内的成员根据字符串/数字逐个读取填写（即底层实现是两个parse数据结构的函数）</p>
<p>争取之后实现其他命令的时候把文字思路转换成伪代码，这样就能更好的确定各板块的共同需求 方便划分函数功能。</p>
<p>另外没有对新写的模块进行编译测试 磁盘FAT部分的初始化也没有完成 还有函数没有完成</p>
<p>0729 </p>
<p>花了很长时间写mkdir的指令，因为需要补充很多底层的指令。调试的时候发现段错误，于是用gdb调试；为了及时看到源码，对每一个模块都用了-g参数便于调试。</p>
<p>编译的时候因为typo， debug了很久，后来总是显示找不到新加入的cmd内的函数，检查发现makefile内编译主体程序的编译命令没有包含cmd.o</p>
<p>在认为有问题的函数打断点直接执行来缩小范围，后来怀疑是在parsePath的strcpy出现问题，因为一开始char entname[12] 编译没有通过改成了 char* entname，怀疑没有分配足够的空间导致栈溢出，于是改成用动态数组分配，问题解决</p>
<p>调试的时候遇到了输入第二个命令会 <code>*** stack smashing detected ***: terminated Aborted (core dumped)</code> </p>
<p>0730</p>
<p>先把剩下的命令全部实现，其中在写edit命令的时候学到一个函数<a href="https://www.cplusplus.com/reference/cstdio/fgets/"><strong>fget</strong></a>的用法,支持逐个字节读入数据并写入磁盘</p>
<h2 id="Sum-up"><a href="#Sum-up" class="headerlink" title="Sum up"></a>Sum up</h2><p>第一次在没有框架代码的情况下写这样的小系统。通过阅读别人的代码和自己设计实现逐步理清了框架和各个函数的功能与实现。项目管理的缺失让coding的进展非常不稳定。下个学期上课应该多注意这一方面的训练。</p>
<p>断断续续做了一个月，还有一些小bug没有调试。之后有空再来填坑</p>
<p>项目代码：（因为网络问题暂时没有同步，回校再填坑）</p>
<p>参考文献：</p>
<p><a href="https://zhuanlan.zhihu.com/p/122569192">https://zhuanlan.zhihu.com/p/122569192</a></p>
<p><a href="https://blog.csdn.net/yxc135/article/details/8769086">https://blog.csdn.net/yxc135/article/details/8769086</a></p>
<p><a href="https://reeeeeeeeeein.github.io/2020/04/15/fat12%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">https://reeeeeeeeeein.github.io/2020/04/15/fat12%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</a></p>
<p><a href="https://github.com/warpmatrix/fat12-file-system">https://github.com/warpmatrix/fat12-file-system</a> useful</p>
<p><a href="https://blog.csdn.net/Laichilueng/article/details/54669370?utm_medium=distribute.pc_relevant_download.none-task-blog-2~default~searchFromBaidu~default-7.test_version_3&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-2~default~searchFromBaidu~default-7.test_version">https://blog.csdn.net/Laichilueng/article/details/54669370?utm_medium=distribute.pc_relevant_download.none-task-blog-2~default~searchFromBaidu~default-7.test_version_3&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-2~default~searchFromBaidu~default-7.test_version</a>_</p>
<p><a href="https://zhuanlan.zhihu.com/p/121807427">https://zhuanlan.zhihu.com/p/121807427</a> 给出参数具体值</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Google2021STEP 失败小结</title>
    <url>/post/c243b9f0/</url>
    <content><![CDATA[<h2 id="初期准备"><a href="#初期准备" class="headerlink" title="初期准备"></a>初期准备</h2><p>起初真就见财起意，但是由于本人执行力太差，大一下在家期间原本希望的早起刷题并没有实现，暑假又以准备开学考试为由没有刷题，真正刷题是大二上学期在决定申请之后，刷力扣大概一两个月的时间，算法面试题的集合中动态规划几乎没做（划重点这里会考！），其他部分做了七七八八。但是完成度不高，不够精细，基本都是先想一会然后看答案，如果不太难就自己复刻，太难没耐心想就会理解之后copy。而且重难点的题目没有多次巩固。一方面是时间问题，刷题的时间集中在了复习周+美赛爆肝期间（不过事实证明时间确实是海绵里的水，没空是因为还不够渴望）；另一方面是方法问题，由于对需要达到怎样的程度并没有清晰的认识，在钻研的深度上有所欠缺。</p>
<h2 id="软实力准备"><a href="#软实力准备" class="headerlink" title="软实力准备"></a>软实力准备</h2><p>写了简历，结合了自己做过的一些小项目和课程大作业（呜呜这里也划重点），但是简历当时写的不够精简。</p>
<p>找了HR姐姐给自己内推，之后出现情况也很及时的去push了 夸夸自己！</p>
<h2 id="本人搞笑实录"><a href="#本人搞笑实录" class="headerlink" title="本人搞笑实录"></a>本人搞笑实录</h2><p>留了两个邮箱，但是一直以来主要通过新浪联系，导致没发现最后最关键的通知面试信息投到谷歌邮箱去了，还好在朋友开始面试之后去问了hr姐姐 我是憨憨</p>
<p>不知道是否是回复面试通知确认时间太晚的原因，我第二天的上海base面试竟然被放鸽子了，于是只能过年后回来再面。我早早面完的同学第二天就收到了拒信orz</p>
<h2 id="手撕代码部分"><a href="#手撕代码部分" class="headerlink" title="手撕代码部分"></a>手撕代码部分</h2><h3 id="第一场-北京base"><a href="#第一场-北京base" class="headerlink" title="第一场 北京base"></a>第一场 北京base</h3><p><strong>Q: 有N个盒子，盒子内壁厚度不计，只有盒子长和宽大于等于另一个盒子的长和宽的时候能套盒，求能够套盒的最大数目</strong></p>
<p>与一般的排序不同，有两个维度，先对于长排序，然后考虑对宽思考，在面试官姐姐的提示下考虑用了动态规划的思路（还好我对记忆化搜索以及动态规划的名词有点印象），前一个盒子的最大套盒数=max{比它小的盒子的最大套盒数}+1 </p>
<p>思路理清楚之后上手写代码，同时用一些简单的测试用例来检查了一些小bug，（比如初始状态写错了）发现盒子宽度是逆序的时候会出现无法处理的情况，于是通过修改排序函数中比较大小的函数来规避 注意返回的逻辑变量与期望的大小是相反的 写完这些面试时间已经到了</p>
<p>总体来说，上来自我介绍的时候说了姓名学校入学时间，好死不死说了一句学过数据结构了 之后首先是问了实习会做什么 其次问了面试官对我有什么建议。面试官肯定了我的表达能力，但是说我的代码能力需要加强，可以多看看面经，我心里有一点点慌。貌似我踩雷了，不应该让面试官再回忆我的缺点的</p>
<h3 id="第二场-上海base"><a href="#第二场-上海base" class="headerlink" title="第二场 上海base"></a>第二场 上海base</h3><p><strong>Q： 计算N个数中，抽取k个数的最大和</strong></p>
<p>转换成求K个最大数，又转换成快速排序的算法，在面试官小哥哥的提醒下意识到K个最大数内不需要排序，所以在写出快速排序的基础上还需要进行修改。。然而我发现自己对快速排序理解还不够深刻，解释原理的时候磕磕绊绊，在解释分界线的时候误认为是一半之处，小哥哥还顺着我的话往下说真是呜呜呜谢谢不戳穿之恩。是否继续递归需要分情况讨论：较大一组数的数量大于/小于/等于K 根据需要停止/继续排序 算复杂度，我认为原本最终停下时的被排序的子数组长度是1，在本题情况下是n/k，所以结合原本快速排序的时间复杂度，本题版本的时间复杂度应该是 $$ O(nlog \frac{n}{k}) $$  面试官说应该要更小一些（惊恐的怀疑自己算错了，从语气中听出来的）。之后自己设计了一组简单的用例，但是只测试到了一种情况，还有一种来不及测试针对性的用例，于是面试官问了一些设计用例的测试思路。从数据规模，排列方式，k的大小选择上都说了一些。最后一个当我提到的时候面试官也正好开口了，说明是重点。</p>
<p>除了问题，开头还问了我的简历中的项目，问了消消乐 结果因为听不清加上英文没对上我还去翻了自己的简历才反应过来，自己的简历也要好好复习哇</p>
<p>基础功不扎实，回答的时候磕巴空白很多，写代码也卡了很久，天哪连基础的快速排序都磕磕绊绊的 虽然后来还坚强的走完了流程 但是我觉得听语气上来说 我应该是凉了。</p>
<p>之后只好意思问了提升自己的方法这个问题，得到的建议是偏工业方向的，做经典的项目，对比学习经典的代码来提高。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实是在结果没出来之前码字的，我心里残存的不甘心和渴望反映在了梦境里，我真是高考都没那么心心念念过。事实证明我的努力完全配不上我的在意。也罢，从在意的事情的失败上来学习面对失败，同时也学到很多面试小技巧，以及认识到了自己的诸多不足和five之处。谨以此警醒自己。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Owl at Dusk</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>The Truth Untold--迟到两年的高中生活回忆</title>
    <url>/post/7b442c5c/</url>
    <content><![CDATA[<p>写这篇的原因是，临时起意在知乎搜索了二中，结合和朋友讨论二中老师近期的反应，有很多零零碎碎又反复出现的想法，不如一次写个痛快。</p>
<span id="more"></span>



<h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><p>事实上我已经几次下定决心不再关注二中的事情，但是今年高考成绩实在是让我大跌眼镜。理科前一百三人，前五十一人（来自我本届同学的消息，知乎提问中则说是两人），二中前三十对应全省排名竟然到600名左右。文科稍好，文科有榜眼。一本率和600分率我不太清楚。</p>
<p>当然也有本届的同学站出来说二中并不算差，不能因此唱衰二中。首先，要明确的是，所有讨论都没有责怪同学的意思，毕竟在自认生源不好的情况下，老师和领导会反复强调“你们这届生源不行”，但是却忘记二三中的同学的水平在除尖子以外的重合率是非常高的。因此所有讨论都无意否定同学们自身的努力。加上我本人的视野水平有限，也会更多关注尖子生，即特训班/实验班层次的整体成绩。同时，对于尖子生来说，清北也并不是衡量他们全部努力和才智的唯一标准。因此，当我批评二中成绩的时候，更多的讨论在学校自身KPI体系下学校的表现，而无意冒犯同学。我想一部分同学否定二中今年成绩不理想，可能是出于不愿否定自己努力的心理，但是当我们把学校的教学方针和同学的努力分割开，为何不大大方方的承认今年二中的成绩就是在尖子层肉眼可见的差。今年毕业的同学缺少信息来源或许不太清楚，但在已经毕业观察多届成绩，并且经历过报考选校甚至参与过招生的人眼里，历年的横向比较足以说明问题。<del>废话有些学校的朋友都快要没直系了当然说明大滑坡啊</del></p>
<h2 id="归根到底"><a href="#归根到底" class="headerlink" title="归根到底"></a>归根到底</h2><p>自我毕业以来，二中经历了收手机，加强补课等一系列衡水化的加速，期间也有不少非制度性的<del>恶性</del>事件。每一次都会激起一阵讨论，但是说来说去，问题无非都一样。</p>
<p><strong>领导层的改革缺乏可行性和科学性</strong>，朝令夕改，容易受家长影响，领导脱离实际，不够尊重一线的老师的自主权；这样导致的结果就是老师和学生疲于奔命，浪费宝贵的时间（尤其是在高三期间），并且加重老师和学生，老师和领导，学生和领导，学生和家长之间的对立情绪。瞎折腾高三是大忌，影响高一高二打基础也不是明智之举。二中领导已经到了一种草木皆兵，邯郸学步的地步了。</p>
<p><strong>对尖子生，学校领导“狡兔死走狗烹”的态度太过明目张胆</strong>，让人寒心；唯清北论也非常影响高三尖子生的心理状态。领导可能以为所有人都自小立志清北“不破楼兰终不还”，但是忘记了过大了压力会让人更早崩溃。为了KPI<em>道德绑架</em> 学生乃至进行语言上的<em>PUA</em>的情况我就不再赘述了，之前发过一个长篇说说被人喷戾气太重我可真是不愿再笑。朋友，未经他人苦莫劝他人善好吧。</p>
<h2 id="说说特训"><a href="#说说特训" class="headerlink" title="说说特训"></a>说说特训</h2><p>特训班其实是这样一个心理的产物：清北 or nothing。人们在讨论一所高中的成绩的时候，往往最先关注的是清北，连复交浙科南等都被直接无视。我曾经很不能理解，清北终究是少数，为什么家长如此执着，直到我同学一语道破：“毕竟进来之前谁都以为自家小孩是上清北的料”</p>
<p>OK Fine. 但即便是特训班，也做不到全员清北。如果真要把特训班定性成非清北不可的班级的话，我建议也别弄什么1班2班了，留15个人在理特就行了。更何况非清北不可对于在清北线边缘徘徊的同学是非常负面的，终日活在患得患失里还不如直接放弃执念。这种执念也会让认同这套价值体系的人自觉的区别对待学生个体，无论程度轻重。虽然我们的班主任不止一次的抱怨过我们“没有血性”，但在我看来这恰恰是00后某种心理上的转变：清北的光环并不值得你牺牲一切，比如心理和生理的健康。忽视这种执念与情结的淡化，一味的通过否定其他学府的价值来道德绑架学生，显然并不能达到“冲一冲”清北“的效果。<del>有兴趣可以知乎搜索南宁二中，有一部分各届特训班同学的回答有点意思的</del></p>
<p>再来说说特训班自身。以我自己为例，虽然特训班偶尔要被领导恶心几个小时（骂的就是座谈会），但是氛围搞得好的话也能享受和高手过招的快乐。说到生源，大家似乎都比较喜欢以6A+评定尖子生源好坏。甚至后来几届的分班也基本以5+6+为一锤定音的根据。但是在我看来这显然不科学。如果观察过历年尖子生榜，你不难发现，4A+5A+的同学不在少数；甚至我所在的特训班的入口成绩分布也以4、5个A+占大头。在我看来，如果二三中在4 5A+的人数分布没有明显差距，那么考不好就不是尖子层学生的错，而是教学方针的问题。而这教学方针，又与领导有更大关系。毕竟我的班主任和科任老师在每次大考后开完会都会肉眼可见的焦虑。领导不适当的施压和干涉只会打乱老师原本的教学安排，这种错误最后必定会传导到学生身上。与我朝夕相处的老师无论如何都还会真正关系我作为个体的发展，而一年到头见不到几次面的领导可就不一定了。</p>
<h2 id="一个理想主义者的自白"><a href="#一个理想主义者的自白" class="headerlink" title="一个理想主义者的自白"></a>一个理想主义者的自白</h2><p>在我认识的人当中，我可能是骂二中骂的最狠的那一个（乐了。从高三开始，在我见识到一些社达言论以后，我感到自己被拉扯撕裂。作为一个16年入学的人，多少还是享受了二中最后几年的宽松氛围，有幸体会了“启牖智慧 活泼身心“的校训。我曾经也是真的相信来到二中可以借助这里优秀的师资和同学氛围来self-educate成一个人，而非一个工具的。但是一些急功近利的措施和言论让我开始动摇：某些人眼里，我们也只是KPI工具人罢了。</p>
<p>当我和大学同学聊到我的高中的时候，我突然意识到，让我有归属感的是我的老师，我的同学，还有那个允许我“八分精力在学习，两分精力瞎搞”的氛围。<strong>会痛苦，会失望是因为依旧对那里有期待。</strong>介于我本人的性格是有感情也照样嘴的，所以一年前写下关于我在特训班一些不愉快记忆但却被人说戾气重以及被讲“此人观点需要观望”的时候，我不明白了。有些人对二中莫名其妙的滤镜大到听不得一点点真话。</p>
<h2 id="防杠说明"><a href="#防杠说明" class="headerlink" title="防杠说明"></a>防杠说明</h2><p>为了防止有些人说我纸上谈兵破而不立，先声明，我不能保证我的观点一定正确，毕竟我只是从我自己的角度出发，谈谈我作为一个曾经的学生所见所思。不过介于有些老师认为有意见的特训班学生是白眼狼，我只能说<strong>所有特训班的学生都没有跪着求进二中的特训班 凭成绩进出谁也不欠谁 如果你真的在乎老师付出的额外努力就应该看看这些努力到底是有用的还是在互相折磨学生与老师</strong> </p>
<p>写破防了，呼应一下题目，用The Truth Untold歌词收尾吧</p>
<blockquote>
<p>난 울고 있어，</p>
<p>我泪流满面，</p>
<p>사라진，</p>
<p>消失的，</p>
<p>무너진，</p>
<p>倒塌的，</p>
<p>홀로 남겨진 이 모래성에서，</p>
<p>独自残留下的这沙城之中，</p>
<p>부서진 가면을 바라보면서，</p>
<p>望着这破碎的假面，</p>
<p>And I still want you，</p>
</blockquote>
]]></content>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-world</title>
    <url>/post/b1d4025b/</url>
    <content><![CDATA[<p>如果表达是为了给自己记录，而不是为了成为大触，那么表达的好坏是无所谓的。</p>
<p>所以这里只是各种碎碎念</p>
]]></content>
  </entry>
  <entry>
    <title>前人栽树后人乘凉-配置自己的RSS</title>
    <url>/post/68913f78/</url>
    <content><![CDATA[<p><em>希望solo追星但是不愿意错过大粉物料的，速来！</em></p>
<span id="more"></span>



<h2 id="为何使用RSS"><a href="#为何使用RSS" class="headerlink" title="为何使用RSS"></a>为何使用RSS</h2><p>面对纷繁的信息和无穷无尽的粉丝撕逼（不是），我一直以来渴望一个收集器，只获取我需要的信息/idol物料。偶然间看到RSS，发现它完美符合了我的需求：</p>
<ul>
<li>主动抓取，我不需要跟在博主或者平台后面翻找</li>
<li>跨平台的整合 从微博到一些专业新闻网站</li>
</ul>
<p>使用现有的RSS平台（这里我用的是<a href="https://feedly.com/">Feedly</a>），加上一些<a href="https://docs.rsshub.app/">插件</a> 可以轻松完成跨平台的信息收集。如果需要更近一步的个性化配置，也可以自己搭建RSS服务。</p>
<h2 id="为何需要插件"><a href="#为何需要插件" class="headerlink" title="为何需要插件"></a>为何需要插件</h2><p>RSS 的全称是 Really Simple Syndication（简易信息聚合），简单说就是一个订阅网站更新的协议。被订阅的网站需要有对应的RSS链接，就像电话联系需要有电话号码一样。如果网站有，皆大欢喜，如果没有就需要配合插件使用。</p>
<p>目前我使用的插件是一个有规模的插件服务，支持非常多的原本不支持RSS的网站订阅。但是可能因为部分网站采取了反爬策略，有一些无法通过原本的服务器订阅。比如豆瓣和微博。</p>
<p>参照教程，在本地部署了RSS后，豆瓣小组的内容可以被爬取了。估计需要保持本地RSS运行才能及时获取消息？</p>
<p>但是微博依旧不可。</p>
<p>于是找到另一个<a href="https://rssfeed.today/weibo/">生成微博订阅的网站</a> 成功解决问题</p>
<p>更新：rsshub的服务器被twitter反爬了，所以找了<a href="https://uneasy.win/2020/05/rsshub%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%B2%E6%94%AF%E6%8C%81twitter/">别人的服务器</a> 现在只需要按照rsshub的手册写地址配参数的同时，把网址替换成博主提供的网址就可以了。</p>
<p>注意这里的twitter id是分享链接中尾部的标识符，也就是一般推特名字下方给的@号后的内容</p>
<blockquote>
<p><a href="https://rsshub.uneasy.win/twitter/user/YourTargetId">https://rsshub.uneasy.win/twitter/user/YourTargetId</a></p>
</blockquote>
<h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>虽然我也知道当代人面对纷繁的信息洪流，应当沉下心来读书，回归经典。高中的时候我曾经写过一篇随笔说明这个问题，那时候我的态度就是两手都要抓，两手都要硬。即时的信息也有它的意义，正是当下的点滴构成了如今我们所处的潮流。但是与经典书籍相比，信息/新闻的纷繁是它最大的弱点。RSS可以让人重新夺回面对信息流的主动权，从这个意义上说，构建这样一个信息茧房不是坏事。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title>最寒冷的冬天</title>
    <url>/post/6e659447/</url>
    <content><![CDATA[<h2 id="读这本书的缘由及其主要内容"><a href="#读这本书的缘由及其主要内容" class="headerlink" title="读这本书的缘由及其主要内容"></a>读这本书的缘由及其主要内容</h2><p>我是在机场逛书店的时候偶然看到这本书的，当时正是朝鲜战争七十周年，书店在推这本书当然是应景的。但我买下这本厚的像砖的书的更重要的因素是，想要更加深入的了解朝鲜战争爆发的原因，换句话说，从严肃读物里探究中国出兵是否正当合法。当时正是受1011防弹“中弹”事件的影响，网上的发言大多引自教材或者宣传口，于是为了寻找我自己的答案，一时兴起买了这本书慢慢看。</p>
<p>说实话读完整本书，我一开始的疑惑并没有得到完整的解决。对于这场战争一开始的爆发，是朝鲜先出兵一直是毫无争议的（这也要感谢我的初中历史老师）。但是中国是出于怎样的理由出兵干预，以及在韩国人眼里中国人是否能算”侵略的帮凶“，这本书也并没有给出明确的回答，只是一笔带过说”朝鲜军队中有一部分部队曾经在中国内战的战场上为中共效力“。但是对于美国的态度，这本书给出了一个和中国教材有所不同的视角。</p>
<p>这本书有相当多的部分化用了参战美国士兵的采访，描写了战斗的激烈场景，如果是对战争本身感兴趣，那么读起来应该很有意思。但是我对地形和军队分布不太熟悉，加上我的侧重点在于合法性，在我下定决心略读之前，我阅读这本书的进展都相当缓慢。所以如果是希望短时间内弄清楚战争的起因，那么去阅读侧重点在当时东北亚局势的学术文章可能会更合适。</p>
<p>从整体脉络来看，作者选取了云山之战作为开头，之后从朝鲜越过三八线突袭美军开始，一路写到战争结束、和谈、东北亚当今的变化（讲述到如今朝鲜半岛以及中美的现状的时候，有一段读起来相当突兀，估计是被阉割了）。除了战场上，还描写了很多美国国内政治势力的博弈，同时对中国国内的决策层也有一定笔墨的描写。对于从美国视角来看朝鲜战争的全景，还是相当有帮助。</p>
<h2 id="一些中美视角对比"><a href="#一些中美视角对比" class="headerlink" title="一些中美视角对比"></a>一些中美视角对比</h2><p>刚开始读时，最惊讶的部分是武器对比。从小被教育的是美国有强大的火力和武器，充足的后援物资也供应及时,所以志愿军能够赢得战争全靠”精气神“。但是从美国人的视角来看，这场战争打得相当轻敌且匆忙。建国初期二者国力差距对比可见一斑。中共一部分高层的担忧也不算是软弱。</p>
<p>作者还花了相当多的笔墨着重描写麦克阿瑟与杜鲁门在朝鲜战争决策中的博弈，这对于一直以来处于”一尊“环境的中国人来说应该是很有意思的部分。因为当时的中国，尽管国内大部分高官都反对出兵朝鲜，但是毛泽东的意见最终成为国家的决策。正因如此，对于对华强硬派的军事行动，中国人直接定义为美国的国家意志（当然宣传口也火上浇油的利用了这一点）。中国人无法想象何谓不同势力的博弈。</p>
<h2 id="当不得不面对一场战争"><a href="#当不得不面对一场战争" class="headerlink" title="当不得不面对一场战争"></a>当不得不面对一场战争</h2><p>作者在书中透露出了让一个自由派感到亲切的反战情绪，例如提出了这样一个问题：即便胜利，那些本可避免的牺牲是否应当被反思。作者也花了一些笔墨描写这些经历过战争的士兵对一同逃出生天的战友的感激，以及一些在撤退过程中的人性光辉。有一个细节让我感慨万千，有不少撤退过程中躲过炮火活下来的老兵，以及后来被争取交换释放的俘虏，在回到本土后都获得了象征为国家英勇付出的勋章。如果视角一换，那恐怕就是在历次运动中被打成右派/走资派的批斗对象了。</p>
<p>另外，从无情的战争胜负视角，早期的麦克阿瑟和晚期的毛泽东都犯了大意轻敌，自我膨胀的错误，还有忽视一线情报和敌我力量真实对比的错误。麦克阿瑟可能是出于种族歧视错误的高估了美军阵地的稳固性，低估了朝鲜军队突袭战术的有效性；而毛泽东则可能是将追求意识形态的胜利摆在了现实情况之前（也有可能他并没有意识到自己的自大，只能说彭老总真的惨），下达了攻占汉城这样明显是几乎不可能完成的政治任务的命令。</p>
<p>与之相反，彭德怀和李奇微则都是值得尊敬的将领。例如彭德怀根据情报成功预判出麦克阿瑟会选择让美军在仁川登陆。本书花了很多笔墨描写李奇微在接手朝鲜战局后的一系列措施。首先，身先士卒恢复士气，同时替换中层指挥官，重视情报搜集分析，纠正麦克阿瑟时期纸上谈兵的错误；其次，通过砥平里等一系列战役摸清中国-朝鲜军队的作战特点，针对性的打击。简单来说，基于美国的综合国力，只要指挥官不作死，战局稳定只是时间早晚。</p>
<p>从作者的视角来总结，中国的优势在于人多，集中力量攻克松散的美军防线在战争初期有奇效，一般是通过人海战术消耗美军的弹药，从而攻占阵地，但是如果美军在空投保证弹药，并且阵地之间配合足够紧密的话，中国军队的人数优势就会更多的变成无意义的消耗。概括书里对双方战术的暗示的话，其实只有一个非常残酷到原有抗美援朝话术下无法面对的结论：李奇微的战术，就是用弹药来抵消中国的人数优势，中国的战术，就是用源源不断的人命来抵消美军的弹药/补给优势。</p>
<p>不带感情地说，中国的所谓”精气神“，本质就是人多罢了。从这个意义上来说，如果不反思战争”你死我活“的本质，那么意识形态的宣传，其实更像是吃普通军人的人血馒头卖惨。</p>
<p>另外，帮助南北韩作战的本质都是联军。但是美国实际上对联合国军队有本质的控制权，然而中国却无法合理调动包括苏联空军在内的社会主义阵营的力量，就连朝鲜军官都听不进彭德怀的作战建议。从这个视角看，中国可以说是非常吃力不讨好。</p>
<p>阅读这本书花了我前前后后将近小半年的时间。带有一定目的来寻找答案的话，其实可以多采用略读的模式，读完比细读更重要。读完这本书，会对朝鲜战争有新的认识。信息的重要性，反思战争的残酷，认识到地缘政治博弈下残忍的现实，都是我除了寻找”正当性“外的意外收获。</p>
]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>book review</tag>
      </tags>
  </entry>
  <entry>
    <title>2021暑假小结</title>
    <url>/post/f7e510c4/</url>
    <content><![CDATA[<h2 id="目标与效果对照"><a href="#目标与效果对照" class="headerlink" title="目标与效果对照"></a>目标与效果对照</h2><p>假期前列出了以下to do：（按照重要性排序）</p>
<ul>
<li><p>准备GRE 9月开学即考试</p>
</li>
<li><p>完成操作系统课上的PA：FAT12文件系统</p>
</li>
<li><p>搭建博客</p>
</li>
<li><p>leetcode习题积累</p>
</li>
<li><p>自学爬虫 解决一些感兴趣的数据分析话题</p>
</li>
<li><p>收集信息</p>
</li>
<li><p>把借来的书读完（世界史系列8本 北欧神话 二战系列2本 说服与不被说服的艺术 20世纪简史）</p>
</li>
</ul>
<p>实际完成的情况：</p>
<ul>
<li>GRE<ul>
<li>在假期背完了学期间的GRE单词<ul>
<li>粗略过了一遍 做题过程中高频词不够熟悉</li>
</ul>
</li>
<li>Issue 写作5篇，分析6篇 和Arguement 5篇写作<ul>
<li>有大致的思路框架 但是几天不写会模糊</li>
<li>能够表达 但是打字速度和用词需要继续加强</li>
</ul>
</li>
<li>选词 linduxi做了两遍，高频合集做到20+<ul>
<li>与最开始相比能够分析句子</li>
<li>词汇量需要加强</li>
</ul>
</li>
<li>阅读 中间20~30题做了两次 目前到约40题<ul>
<li>能够断长难句 理清逻辑</li>
<li>词汇量和长难文有待提高</li>
</ul>
</li>
<li>数学 专题还差概率部分<ul>
<li>只做了第一遍 需要复习错题和总结技巧</li>
</ul>
</li>
</ul>
</li>
<li>FAT12<ul>
<li>完成了基本的框架代码并且同步到了github上 博客同步更新</li>
<li>但是有bug没有调试完</li>
</ul>
</li>
<li>搭建博客：网站已经可以正常运行 包括评论 tag 收录到搜索引擎<ul>
<li>反复更换心仪的主题 调试比较花时间</li>
</ul>
</li>
<li>Leetcode 100题没有做完，做了一半这样，只要当天在学习就尽量做题<ul>
<li>至少每天一题 偶尔有几次能够在玩耍完回家后随手来一题</li>
</ul>
</li>
<li>读书：读完了《说服与不被说服的艺术 》世界史2本 北欧神话 （都没有更新读书笔记）</li>
</ul>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>最大的问题是作息 1点~3点睡 10~12点起成为常态导致一整个上午直接报废，下午的效率比较高 晚上基本在放松躺平</p>
<p>因为一直在熬夜，所以也不敢运动。关键是到点就休息 维持良好的作息才会有更多的自由时间</p>
<p>其次是不太紧张，虽然开了倒计时但是对于没有明确时间节点的任务经常会因为赖床往后推。在GRE考试延期以后连最开始坚持的GRE刷题也松懈了。</p>
<p>因为在家放假，休息时间很容易失控。应当用温和平静的放松方式代替玩手机，避免一次上头忘乎所以。</p>
<p>假期生活也有做得好的地方，比如：在准备GRE的过程中，发现先探索再调整计划，比担忧能否完成计划更有利于身心健康。</p>
<p>leetcode也渐渐做出手感，希望一天一题至少能保持下去</p>
<h2 id="新学期的展望"><a href="#新学期的展望" class="headerlink" title="新学期的展望"></a>新学期的展望</h2><p>第一，利用在家的时间 把书看完（忙里偷闲的时候看书效率更高！）</p>
<p>第二， leetcode 和GRE保持，leetcode每日一题，GRE采用写作+选词/数学+阅读之类搭配的方式保持练习量直到回校）巩固高频单词 可以利用好早八之前的时间 </p>
<p> 第三，恢复锻炼。利用好下午课程后的时间还有闲置的瑜伽垫进行复检</p>
<p> <em>Make hay while the sun shines</em></p>
]]></content>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>恢复特定文件到过去版本的解决办法</title>
    <url>/post/ca390c6f/</url>
    <content><![CDATA[<p>事情的起因是提交java作业的时候，因为有一个模板文件被改动而无法merge。于是需要把这个文件还原到最初下载时的样子</p>
<p>首先是查询特定文件的git log记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> ./folder/filename</span><br></pre></td></tr></table></figure>



<p>在windows的git bash中，是无法通过 <code>git reset --hard 版本哈希 filename </code> 来回退的</p>
<p><a href="https://www.jianshu.com/p/caae5b928173">搜索</a>后发现应该用<code>checkout</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 版本<span class="built_in">hash</span> filename</span><br></pre></td></tr></table></figure>

<p>可以避免影响已经完成的作业</p>
<p>但是这样是无法直接push的，因为有文件回退到了过去的版本。<a href="https://stackoverflow.com/questions/30471557/git-push-master-fatal-you-are-not-currently-on-a-branch/30471627">会出现 you are not currently on a branch</a></p>
<p>可以通过 <code>git push origin HEAD:master --force</code> 来强制执行</p>
<p>成功！</p>
<p>Stackoverflow 好用！</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>RM 高考 目的与手段 和我</title>
    <url>/post/72f41795/</url>
    <content><![CDATA[<p>rm生日的时候看到一条生贺视频 缪斯、月亮与鲸鱼 里面南俊说 在工作压力下 通过看展 散步 骑车 亲近自然 来放松自己 虽然说不能指望这些体验对音乐工作有直接的作用 但是至少这是他对抗压力的方式</p>
<p>突然鼻子就一酸 南俊的生活当中镶嵌了许许多多他喜欢的治愈的事情 而我却有很长一段时间都在把想做的事情推到“等到xx的时候” 如果压力一直长存没有尽头 如果人生不是为了一个目的就可以放弃一切 那在松动下来的时间里忙里偷闲又有何妨？跑弹不必留到周末再看 吃饭间隙就可以享受 想读的时候就找来放在手边 网络一关就可以开始看 毕竟 某种程度上 这也是让我不必崩溃的办法</p>
<p>到底是为什么没有办法享受闲暇 只能在碎片化中找到安心的时刻 只能在压力下承认自己也需要休息 为什么总要在极端反复跳跃？我想这个问题 得要回到高三的时候 毕竟那个时候只有一个目标 哪怕心底里在反抗 但只能在指挥棒下不断的自我拉扯 看综艺没办法看完 看书也不能认真享受 一切都推到高考以后 推着推着 高考过去了整整两年 我还困在这里</p>
<p>想起来看到的一篇衡水学生的文章 不得不承认尽管自己的高中已经宽松太多 但是总有一些相似的ptsd是高考体制下人们共通的 里面作者写到无法忍受等待和闲暇 做什么都要有目的和效率 实在是让人狠狠共情 为了一个目标能够放弃一切的想法 以及随之造就的习惯 其实作为一种惯性留在很多人的后高考时代 看转发评论里的人们可见一斑 可是有很多事情 也同样重要 或者换句话说 一些斗争不会到此为止 难道要一直这样等到克服一切困难才能放过自己吗 那可能要把一些原本属于自己的时光带进坟墓了</p>
<p>看着南俊 突然意识到自己也有和压力共存的方式 心安理得的在午饭的时候享受跑弹 心安理得的在认真做了几个小时的任务之后放松自己 反倒减少了很多犹如溺水之人抓不到救命稻草的时刻 想要从网络上找一些转移注意力的刺激的时刻减少了不少 搭配digital balance 这两天连睡眠作息都规律了很多</p>
<p>承认自己的压力 承认自己的欲望 让自己慢慢学会享受闲暇 享受专注 避免碎片化的emo 这是我最近学到的love myself的方式 感谢南俊 还有那个剪出让人落泪的生贺视频的4粉</p>
]]></content>
      <tags>
        <tag>Owl at Dusk</tag>
      </tags>
  </entry>
  <entry>
    <title>更换设备后追踪仓库更新</title>
    <url>/post/3a3e4295/</url>
    <content><![CDATA[<p>原本是在windows上git clone的github仓库，在原仓库有一次较大改动（发布新作业）之后，因为环境问题需要换到linux虚拟机上做，于是需要把仓库也clone到虚拟机上，但是直接git clone我fork过后的仓库只能下载提交后原仓库更新前的代码，需要更新。</p>
<p>首先检查upstream是否有对应的远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>如果只有两行origin，说明新设备上的仓库还没有与原本的仓库挂钩，需要添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add remote-original.git</span><br></pre></td></tr></table></figure>

<p>之后再次检查upstream，出现upstream两行就可以了</p>
<p>记得根据upstream的提示切换分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout upstream/main</span><br></pre></td></tr></table></figure>

<p>否则就会依旧停留在旧的版本（在这里卡了很久以为弄错了）</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>配环境有感</title>
    <url>/post/fbfaa019/</url>
    <content><![CDATA[<p>配环境有感<br>配环境是接触一门新语言/一个新框架的启蒙老师！</p>
<p>连续配了Android开发和php网页段的环境。发现为了跑demo实际上掌握了关于一个新技术大致的运行方式。比如Android需要Java底层的支持和很多在线组建的支持 还有php需要配合服务器而不仅仅是一个网页文件</p>
<p> 在配环境的过程中 经常会出现按照教程走了却没有得到想要的结果的情况 在解决这种不一致的过程中 必须要去了解原因 也因此会学习关于这门语言或者技术框架的运行原理 这样遇到问题才能分析出原因 配环境的这几个小时不算白搭</p>
<p>另外 在没有现成demo教程的情况下 学会问问题而不仅仅是一遍遍机械重复的尝试变得非常关键 比如我在配php环境的时候一直跑不出更加复杂的他人的项目demo 搜索了如何在浏览器显示php才发现是我想的太简单了 同时也意识到这一套体系是用来模拟网站而不仅仅是网页运行的 解决这一点之后demo丝滑运行了</p>
<p>不过必要的时候还是要寻求帮助 不过要在尝试所以能尝试的 能提问搜索的之后 </p>
<p>还有不得不说 Google永远的神 拥有谷歌的人解决问题的概率比没有的人高了不知多少 stackoverfkow也是好东西 看多了加上逼不得已 英文就不再成为阻碍了 而且也能锻炼快速抓重点的能力</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title>Algo Revised: Tree</title>
    <url>/post/55a58fe7/</url>
    <content><![CDATA[<h4 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. Symmetric Tree</a></h4><p>从树的递归性质入手 这里增加的难度在于左右交替判断 注意指针为空的情况</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSym</span><span class="params">(TreeNode* rt1,TreeNode*rt2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!rt1&amp;&amp;!rt2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rt1 &amp;&amp; rt2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rt1-&gt;val!=rt2-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isSym</span>(rt1-&gt;left,rt2-&gt;right) &amp;&amp; <span class="built_in">isSym</span>(rt1-&gt;right,rt2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSym</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h4><p>搜索树的定义！！复习非递归实现前序遍历</p>
<p>递归：结合范围 注意数字取值的范围</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> lower,<span class="keyword">long</span> <span class="keyword">long</span> upper, TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= lower || root-&gt;val &gt;= upper)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(lower,root-&gt;val,root-&gt;left) &amp;&amp; </span><br><span class="line">        <span class="built_in">check</span>(root-&gt;val,upper,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(LONG_MIN,LONG_MAX,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归的中序遍历</p>
<p>甚至都不需要存队列 只需要保存队列的最后一个值进行比较就可以了</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> inorder = LONG_MIN;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() || root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(inorder&gt;=root-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            inorder = root-&gt;val;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h4><p>复习一下切分递归的方式  广度优先</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoSide</span><span class="params">(TreeNode* ltree,TreeNode* rtree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lDepth=<span class="number">0</span>,rDepth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ltree)</span><br><span class="line">            lDepth = <span class="built_in">twoSide</span>(ltree-&gt;left,ltree-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(rtree)</span><br><span class="line">            rDepth = <span class="built_in">twoSide</span>(rtree-&gt;left,rtree-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(lDepth,rDepth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">twoSide</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其他方法：深度优先递归 不使用全局变量</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left),<span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h4><blockquote>
<p>美区评论区大神 StefanPochmann</p>
<p>Consider the example again. Instead of finding the <code>1</code> in <code>inorder</code>, splitting the arrays into parts and recursing on them, just recurse on the full remaining arrays and <strong>stop</strong> when you come across the <code>1</code> in <code>inorder</code>. That’s what my above solution does. Each recursive call gets told where to stop, and it tells its subcalls where to stop. It gives its own root value as stopper to its left subcall and its parent`s stopper as stopper to its right subcall.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> preIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> partition(Integer.MAX_VALUE+<span class="number">1</span>,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">partition</span><span class="params">(<span class="keyword">int</span> stop,<span class="keyword">int</span>[] preorder,<span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;inorder.length &amp;&amp; inorder[index]!=stop)&#123;</span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preIndex++]);</span><br><span class="line">            root.left = partition(root.val,preorder,inorder);</span><br><span class="line">            <span class="comment">//左子树遍历完成后index指向root</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="comment">//开始遍历右侧 其中右侧应当停下的位置与上一层指定的stop位置相同</span></span><br><span class="line">            <span class="comment">//右侧遍历和左侧一样 先建立左子树 递归思路</span></span><br><span class="line">            root.right = partition(stop,preorder,inorder);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. Binary Tree Level Order Traversal</a></h4><p>一开始想到广度优先的填色法来交替区分不同层次，答案给出了更小空间的做法：统计当前队列中点的个数 只取出这些作为一列 </p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tmp;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; line;</span><br><span class="line">            <span class="keyword">int</span> lineCount = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lineCount;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                line.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>用分而治之的思路来解决这个看似复杂的问题：先搞好根节点 递归的构建子节点</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">partBuild</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="keyword">int</span> rootpos,vector&lt;<span class="keyword">int</span>&gt;&amp;inorder,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;rootpos&lt;&lt;&quot; &quot;&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(rootpos&gt;=preorder.<span class="built_in">size</span>() || rootpos&lt;<span class="number">0</span>)<span class="comment">//|| left&gt;right</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[rootpos]);</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[rootpos]);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;res-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> inpos=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==preorder[rootpos])</span><br><span class="line">            &#123;</span><br><span class="line">                inpos = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftlen = inpos-left;</span><br><span class="line">        <span class="keyword">if</span>(leftlen!=<span class="number">0</span>)<span class="comment">//记得给两个子树加条件 未必有子树</span></span><br><span class="line">            res-&gt;left = <span class="built_in">partBuild</span>(preorder,rootpos+<span class="number">1</span>,inorder,left,inpos<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(inpos+<span class="number">1</span>&lt;=right)<span class="comment">//救命 debug了半天 或者注释掉两个if 在开头加上 </span></span><br><span class="line">            res-&gt;right = <span class="built_in">partBuild</span>(preorder,rootpos+leftlen+<span class="number">1</span>,inorder,inpos+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partBuild</span>(preorder,<span class="number">0</span>,inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>复习preorder</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode*ptr=root;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        vector&lt;TreeNode*&gt; vec;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() || ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">                stk.<span class="built_in">push</span>(ptr);</span><br><span class="line">                ptr=ptr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            ptr=ptr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;vec.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr-&gt;right=vec[i];</span><br><span class="line">            ptr-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">            ptr=ptr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一边遍历一边修改树的难点在于同时保存左右节点的信息</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        TreeNode* prev=<span class="literal">nullptr</span>,*curr=<span class="literal">nullptr</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            curr= stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(prev)</span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">                prev-&gt;right=curr;</span><br><span class="line">            &#125;</span><br><span class="line">            prev=curr;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right)</span><br><span class="line">                stk.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left)</span><br><span class="line">                stk.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最理想的状态是 原地完成 关键是找前驱：<strong>在前序遍历中 左子树最右侧的节点是右子树的前驱</strong></p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)  </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* curr=root,*next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                next=curr-&gt;left;</span><br><span class="line">                <span class="keyword">auto</span> pred = next;</span><br><span class="line">                <span class="keyword">while</span>(pred-&gt;right)</span><br><span class="line">                    pred=pred-&gt;right;</span><br><span class="line">                pred-&gt;right=curr-&gt;right;</span><br><span class="line">                curr-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">                curr-&gt;right=next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum</a></h4><p>利用分治的思想分析的时候还应该考虑完整的情况 比如作为答案最大值有几种来源（根，根和子树之一，绕过根两棵子树，子树），以及作为子树路径最大值有几种可能（根本身，根和其中一棵子树）</p>
<p>多次提交失败中没有注意到的情况：</p>
<p>子树不能增益</p>
<p>根不能增益</p>
<p>最大值来源于：仅有根，根和两棵子树。根和单边子树</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftres=<span class="number">0</span>,rightres=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            leftres = <span class="built_in">reverse</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            rightres = <span class="built_in">reverse</span>(root-&gt;right);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,root-&gt;val+leftres+rightres);<span class="comment">//经过根节点</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans,root-&gt;val);<span class="comment">//只有根节点</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans,<span class="built_in">max</span>(leftres,rightres)+root-&gt;val);<span class="comment">//经过单边</span></span><br><span class="line">        <span class="comment">//ans = max(ans)</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span>(leftres,rightres)&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val+<span class="built_in">max</span>(leftres,rightres);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (root-&gt;val&gt;<span class="number">0</span>)?root-&gt;val:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="*236. Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">*236. Lowest Common Ancestor of a Binary Tree</a></h4><p>递归</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line"><span class="comment">//两侧检查 向上传递 只在有交汇的地方更新 剩下的不管 只管传递</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> lson = <span class="built_in">DFS</span>(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">bool</span> rson = <span class="built_in">DFS</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>((lson &amp;&amp; rson)||</span><br><span class="line">        ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val)&amp;&amp;(lson || rson)) )&#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lson || rson || root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表记录父亲节点 再记录是否被遍历过 出现重复遍历的就返回</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,TreeNode*&gt; father;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            father[root-&gt;left-&gt;val]=root;</span><br><span class="line">            <span class="built_in">DFS</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            father[root-&gt;right-&gt;val]=root;</span><br><span class="line">            <span class="built_in">DFS</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        father[root-&gt;val]=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            visited[p-&gt;val]=<span class="literal">true</span>;</span><br><span class="line">            p = father[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[q-&gt;val]==<span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            q = father[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297. Serialize and Deserialize Binary Tree"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. Serialize and Deserialize Binary Tree</a></h4><p>复习了层次遍历 关键在于存入空指针是无法构成联系的</p>
<p>复习了一些库的使用 包括利用stringstream以指定分割符分割字符串，int和string的互相转换</p>
<h4 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. Path Sum III</a></h4><p>原本的思路 用哈希表记录可能的结果——空间优化 记录需要的</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rootSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum) &#123;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        ret += <span class="built_in">rootSum</span>(root-&gt;left, targetSum - root-&gt;val);</span><br><span class="line">        ret += <span class="built_in">rootSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">rootSum</span>(root, targetSum);</span><br><span class="line">        ret += <span class="built_in">pathSum</span>(root-&gt;left, targetSum);</span><br><span class="line">        ret += <span class="built_in">pathSum</span>(root-&gt;right, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>沿用类似的思路 是否加上自己本身 可以折叠成递归</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//k=true 不包括本节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum,<span class="keyword">bool</span> k=<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root? (</span><br><span class="line">            <span class="built_in">pathSum</span>(root-&gt;left,targetSum-root-&gt;val,<span class="literal">false</span>)</span><br><span class="line">            +<span class="built_in">pathSum</span>(root-&gt;right,targetSum-root-&gt;val,<span class="literal">false</span>) </span><br><span class="line">            +(k?(<span class="built_in">pathSum</span>(root-&gt;left,targetSum,<span class="literal">true</span>)<span class="comment">//有不包括的情况才能计入</span></span><br><span class="line">                +<span class="built_in">pathSum</span>(root-&gt;right,targetSum,<span class="literal">true</span>))</span><br><span class="line">            :<span class="number">0</span>)+(root-&gt;val==targetSum?<span class="number">1</span>:<span class="number">0</span>)</span><br><span class="line">        ):<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//空间打败的多</span></span><br></pre></td></tr></table></figure>

<p>前缀和：记录根节点到当前节点的路径上 除去当前节点自身之外节点和</p>
<p>如果有一个节点n 其前缀和为curr 如果n到root路径上存在p点，前缀和为 curr-targetSum 那么p到n和为targetSum</p>
<p>有类似之前线性的一道题 记录本身 找与目标差值的key的哈希表用法</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">long</span> <span class="keyword">long</span> ,<span class="keyword">int</span>&gt; prefix;<span class="comment">//curr对应的路径条数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">long</span> <span class="keyword">long</span> curr,<span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        curr+=root-&gt;val;<span class="comment">//accumulate</span></span><br><span class="line">        <span class="keyword">if</span>(prefix.<span class="built_in">count</span>(curr-targetSum))</span><br><span class="line">            ret = prefix[curr-targetSum];</span><br><span class="line">        <span class="comment">//search</span></span><br><span class="line">        prefix[curr]++;</span><br><span class="line">        ret+=<span class="built_in">dfs</span>(root-&gt;left,curr,targetSum);</span><br><span class="line">        ret+=<span class="built_in">dfs</span>(root-&gt;right,curr,targetSum);</span><br><span class="line">        prefix[curr]--;<span class="comment">//从当前路径退出 避免干扰其他路径计数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        prefix[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//ini 假设一开始root-&gt;val==targetSum</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root,<span class="number">0</span>,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a></h4><p>分析清除返回值的含义 争取一次bug free</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sideLongest</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">sideLongest</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right= <span class="built_in">sideLongest</span>(root-&gt;right);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,right+left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sideLongest</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="538-Convert-BST-to-Greater-Tree"><a href="#538-Convert-BST-to-Greater-Tree" class="headerlink" title="538. Convert BST to Greater Tree"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a></h4><p>可以原地！按照右中左反中序遍历 只需要累加并且把值赋予节点就可以</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//可以原地</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">convertBST</span>(root-&gt;right);</span><br><span class="line">        sum+=root-&gt;val;</span><br><span class="line">        root-&gt;val=sum;</span><br><span class="line">        <span class="built_in">convertBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></h4><p>深度优先 更简洁</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1)  </span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(!root2)</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root1-&gt;val+root2-&gt;val);</span><br><span class="line">        root-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>广度优先 用牵引避免空指针 小心空指针的条件</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> merged = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(t1-&gt;val + t2-&gt;val);</span><br><span class="line">        <span class="keyword">auto</span> q = queue&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">auto</span> queue1 = queue&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">auto</span> queue2 = queue&lt;TreeNode*&gt;();</span><br><span class="line">        q.<span class="built_in">push</span>(merged);</span><br><span class="line">        queue1.<span class="built_in">push</span>(t1);</span><br><span class="line">        queue2.<span class="built_in">push</span>(t2);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.<span class="built_in">empty</span>() &amp;&amp; !queue2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(), node1 = queue1.<span class="built_in">front</span>(), node2 = queue2.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            queue1.<span class="built_in">pop</span>();</span><br><span class="line">            queue2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">auto</span> left1 = node1-&gt;left, left2 = node2-&gt;left, right1 = node1-&gt;right, right2 = node2-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (left1 != <span class="literal">nullptr</span> || left2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left1 != <span class="literal">nullptr</span> &amp;&amp; left2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(left1-&gt;val + left2-&gt;val);</span><br><span class="line">                    node-&gt;left = left;</span><br><span class="line">                    q.<span class="built_in">push</span>(left);</span><br><span class="line">                    queue1.<span class="built_in">push</span>(left1);</span><br><span class="line">                    queue2.<span class="built_in">push</span>(left2);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    node-&gt;left = left1;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    node-&gt;left = left2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right1 != <span class="literal">nullptr</span> || right2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right1 != <span class="literal">nullptr</span> &amp;&amp; right2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(right1-&gt;val + right2-&gt;val);</span><br><span class="line">                    node-&gt;right = right;</span><br><span class="line">                    q.<span class="built_in">push</span>(right);</span><br><span class="line">                    queue1.<span class="built_in">push</span>(right1);</span><br><span class="line">                    queue2.<span class="built_in">push</span>(right2);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    node-&gt;right = right1;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node-&gt;right = right2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. Binary Tree Zigzag Level Order Traversal</a></h4><p>注意是整体的排序 需要用到栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            Stack&lt;TreeNode&gt; nextline = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">                TreeNode node = stk.pop();</span><br><span class="line">                <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(cnt%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                        nextline.push(node.left);</span><br><span class="line">                        nextline.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        nextline.push(node.right);</span><br><span class="line">                        nextline.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!list.isEmpty())</span><br><span class="line">                ans.add(list);</span><br><span class="line">            stk.addAll(nextline);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更简单的办法：层序遍历 在最终结果中取奇数位置的list倒序遍历</p>
<h4 id="987-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#987-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="987. Vertical Order Traversal of a Binary Tree"></a><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. Vertical Order Traversal of a Binary Tree</a></h4><p>自定义排序</p>
<p>注意自定排序的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="number">0</span>,<span class="number">0</span>,nodes);</span><br><span class="line">        Collections.sort(nodes,<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] tuple1,<span class="keyword">int</span>[] tuple2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tuple1[<span class="number">0</span>]!=tuple2[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">return</span> tuple1[<span class="number">0</span>]-tuple2[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tuple1[<span class="number">1</span>]!=tuple2[<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">return</span> tuple1[<span class="number">1</span>]-tuple2[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span>    </span><br><span class="line">                    <span class="keyword">return</span> tuple1[<span class="number">2</span>]-tuple2[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastCol = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] tuple : nodes)&#123;</span><br><span class="line">            <span class="keyword">int</span> col = tuple[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> row = tuple[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> val = tuple[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(col!=lastCol)&#123;</span><br><span class="line">                lastCol = col;</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.get(size-<span class="number">1</span>).add(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> row,<span class="keyword">int</span> col,List&lt;<span class="keyword">int</span>[]&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] info = &#123;col,row,root.val&#125;;  </span><br><span class="line">        nodes.add(info);</span><br><span class="line">        dfs(root.left,row+<span class="number">1</span>,col-<span class="number">1</span>,nodes);</span><br><span class="line">        dfs(root.right,row+<span class="number">1</span>,col+<span class="number">1</span>,nodes);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Algo</tag>
      </tags>
  </entry>
  <entry>
    <title>tunneling socket could not established， cause = getaddrinfo ENOTFOUND 解决方案</title>
    <url>/post/d0b95d98/</url>
    <content><![CDATA[<p>这个错误同时在PicGo上传图片和我登陆科学上网小工具的时候出现。一开始在科学上网工具出现的时候没当回事，以为是工具本身问题，再次出现发现不对劲，应该配置问题。</p>
<p>感谢谷歌,让我翻到一个<a href="https://www.lifeee.top/posts/1004.html">参考解决方案</a>。</p>
<p>因为不是PicGo本身的问题，所以搜索到的调整PicGo的方案都不符合我的要求，最后发现是当前用户的系统变量莫名其妙多出来一个https的环境变量，删除以后解决。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title>新世界大门大开-几款编程相关工具</title>
    <url>/post/c0898a4d/</url>
    <content><![CDATA[<h2 id="plantuml"><a href="#plantuml" class="headerlink" title="plantuml"></a>plantuml</h2><p>一个绘制类图，时序图的在线<a href="https://plantuml.com/zh/starting">网站</a>，支持生成在线的url，无需登录。</p>
<p>和其他工具不太一样的是，输入主要依靠代码描述，和拖拽相比感觉很酷（x</p>
<h2 id="asciinema"><a href="#asciinema" class="headerlink" title="asciinema"></a>asciinema</h2><p><a href="https://asciinema.org/">终端录制工具</a>，可以把终端的动画保存在网站云端，可以获取url插入markdown，但是大小有限制，超过5M左右就无法顺利上传。邮箱可以直接注册登陆。</p>
<p>可以在命令行安装，但是不支持windows，macOS和linux都可以。</p>
<h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>一个图床工具，支持github，gitee，七牛腾讯等等云床，可以内嵌进入markdown。</p>
<h2 id="localtunnel"><a href="#localtunnel" class="headerlink" title="localtunnel"></a>localtunnel</h2><p>在自己本地测试服务器的时候，如果需要外部网络访问被测试的网站和服务器，可以用这个<a href="https://localtunnel.github.io/www/">工具</a>生成网址。</p>
<p>先安装，然后启动工具获得外网网址</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
  </entry>
  <entry>
    <title>Algo Revised: Dynamic Programing</title>
    <url>/post/9120db44/</url>
    <content><![CDATA[<h4 id="Longest-ZigZag-Path-in-a-Binary-Tree"><a href="#Longest-ZigZag-Path-in-a-Binary-Tree" class="headerlink" title="Longest ZigZag Path in a Binary Tree"></a><a href="https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/">Longest ZigZag Path in a Binary Tree</a></h4><p>尾递归的构建方式 在参数当中完成运算。</p>
<p>本题最优解不依赖于子问题的解，因为有可能子问题中出现最大解但是对于父问题来说不符合加1的要求，例如最长Z路径出现在中间段，所以采用外部设置全局变量比较更新的方法</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tail_recusion</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">int</span> direct,TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen,len);</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(direct==<span class="number">1</span>)<span class="comment">//上一次走的是右侧 即当前节点是父节点的右子树</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                    <span class="built_in">tail_recusion</span>(len+<span class="number">1</span>,<span class="number">0</span>,root-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                    <span class="built_in">tail_recusion</span>(<span class="number">1</span>,<span class="number">1</span>,root-&gt;right);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span><span class="comment">//当前节点是父节点的左子树</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                    <span class="built_in">tail_recusion</span>(<span class="number">1</span>,<span class="number">0</span>,root-&gt;left);<span class="comment">//1 是为了在下一层中记录本层的位置</span></span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                    <span class="built_in">tail_recusion</span>(len+<span class="number">1</span>,<span class="number">1</span>,root-&gt;right);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">tail_recusion</span>(<span class="number">0</span>,<span class="number">0</span>,root);</span><br><span class="line">        <span class="built_in">tail_recusion</span>(<span class="number">0</span>,<span class="number">1</span>,root);</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="887-Super-Egg-Drop"><a href="#887-Super-Egg-Drop" class="headerlink" title="887. Super Egg Drop"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/">887. Super Egg Drop</a></h4><p>重点:描述出状态 找到状态转移方程 本题特征: 利用函数的单调性来逼近答案（这是本题规划的部分）</p>
<img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20210526153430141.png" alt="image-20210526153430141" style="zoom: 50%;">

<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20210526153443782.png" alt="image-20210526153443782"></p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; memo;<span class="comment">//dp中用于存储的字典</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">find</span>(<span class="number">100</span>*n+k)==memo.<span class="built_in">end</span>())<span class="comment">//找不到</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">                ans=n;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">                ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> low =<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> high=n;</span><br><span class="line">                <span class="keyword">while</span>(low+<span class="number">1</span>&lt;high)<span class="comment">//是离散的点 所以只能用间隔逼近</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> t1 = <span class="built_in">dp</span>(k,n-x);</span><br><span class="line">                    <span class="keyword">int</span> t2 = <span class="built_in">dp</span>(k<span class="number">-1</span>,x<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(t1&gt;t2)</span><br><span class="line">                        low = x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(t1&lt;t2)</span><br><span class="line">                        high=x;</span><br><span class="line">                    <span class="keyword">else</span>    </span><br><span class="line">                        low = high = x;</span><br><span class="line">                &#125;</span><br><span class="line">                ans=<span class="number">1</span>+<span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">dp</span>(k,n-low),<span class="built_in">dp</span>(k<span class="number">-1</span>,low<span class="number">-1</span>)),<span class="built_in">max</span>(<span class="built_in">dp</span>(k,n-high),<span class="built_in">dp</span>(k<span class="number">-1</span>,high<span class="number">-1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            memo[<span class="number">100</span>*n+k]=ans;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">100</span>*n+k];<span class="comment">//利用一个函数映射 把二维降为一维存储</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(K,N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>20220118 树状分析改为动态规划：二分法想到的是对的 最后本质采用了二分查找；压缩的本质是 m~n可以用n-m来表示</p>
<h4 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. Palindrome Partitioning</a></h4><p>回溯法写对了 关键在于去除冗余计算</p>
<p>在判断回文串的时候有冗余 dp判断是否是回文串</p>
<p>如果直接采用课堂上二维矩阵的方式来记录的话，需要分配的空间过大</p>
<p> <strong>dp判断s[i]~s[j]是否是回文串</strong></p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; jdg;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;s.<span class="built_in">size</span>();++j)</span><br><span class="line">            &#123;            </span><br><span class="line">                jdg[i][j]=(s[i]==s[j])&amp;&amp;jdg[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//转移方程依赖[i+1][j-1] 从末尾往前</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        jdg.<span class="built_in">assign</span>(len,vector&lt;<span class="keyword">bool</span>&gt;(len,<span class="literal">true</span>));<span class="comment">//学到新函数 注意初始化 i&gt;=j 时都为真 边缘是i+1和j-1交错 此时依赖于i+1和j-1字符是否相等 因此应该设置为true</span></span><br><span class="line">        <span class="built_in">judge</span>(s);</span><br><span class="line">        vector&lt;string&gt; set;</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">0</span>,s,set);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> left,string s,vector&lt;string&gt;&amp; set)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=s.<span class="built_in">size</span>())</span><br><span class="line">            ans.<span class="built_in">push_back</span>(set);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;s.<span class="built_in">size</span>();++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(jdg[left][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    set.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(left,i-left+<span class="number">1</span>));</span><br><span class="line">                    <span class="built_in">backtrace</span>(i+<span class="number">1</span>,s,set);</span><br><span class="line">                    set.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>时间代价：</strong>字符串长度为n，若每个字符都一样，则有2^(n-1) = O(2^n) 的分法，而每种分发都需要遍历一次字符串来获得对应的划分，加上动态规划的代价</p>
<p>O(n*2^n+n^2)=O(n*2^n)</p>
<p><strong>空间代价</strong> dp的数组 O(n^2)</p>
<p>变式 <a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132. Palindrome Partitioning II</a></p>
<p>基于上一题的思路 就是在回溯具体切分的过程中做统计 每次到底得到答案的时候记录切分次数，在切分回溯的过程中利用已经有的答案做出剪枝</p>
<p>还有一个更快的思路是只统计次数 不在乎情况</p>
<p>不要贪心 思路是对的 先用dp求出回文的情况，计算最小分割数的时候的方程是互相依赖的且是一维的 在用上述标记做一次dp</p>
<p>取决于问题是从后往前分析还是从前往后；如果数组定义为从0到位置i需要的最短分割，那么是从前往后（注意！！）数组的定义会影响到问题规划的方式</p>
<p>方程：s[0][i]是回文的话 memo[i]=0 因为无需分割，否则对于j=[0,i], 找到一个最小的memo[j]+1 在此处使用了贪心的解法</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; jdg;</span><br><span class="line">        memo.<span class="built_in">resize</span>(s.<span class="built_in">size</span>(),s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        jdg.<span class="built_in">assign</span>(s.<span class="built_in">size</span>(),vector&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">size</span>(),<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;s.<span class="built_in">size</span>();++j)</span><br><span class="line">                jdg[i][j]=(s[i]==s[j])&amp;&amp;jdg[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(jdg[<span class="number">0</span>][i])</span><br><span class="line">                memo[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)</span><br><span class="line">                    <span class="keyword">if</span>(jdg[j+<span class="number">1</span>][i])</span><br><span class="line">                        memo[i]=(memo[i]&gt;memo[j]+<span class="number">1</span>)?(memo[j]+<span class="number">1</span>):memo[i];</span><br><span class="line">            <span class="comment">//转移方程中 更小的值可能已经被记录 要维持最小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>变式  <a href="https://leetcode-cn.com/problems/palindrome-partitioning-iii/">1278. Palindrome Partitioning III</a></p>
<p>采用同样的预处理，changed[i][j]表示从s[i]到s[j]若修改为字符串需要修改的字符个数，转移方程只需要在判断的基础上略作修改即可。原本考虑用递归来表示待分割的次数k，但是这也转换为一个二维空间 </p>
<blockquote>
<p>为什么changed是二维而不是一维——因为同一层循环可能有不同的分割点</p>
</blockquote>
<p>定义 minch[m][i] 还有m次分割机会（很重要！划重点！）下，从0号位置到i号位置最少改变的字符数</p>
<p>卡在的地方: 解决问题的思路（明确有二维的变量），m的取值（一开始搞成了k+1，k+1是用在不包括0的计数的情况，这里的确只有0~k），内部规划的时候 j 和 i 的关系，注意分割的时候要从下一个字符开始</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;b)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">palindromePartition</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; changed;</span><br><span class="line">    changed.<span class="built_in">assign</span>(len, vector&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                changed[i][j] = changed[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                changed[i][j] = changed[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//再次出现的回文处理方式</span></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; minch;</span><br><span class="line">    minch.<span class="built_in">assign</span>(k, vector&lt;<span class="keyword">int</span>&gt;(len, INT_MAX - <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        minch[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; ++m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;m &quot; &lt;&lt; m &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                minch[<span class="number">0</span>][i] = changed[<span class="number">0</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; minch[m - 1][j] &lt;&lt; &quot; &quot; &lt;&lt; changed[j + 1][i] &lt;&lt; endl;</span></span><br><span class="line">                    minch[m][i] = <span class="built_in">min</span>(minch[m][i], minch[m - <span class="number">1</span>][j] + changed[j + <span class="number">1</span>][i]);<span class="comment">//记住留下最小值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for (int i = 0; i &lt; k; ++i)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt; len; ++j)</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; minch[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; endl;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minch[k<span class="number">-1</span>][len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>变式 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></p>
<p>在原本架构上增加全局变量找最大值 一开始脑子转不过来没有意识到本质是变式。可以接机复习回文串的动态规划架构</p>
<p>在规划顺序卡住，取决于如何分解问题：可以长度由小到大显式：</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20210713201525528.png" alt="image-20210713201525528"></p>
<p>也可以采用如下：右侧限定了左侧，右侧从小到大，左侧从最左开始填写</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>,start=<span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">judge</span>(len,vector&lt;<span class="keyword">bool</span>&gt;(len));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right=<span class="number">0</span>;right&lt;len;++right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>;left&lt;=right;++left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[left]!=s[right])  </span><br><span class="line">                &#123;</span><br><span class="line">                    judge[left][right]=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;=<span class="number">2</span>)</span><br><span class="line">                    judge[left][right]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    judge[left][right]=judge[left+<span class="number">1</span>][right<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(judge[left][right] &amp;&amp; right+<span class="number">1</span>-left&gt;maxlen)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen=right+<span class="number">1</span>-left;</span><br><span class="line">                    start=left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最初想到的：中心扩散法</p>
<p>可以优化的地方是：在剩余的长度小于maxlen/2的时候停止，因为此时不可能再有回文串比现行最大长度回文串要长；出现重复字符的时候移动指针直到下一个字符不重复，相当于根据重复字符也是回文串把重复部分压缩，然后再照常判断</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>,start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(len-i&lt;=maxlen/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//长度为1或0必是回文 且不会再有比现行答案更长的回文串 可以早点结束</span></span><br><span class="line">            <span class="keyword">int</span> left=i,right=i;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;len<span class="number">-1</span> &amp;&amp; s[right]==s[right+<span class="number">1</span>])</span><br><span class="line">                right++;<span class="comment">//确认核心</span></span><br><span class="line">            i=right+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;len<span class="number">-1</span> &amp;&amp; left&gt;<span class="number">0</span> &amp;&amp; s[left<span class="number">-1</span>]==s[right+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxlen&lt;right+<span class="number">1</span>-left)</span><br><span class="line">            &#123;</span><br><span class="line">                maxlen=right+<span class="number">1</span>-left;</span><br><span class="line">                start=left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start,maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>变式：<a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. Palindromic Substrings</a></p>
<p>评论区RoundOne的dp解法很简洁 学习</p>
<h4 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a><a href="https://leetcode-cn.com/problems/word-break/">139. Word Break</a></h4><p>遇到可以匹配的词就切分并且以切分后的字串为开头继续切分 但该思路的本质是贪心策略，</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">judge</span><span class="params">(len+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        judge[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(wordDict.<span class="built_in">begin</span>(),wordDict.<span class="built_in">end</span>(),str)!=wordDict.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(judge[i+<span class="number">1</span>-cnt])</span><br><span class="line">                &#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;i &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;str &quot;</span>&lt;&lt;str&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;cnt &quot;</span>&lt;&lt;cnt&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    judge[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                    cnt=<span class="number">0</span>;</span><br><span class="line">                    str.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judge[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;aaaaaaa&quot;</span></span><br><span class="line"><span class="comment">[&quot;aaaa&quot;,&quot;aaa&quot;]</span></span><br><span class="line"><span class="comment">My output:false</span></span><br><span class="line"><span class="comment">Expected:true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>动态规划 一维</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt;<span class="built_in">judge</span>(len+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">        judge[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                string str = s.<span class="built_in">substr</span>(j,i+<span class="number">1</span>-j);</span><br><span class="line">                <span class="keyword">if</span>(!judge[i+<span class="number">1</span>]&amp;&amp;<span class="built_in">find</span>(wordDict.<span class="built_in">begin</span>(),wordDict.<span class="built_in">end</span>(),str)!=wordDict.<span class="built_in">end</span>())<span class="comment">//有可分割的情况就不再判断</span></span><br><span class="line">                &#123;</span><br><span class="line">                    judge[i+<span class="number">1</span>]=judge[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:judge)</span><br><span class="line">            cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> judge[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. Regular Expression Matching</a></h4><p>关键在于意识到需要用到动态规划才能解决问题，是在测试用例</p>
<p>s=”aab” p=”ac*a*b”的时候意识到的</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> match=[&amp;](<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="comment">//除了[0][0]之外，其他意味着空串匹配非空串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>];</span><br><span class="line">        &#125;;<span class="comment">//注意边界条件 judge[0][0]=true 是初始条件</span></span><br><span class="line">        <span class="keyword">int</span> m=s.<span class="built_in">size</span>(),n=p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">judge</span>(m+<span class="number">1</span>,vector&lt;<span class="keyword">bool</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        judge[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    judge[i][j]=judge[i][j<span class="number">-2</span>];<span class="comment">//是否需要星号</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">match</span>(i,j<span class="number">-1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        judge[i][j]=judge[i<span class="number">-1</span>][j]||judge[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">match</span>(i,j))</span><br><span class="line">                    &#123;</span><br><span class="line">                        judge[i][j]=judge[i<span class="number">-1</span>][j<span class="number">-1</span>]||judge[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judge[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title=" Letter Combinations of a Phone Number"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/"> Letter Combinations of a Phone Number</a></h4><p>直接做法是哈希表硬记忆，后用回溯</p>
<p>这里看到了一个技巧做法：统计出所有可能性（本身是连乘），然后根据计数规律来构造</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        vector&lt;string&gt; dict=&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>,size=digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digits.<span class="built_in">size</span>();++i)</span><br><span class="line">            len=len*dict[digits[i]-<span class="string">&#x27;0&#x27;</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> last=i;</span><br><span class="line">            string str;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=size<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> c = digits[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> pos = last%dict[c].<span class="built_in">size</span>();</span><br><span class="line">                last/=dict[c].<span class="built_in">size</span>();<span class="comment">//这两句决定了外层的循环是倒序并且最后需要reverse</span></span><br><span class="line">                str.<span class="built_in">push_back</span>(dict[c][pos]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类似题：</p>
<h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a><a href="https://leetcode-cn.com/problems/permutations/">46. Permutations</a></h4><p>上述编号取余的方法并没有比回溯法更加高效 但是学习了unique的用法 返回一个迭代器 从begin到该迭代器 只有一个元素重复出现一次 即对于不重复出现的部分 返回的迭代器相当于end()</p>
<p>回溯法 注意是引用 要创建新的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>.n=nums.length;</span><br><span class="line">        <span class="keyword">this</span>.res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">            output.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        backtrace(output,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(List&lt;Integer&gt; output,<span class="keyword">int</span> first)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first==n)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(output));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;n;++i)&#123;</span><br><span class="line">            Collections.swap(output,first,i);</span><br><span class="line">            backtrace(output,first+<span class="number">1</span>);</span><br><span class="line">            Collections.swap(output,first,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. Generate Parentheses</a></h4><p>一个简单的回溯 关键是控制配对</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">char</span> ch,string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left--,right--;</span><br><span class="line">            str.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">reverse</span>(left,right,<span class="string">&#x27;(&#x27;</span>,str);</span><br><span class="line">            <span class="keyword">if</span>(right&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">reverse</span>(left,right,<span class="string">&#x27;)&#x27;</span>,str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right++;</span><br><span class="line">            str.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">reverse</span>(left,right,<span class="string">&#x27;(&#x27;</span>,str);</span><br><span class="line">            <span class="keyword">if</span>(right&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">reverse</span>(left,right,<span class="string">&#x27;)&#x27;</span>,str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(n,<span class="number">0</span>,<span class="string">&#x27;(&#x27;</span>,str);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32. Longest Valid Parentheses"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. Longest Valid Parentheses</a></h4><p>一开始想用栈做 但是实际情况更复杂 没有考虑括号套娃的情况</p>
<p>dp版：关键在于 完整的子串必定是右括号结尾，所以状态转移只需要关注右括号，左括号结尾的子串长度必定是0（全初始化为0就可以） 有两种转移状态 成对和套娃 小心下标合法性的判断</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    dp[i]=<span class="number">2</span>+((i&lt;<span class="number">2</span>)?<span class="number">0</span>:dp[i<span class="number">-2</span>]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]&gt;<span class="number">0</span> &amp;&amp; s[i<span class="number">-1</span>-dp[i<span class="number">-1</span>]]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        dp[i]=<span class="number">2</span>+dp[i<span class="number">-1</span>]+((i<span class="number">-2</span>-dp[i<span class="number">-1</span>]&lt;<span class="number">0</span>)?<span class="number">0</span>:dp[i<span class="number">-2</span>-dp[i<span class="number">-1</span>]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max=(dp[i]&gt;max)?dp[i]:max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>栈：</p>
<p>一开始使用更多的是对符号本身是否匹配，这里改成存下标，以来通过下标的信息可以判断是否匹配，二来下标差可以直接求出子串长</p>
<p>这里栈底是最后一个没有被匹配的右括号的下标，之上都是可以被匹配的左括号初始化采用-1可以在开头不是右括号的情况下完成补全。</p>
<p>需要注意的细节：</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>,len=s.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                stk.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())</span><br><span class="line">                        max = (i-stk.<span class="built_in">top</span>()&gt;max)?i-stk.<span class="built_in">top</span>():max;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        stk.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    stk.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. Combination Sum</a></h4><p>卡在了具体实现上（本质就是部分和问题）</p>
<p>动态规划 巧用stl库</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &gt;dict;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it:candidates)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(it==i)</span><br><span class="line">                    dict[i].<span class="built_in">insert</span>(&#123;it&#125;);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> vec:dict[i-it])<span class="comment">//为空会跳过</span></span><br><span class="line">                    <span class="comment">//没有引用符号 不会修改原来的vector</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        vec.<span class="built_in">push_back</span>(it);</span><br><span class="line">                        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">                        <span class="keyword">if</span>(dict[i].<span class="built_in">count</span>(vec)==<span class="number">0</span>)<span class="comment">//绝妙 其中的元素vector比较符号被重载了</span></span><br><span class="line">                            dict[i].<span class="built_in">insert</span>(vec);<span class="comment">//没有就加入</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:dict[target])</span><br><span class="line">            ans.<span class="built_in">push_back</span>(it);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回溯法</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; candi;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; res,<span class="keyword">int</span> remain)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>(),res)==ans.<span class="built_in">end</span>())</span><br><span class="line">                ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : candi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(it&gt;remain)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(it);</span><br><span class="line">            <span class="built_in">backtrace</span>(res,remain-it);</span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        candi = candidates;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">backtrace</span>(res,target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. Minimum Path Sum</a></h4><p>dp和记忆化搜索都可以</p>
<p>dp</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.<span class="built_in">size</span>(),n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        dp[m<span class="number">-1</span>][n<span class="number">-1</span>]=grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            dp[i][n<span class="number">-1</span>]=grid[i][n<span class="number">-1</span>]+dp[i+<span class="number">1</span>][n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            dp[m<span class="number">-1</span>][i]=grid[m<span class="number">-1</span>][i]+dp[m<span class="number">-1</span>][i+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化只能向右和只能向下的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-2</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>记忆化搜索另外一题：<a href="https://leetcode-cn.com/problems/unique-paths/">62. Unique Paths</a></p>
<h4 id="221-Maximal-Square"><a href="#221-Maximal-Square" class="headerlink" title="221. Maximal Square"></a><a href="https://leetcode-cn.com/problems/maximal-square/">221. Maximal Square</a></h4><p>dp的含义：以ij为右下角的正方形的最大边长</p>
<p>依赖于左上方 左方 上方是否是正方形 为了统计数量方便 也可以理解为依赖于左上方 左方 上方正方形边长大小 缺一不可 所以要取三者最小值 注意边界情况（在图形边界）</p>
<p>可以解释为什么要考虑左侧上侧的最小值</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20210915113432534.png" alt="image-20210915113432534"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(columns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;<span class="comment">//不仅是判断 还要计数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = <span class="built_in">max</span>(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. Perfect Squares</a></h4><p>内层循环是在动态规划解法中是不可避免的 相信自己!</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> minn=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*j&lt;=i;++j)<span class="comment">//用于找最优</span></span><br><span class="line">                minn = <span class="built_in">min</span>(minn,dp[i-j*j]);</span><br><span class="line">            dp[i]=minn+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BFS 减去比自己小的完全平方数 成为树的节点</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">        visited.<span class="built_in">emplace</span>(n);</span><br><span class="line">        que.<span class="built_in">push</span>(n);</span><br><span class="line">        <span class="keyword">int</span> level=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> num = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j*j&lt;=num;++j)&#123;<span class="comment">//找多种可能性</span></span><br><span class="line">                    <span class="keyword">int</span> residual = num-j*j;</span><br><span class="line">                    <span class="keyword">if</span>(residual==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(visited.<span class="built_in">count</span>(residual)==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited.<span class="built_in">emplace</span>(residual);</span><br><span class="line">                        que.<span class="built_in">push</span>(residual);</span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. Maximum Product Subarray</a></h4><p>最长子序列的变体 关键在于从动态规划的思路理清</p>
<p>最大除了符号反转之外还有重新开始的可能（<code>nums[i]</code>自身）</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minp=nums[<span class="number">0</span>],maxp=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> tmpmax=<span class="number">0</span>,tmpmin=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpmax=maxp;</span><br><span class="line">            tmpmin=minp;</span><br><span class="line">            maxp = <span class="built_in">max</span>(nums[i],<span class="built_in">max</span>(tmpmax*nums[i],tmpmin*nums[i]));</span><br><span class="line">            minp = <span class="built_in">min</span>(nums[i],<span class="built_in">min</span>(tmpmax*nums[i],tmpmin*nums[i]));</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,maxp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. Longest Increasing Subsequence</a></h4><p>和最大子串和 最大子串积是同类</p>
<p>动态规划 有重复遍历</p>
<p>贪心+二分查找——上升的尽可能慢 长度为j的最小末尾作为状态记录 遍历到一个数用二分查找来更新（可以证明最小末尾数据是递增的）</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        d[len]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;d[len])</span><br><span class="line">                d[++len]=nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l=<span class="number">1</span>,r=len;</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;<span class="comment">//如果都没有找到 说明所有前面的数都比当前数大</span></span><br><span class="line">                <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(d[mid]&lt;nums[i])&#123;<span class="comment">//在记录中查找</span></span><br><span class="line">                        pos = mid;<span class="comment">//尽量向大的靠近 因此先赋值给pos </span></span><br><span class="line">                        l=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>    </span><br><span class="line">                        r=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;<span class="comment">//二分查找 目标是找到d[pos]&lt;nums[i] &amp;&amp; d[pos+1]&gt;nums[i]</span></span><br><span class="line">                d[pos+<span class="number">1</span>]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. Best Time to Buy and Sell Stock with Cooldown</a></h4><p><strong>How to come up with the idea that using dynamic programming?</strong></p>
<p>multiple states+rely on state of previous day</p>
<p>Because it has three different decisions in one day, dp vector should be two-dimension.</p>
<p>To optimize the space, we notice that every step is only dependent to its previous one step. So we can use single variable instead of vector to memorize states. In this way the memory used is back to one dimension but it is a bit different to my original thought, which only consider the time series.</p>
<p>Another point is to figure out how the state changes with cool-down.  Devide the state into three situations: stock, not stock and cool, not stocking and not cool.</p>
<p>For day i, Stock means you have bought stocks previous day, so state is same as day i-1 stock. Or you bought it today, which means you cannot cool down and have stocks yesterday. So it is not stock and not cool plus your cost of buying stocks.</p>
<p>For day i, not stock and not cool means you have no stocks yesterday ( same as day i-1 no-stocks-no-cool);or you are cool down yesterday.</p>
<p>For day i, not stock and cool means you sold your stocks yesterday, which is day i-1 stock plus the price you sold them.</p>
<p>Besides, for initialization, stock means you bought stocks on that day, so it’s minus.  It’s impossible for first day to be cool-down but we still set it zero,same as no-stocks-no-cool. We can take it as sell at 0 before.</p>
<p>Last, it’s meaningless to have stocks at last day, so the answer comes from cool-down and no-stocks-no-cool.</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> stock=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cool = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nsnc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> newst = <span class="built_in">max</span>(stock,nsnc-prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newcool = stock+prices[i];</span><br><span class="line">            <span class="keyword">int</span> newnsnc = <span class="built_in">max</span>(nsnc,cool);</span><br><span class="line">            stock = newst;</span><br><span class="line">            cool = newcool;</span><br><span class="line">            nsnc = newnsnc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(cool,nsnc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. House Robber</a></h4><p>小心初始化的时候 第二个位置是取前两个的最大值</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);<span class="comment">//attention</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(nums[i]+dp[i<span class="number">-2</span>],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现 实际上只需要存前两栋房屋的最大值就可以了 再往前的不需要</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> house1=<span class="number">0</span>,house2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            house1 = nums[<span class="number">0</span>];</span><br><span class="line">            house2 = <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=house2;<span class="comment">//不能设置为0 否则nums.size()==2时出错</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(house1+nums[i],house2);</span><br><span class="line">            house1 = house2;</span><br><span class="line">            house2=ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="337-House-Robber-III"><a href="#337-House-Robber-III" class="headerlink" title="337. House Robber III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. House Robber III</a></h4><p>曾经的算法题复习 是否要取状态要记录</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;TreeNode*,<span class="keyword">int</span>&gt; yes;</span><br><span class="line">    unordered_map&lt;TreeNode*,<span class="keyword">int</span>&gt; no;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">robPlan</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            yes[root]=root-&gt;val;</span><br><span class="line">            no[root]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">robPlan</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">robPlan</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        yes[root]=root-&gt;val+no[root-&gt;left]+no[root-&gt;right];</span><br><span class="line">        no[root]=<span class="built_in">max</span>(yes[root-&gt;left],no[root-&gt;left])+<span class="built_in">max</span>(yes[root-&gt;right],no[root-&gt;right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">robPlan</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(yes[root],no[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="312-Burst-Balloons"><a href="#312-Burst-Balloons" class="headerlink" title="312. *Burst Balloons"></a><a href="https://leetcode-cn.com/problems/burst-balloons/">312. *Burst Balloons</a></h4><p>memorized search</p>
<p>if deleting ballon, two non-adjacent balloons will become adjacent. So we can take deletion as addition(Last one deleted). And use addtion to partition. Try every possible solution to find out currently max count.</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; rec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right<span class="number">-1</span>)<span class="comment">//open interval </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(rec[left][right]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> mid=left+<span class="number">1</span>;mid&lt;right;++mid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> sum=val[left]*val[right]*val[mid];</span><br><span class="line">                sum+=<span class="built_in">solve</span>(left,mid)+<span class="built_in">solve</span>(mid,right);</span><br><span class="line">                rec[left][right]=<span class="built_in">max</span>(rec[left][right],sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="comment">//take deletion as addition</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        val.<span class="built_in">resize</span>(n+<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            val[i]=nums[i<span class="number">-1</span>];</span><br><span class="line">        val[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        val[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        rec.<span class="built_in">resize</span>(n+<span class="number">2</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">2</span>,<span class="number">-1</span>));<span class="comment">//-1 means not calculated</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(<span class="number">0</span>,n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Change the sequence to calculate. So we have dynamic programming.</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">val</span><span class="params">(n+<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            val[i]=nums[i<span class="number">-1</span>];</span><br><span class="line">        val[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        val[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">rec</span>(n+<span class="number">2</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)<span class="comment">//left</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;=n+<span class="number">1</span>;++j)<span class="comment">//right</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;++k)<span class="comment">//mid</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=val[i]*val[k]*val[j];</span><br><span class="line">                    sum+=rec[i][k]+rec[k][j];</span><br><span class="line">                    rec[i][j]=<span class="built_in">max</span>(sum,rec[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[<span class="number">0</span>][n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum</a></h4><p>一个背包问题 转换为所有值的一半 应该复习的问题 算法课出现过</p>
<p>背包问题用一维是解决不了的 因为需要记录目前加了什么值</p>
<p><code>dp[i][j]</code>的含义 对目标<code>j</code>数组里的前<code>i</code>个数是否能满足</p>
<p>由于只求一半 所以j的范围在0~target就可以 即数组建立为target+1</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxNum=*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(sum &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//是奇数</span></span><br><span class="line">        <span class="keyword">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(maxNum&gt;target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//最大数比一半还大 不可能</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n,vector&lt;<span class="keyword">int</span>&gt;(target+<span class="number">1</span>，<span class="number">0</span>));<span class="comment">//不写0剩下也默认是false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="literal">true</span>;<span class="comment">//initialise 小心转移方程和初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>]]=<span class="literal">true</span>;<span class="comment">//0~0 谁都可以 这是起点 需要为真 ！！！！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num=nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;++j)<span class="comment">//从左到右填表</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=num)</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j]|dp[i<span class="number">-1</span>][j-num];</span><br><span class="line">                <span class="comment">//可以不选这个数 或者选了转译成另一个数</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="comment">//不能选 只能看上一个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. Target Sum</a></h4><p>一开始想到的逐个和累加没有排除负数 </p>
<p>列的大小只与目标有关 转换目标</p>
<p>用公式转换 凑需要是负数的和</p>
<p><code>dp[i][j]</code>的含义是前i个数凑出来负数和是j的方法数</p>
<p>neg没有也是一种情况</p>
<p>想明白传一方程:是累加</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum= <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((sum-target)%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//排除一些不可能情况</span></span><br><span class="line">        <span class="keyword">int</span> neg = (sum-target)/<span class="number">2</span>;<span class="comment">//(sum-neg)-neg==target</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(neg+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)<span class="comment">//0：不需要数字 </span></span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=neg;++j)<span class="comment">//0 和倒扣到0 注意初始化的方向 要包括0 eg [1,0] 1</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(j-nums[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]+=dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>空间优化</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> delta = sum-target;</span><br><span class="line">        <span class="keyword">if</span>(delta%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> neg = delta/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//优化 只与上一行有关</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(neg+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=neg;j&gt;=n;--j)<span class="comment">//从后往前 因为依赖前面的数据 不能覆盖 同时注意下标</span></span><br><span class="line">                dp[j]+=dp[j-n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. Coin Change</a></h4><p>When using dynamic programing, vector can be initialized to be amount+1. Such impossible value can avoid INT_MAX overflow when calculating.</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,amount+<span class="number">2</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//因为不限次数 所以dp[i]代表amount=i时的方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> n:coins)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i-n&gt;=<span class="number">0</span>)</span><br><span class="line">                    dp[i]=<span class="built_in">min</span>(dp[i],dp[i-n]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==amount+<span class="number">2</span>?<span class="number">-1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><p>注意返回的答案应当是f_n_1（Fn-1）；以及按照题目要求每个答案都要取模</p>
<h4 id="1048-Longest-String-Chain"><a href="#1048-Longest-String-Chain" class="headerlink" title="1048. Longest String Chain"></a><a href="https://leetcode-cn.com/problems/longest-string-chain/">1048. Longest String Chain</a></h4><p>一开始想到用回溯 但是在边界情况一直出错 可以用动态规划 避免一开始的是否需要加入的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(String shorter,String longer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shorter.length()+<span class="number">1</span> != longer.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> insert=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;shorter.length() &amp;&amp; j &lt; longer.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(shorter.charAt(i)!=longer.charAt(j))</span><br><span class="line">                insert--;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ++i;<span class="comment">//匹配了 前身的指针才移动 否则让插入 后者的指针一直移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(insert&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        List&lt;String&gt; wordsList =Arrays.asList(words);</span><br><span class="line">        wordsList.sort(<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(String str:wordsList)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s &quot;</span>,str);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = wordsList.size();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(judge(wordsList.get(j),wordsList.get(i)))&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(dp[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>,dp[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="375-Guess-Number-Higher-or-Lower-II-220127x"><a href="#375-Guess-Number-Higher-or-Lower-II-220127x" class="headerlink" title="375. Guess Number Higher or Lower II 220127x"></a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/">375. Guess Number Higher or Lower II 220127x</a></h4><p>最开始想到了树，在这过程中想到了区间分治可以用记忆话搜索或者动态规划</p>
<p>预打表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][] cache = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">10</span>][N+<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//下标会到n</span></span><br><span class="line">    <span class="comment">//打表预处理</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=N;++len)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len-<span class="number">1</span>&lt;=N;++l)&#123;</span><br><span class="line">                <span class="comment">//有减一的操作</span></span><br><span class="line">                <span class="keyword">int</span> r = l+len-<span class="number">1</span>;</span><br><span class="line">                cache[l][r]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i)&#123;</span><br><span class="line">                    <span class="keyword">int</span> cur = Math.max(cache[l][i-<span class="number">1</span>],cache[i+<span class="number">1</span>][r])+i;</span><br><span class="line">                    cache[l][r]=Math.min(cache[l][r],cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cache[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Algo</tag>
      </tags>
  </entry>
  <entry>
    <title>NPC问题：服务商+bitset用法</title>
    <url>/post/4a3554ff/</url>
    <content><![CDATA[<p>原题：</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/Cache_3de56e540c5c45f2..jpg" alt="Cache_3de56e540c5c45f2."></p>
<p>参考的是<a href="https://blog.csdn.net/RayoNicks/article/details/102875252?ops_request_misc=&request_id=&biz_id=102&utm_term=%E4%B8%80%E5%AE%B6%E5%85%AC%E5%8F%B8%E5%9C%A8%20N%20%E4%B8%AA%E5%B0%8F%E9%95%87%E9%94%80%E5%94%AE%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%EF%BC%883%E2%89%A4N%E2%89%A435%EF%BC%89%EF%BC%8C%E6%9C%89%20M%20&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-102875252.pc_search_result_control_group&spm=1018.2226.3001.4187">Program Challenge的CSDN解析</a></p>
<p>数据结构上的绝妙是利用<a href="https://en.cppreference.com/w/cpp/utility/bitset">bitset</a>来压缩信息的存储.可以认为把二位vector中的行变为bitset，即每个单位由int变为bit，则每一行对应一个点的连通信息，每个比特对应点对点是否连通。之后的DFS中，通过位运算可以简洁的合并信息并进行判断。</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(i); <span class="comment">//把bitset的第i位比特设置成1</span></span><br><span class="line"><span class="built_in">test</span>(i);<span class="comment">//检查bitset的第i位是1则返回true</span></span><br><span class="line"><span class="built_in">count</span>();<span class="comment">//数bitset中有多少位是1</span></span><br><span class="line">对bitset可以做位运算</span><br></pre></td></tr></table></figure>

<p>这是一个NPC问题，多项式时间内没有解法，但是可以多项式时间验证解是否正确。作为一个图论问题，自然想到用DFS或者BFS来做。为了求出最小的站点数，从小到大遍历答案并检查。</p>
<p>这里为了简化求解，把图拆封成连通分量分别求解，每个连通分量上的最小解的和就是整个图的最小解。在压入每一个点的信息（即每一行bitset）的时候，可以认为对子图进行了重新编号。</p>
<p>还有一处简化是是通过覆盖率来剪枝。由于遍历是按照序号从小到大来遍历的，back的意思是，从当前点往更大的点遍历，能有多少个点被服务站覆盖。因此填写信息的时候是从序号大的点往序号小的点遍历，因为较大序号的点不会再去遍历小序号的点。这里主要是为了剪枝以下情况。（左侧是结果树）</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/A45CFDC5EF4DCAB9BA01E313BD59C701.png" alt="A45CFDC5EF4DCAB9BA01E313BD59C701"></p>
<p>可以看到在对1的处理中，对5做DFS是没有意义的，因此剪枝。</p>
<p>由于本身建站和相邻建站都算覆盖，这里的连通实际上也代表了覆盖的情况。因此可以通过或运算来计算覆盖的情况。</p>
<p>以下是对原作者代码的注释</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//划分出连通分量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divideGraph</span><span class="params">(<span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt; &amp;graph,vector&lt;vector&lt;bitset&lt;MAX_N&gt;&gt;&gt; &amp;vecChildGraph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    graph 原本的图，graph[i]代表序号为i的点所处的连通分量的记录图</span></span><br><span class="line"><span class="comment">    vecChildGraph 用于存储子图的vector</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">size_t</span> N =graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">size_t</span>&gt; <span class="title">vecVisited</span><span class="params">(N,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">//用于记录每一个点是否已经被遍历并归入一个连通子图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vecVisited[i])<span class="comment">//点还没遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;bitset&lt;MAX_N&gt;&gt; ChildGraph;</span><br><span class="line">            deque&lt;<span class="keyword">size_t</span>&gt; que;<span class="comment">//BFS找连通分量</span></span><br><span class="line">            que.<span class="built_in">push_back</span>(i);</span><br><span class="line">            vecVisited[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">size_t</span> front;</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                front = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">                ChildGraph.<span class="built_in">push_back</span>(graph[front]);<span class="comment">//构建连通图信息中的行</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">size_t</span> pos=<span class="number">0</span>;pos&lt;N;pos++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(graph[front].<span class="built_in">test</span>(pos) &amp;&amp; !vecVisited[pos])</span><br><span class="line">                    &#123;</span><br><span class="line">                        que.<span class="built_in">push_back</span>(pos);</span><br><span class="line">                        vecVisited[pos]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vecChildGraph.<span class="built_in">push_back</span>(ChildGraph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calBackCover</span><span class="params">(vector&lt;vector&lt;bitset&lt;MAX_N&gt;&gt;&gt; &amp;vecChildGraph,vector&lt;vector&lt;bitset&lt;MAX_N&gt;&gt;&gt; &amp;vecBackCover)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//vecChildGraph是连通子图的集合，vecBackCover是记录覆盖率信息的二维bitset，每一行代表遍历到该行序列对应的点的覆盖率信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> idx=<span class="number">0</span>;idx&lt;vecChildGraph.<span class="built_in">size</span>();idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt; &amp;childGraph = vecChildGraph[idx];</span><br><span class="line">        <span class="keyword">size_t</span> node = childGraph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//取出一个子图 记录下子图中节点的数量</span></span><br><span class="line">        vecBackCover.<span class="built_in">push_back</span>(vector&lt;bitset&lt;MAX_N&gt;&gt;(node,bitset&lt;MAX_N&gt;()));</span><br><span class="line">        <span class="comment">//生成一个二维bitset对应该子图，并放入答案vector中</span></span><br><span class="line">        bitset&lt;MAX_N&gt; BackCover;</span><br><span class="line">        <span class="comment">//中间变量 代表一个点的覆盖率信息</span></span><br><span class="line">        <span class="keyword">for</span>(;node&gt;<span class="number">0</span>;--node)</span><br><span class="line">        &#123;</span><br><span class="line">            vecBackCover[idx][node<span class="number">-1</span>]=childGraph[node<span class="number">-1</span>]|BackCover;</span><br><span class="line">            <span class="comment">//直接对bitset进行或运算来得到连通信息 bitset默认初始值应该是全0</span></span><br><span class="line">            BackCover=vecBackCover[idx][node<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">//记录下来 下一轮继续用 因为是层层向序号小的节点传递的连通的信息 小节点的信息依赖于序号更大的覆盖率的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt; &amp;graph,<span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt; &amp;back,bitset&lt;MAX_N&gt; &amp;cover,<span class="keyword">size_t</span> curr,<span class="keyword">size_t</span> cnt,<span class="keyword">const</span> <span class="keyword">size_t</span> bound,<span class="keyword">size_t</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    graph 处理后的连通子图 确保只有一个连通分量</span></span><br><span class="line"><span class="comment">    back 该子图上每个点的覆盖率信息</span></span><br><span class="line"><span class="comment">    cover 遍历到当前点的已有的覆盖子图的情况</span></span><br><span class="line"><span class="comment">    curr 当前遍历的点的序号</span></span><br><span class="line"><span class="comment">    cnt 当前已经建立的服务站的数量</span></span><br><span class="line"><span class="comment">    bound 最多能建的服务站的数量</span></span><br><span class="line"><span class="comment">    num 最终返回的答案</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(cnt==bound)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cover.<span class="built_in">count</span>()==graph.<span class="built_in">size</span>())</span><br><span class="line">            num=cnt;</span><br><span class="line">       	<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//验证当前的bound是否能够使得点都被覆盖 如果是，确定答案并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    bitset&lt;MAX_N&gt; newCover;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=curr;i&lt;graph.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        newCover = cover;</span><br><span class="line">        newCover |=back[curr];</span><br><span class="line">        <span class="keyword">if</span>(newCover.<span class="built_in">count</span>()!=graph.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//做覆盖率的剪枝 现有的覆盖情况与curr覆盖如果合起来不是全图 那么一直不会对之后的点做DFS</span></span><br><span class="line">        newCover = cover;</span><br><span class="line">        newCover |= graph[i];<span class="comment">//更新情况</span></span><br><span class="line">        <span class="keyword">if</span>(newCover == cover)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//覆盖率没有变化 不需要遍历选中的i点 剪枝</span></span><br><span class="line">        <span class="built_in">DFS</span>(graph,back,newCover,i+<span class="number">1</span>,cnt+<span class="number">1</span>,bound,num);</span><br><span class="line">        <span class="comment">//对i建站并更新 记录新的覆盖情况，从下一个点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(num!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       	<span class="comment">//已经有答案 不用再继续</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> N=<span class="number">0</span>,M=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;N&gt;&gt;M)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span> &amp;&amp; M==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        vector&lt;bitset&lt;MAX_N&gt;&gt; <span class="built_in">graph</span>(N,bitset&lt;MAX_N&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> v=<span class="number">0</span>;v&lt;N;++v)</span><br><span class="line">        &#123;</span><br><span class="line">            graph[v].<span class="built_in">set</span>(v);</span><br><span class="line">            <span class="comment">//自己与自己算连通</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> v1,v2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> m=<span class="number">0</span>;m&lt;M;++m)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;v1&gt;&gt;v2;</span><br><span class="line">            graph[v1<span class="number">-1</span>].<span class="built_in">set</span>(v2<span class="number">-1</span>);</span><br><span class="line">            graph[v2<span class="number">-1</span>].<span class="built_in">set</span>(v1<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//记录路径信息 注意下标已经双向</span></span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;bitset&lt;MAX_N&gt;&gt;&gt; vecChildGraph;</span><br><span class="line">        vector&lt;vector&lt;bitset&lt;MAX_N&gt;&gt;&gt; vecBackCover;</span><br><span class="line">        <span class="built_in">divideGraph</span>(graph,vecChildGraph);<span class="comment">//划分连通子图</span></span><br><span class="line">        <span class="built_in">calBackCover</span>(vecChildGraph,vecBackCover);<span class="comment">//求每个子图中每个点的覆盖率</span></span><br><span class="line">        <span class="keyword">size_t</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> idx=<span class="number">0</span>;idx&lt;vecChildGraph.<span class="built_in">size</span>();++idx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt; &amp;childGraph = vecChildGraph[idx];</span><br><span class="line">            <span class="keyword">const</span> vector&lt;bitset&lt;MAX_N&gt;&gt;&amp; back=vecBackCover[idx];</span><br><span class="line">            bitset&lt;MAX_N&gt; cover;</span><br><span class="line">            <span class="keyword">size_t</span> num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> bound=<span class="number">1</span>;bound&lt;=childGraph.<span class="built_in">size</span>();++bound)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">DFS</span>(childGraph,back,cover,<span class="number">0</span>,<span class="number">0</span>,bound,num);<span class="comment">//对每个bound做验证 NPC问题</span></span><br><span class="line">                <span class="keyword">if</span>(num!=<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//有解</span></span><br><span class="line">            &#125;</span><br><span class="line">            total+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;total&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Algo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发高级设施实现原理笔记</title>
    <url>/post/175000d5/</url>
    <content><![CDATA[<blockquote>
<p>vscode看java api的源码非常舒适 提供了跳转到指定源码的功能</p>
<p>结合Oracle的JAVA文档食用更佳</p>
<p><a href="https://www.baeldung.com/">Java相关api介绍网站推荐: Baeldung</a></p>
</blockquote>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a></h2><p>核心是sync，Sync类是基于AbstractQueueSynchonizer这一抽象接口实现的</p>
<h3 id="AbstractQueueSynchronizer"><a href="#AbstractQueueSynchronizer" class="headerlink" title="AbstractQueueSynchronizer"></a>AbstractQueueSynchronizer</h3><p>一个用链表实现的队列，对节点加自旋锁来实现synchronize。按照队列的性质，头部的节点会先获得申请锁的机会，但是不保证成功。</p>
<p>有state来存储状态，其中state是volatile的，即存储在内存中，立即更新，不存在写缓冲问题。</p>
<p>这里的加锁方式有exclusive/shared两种。实现上没有做显著区分</p>
<h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p>实现了上述接口，其中Count直接存储在了AbstractQueueSynchronizer（以下简称AQS）的state变量中。</p>
<p>CountDownLatch的countDown方法是调用sync的releaseShared方法实现的 而sync中又调用AQS的tryReleaseShared() 判断能否释放，如果能，就调用doReleaseShared()对队列里的节点做操作。具体会调整列表中节点的状态。</p>
<p>CountDownLatch的await方法是调用sync的tryAcquireSharedNanos方法实现的，其中有设置限时（这里以纳秒为单位）。除了返回之外还会抛出异常。sync的方法调用了AQS的tryAcquireShared ,doAcquireSharedNanos方法 try方法有三种状态，不成功（返回负数），shared mode成功但subsequent shared-mode acquisition不成功（返回0，这里理解成时序上接下来共享状态下的申请不成功），shared mode和subsequent shared-mode acquisition都成功</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><a href="https://www.baeldung.com/java-cyclic-barrier">CyclicBarrier</a></h2><p>cyclic表达了可以重复利用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties，Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure>

<p>parties代表参与的线程的数量，通过await登记到达了共同的阻塞状态（目的地）并进入阻塞，只有当参与的所有线程都调用await进入阻塞的时候，所有进程才能同时进入barrierAction所对应的操作。注意，和CountDownLatch不同的是，这里并没有新开一个总结的线程（类型是Runnable，是任务而非Thread线程），而是把最后一个进入阻塞状态的线程用来执行barrierAction</p>
<h3 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h3><p>实现重用依赖于Generation这个类。线程会阻塞，停止，因此用Generation来装载可以实现重用。Generation的实例被分配给哪一个线程是不确定的，而且可以有多个被分配给使用CyclicBarrier的线程，但是可以确定的是，同一时间只能有一个Generation是活跃中的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="comment">//是之前提及的可重用锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line">    <span class="comment">//Condition即java分配给每个对象的monitor相关数据结构，有notify notifyAll wait等方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/** The number of parties */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/* The command to run when tripped */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/** The current generation */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Updates state on barrier trip and wakes up everyone.</span></span><br><span class="line"><span class="comment">     * Called only while holding lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// signal completion of last generation</span></span><br><span class="line">        trip.signalAll();<span class="comment">//condition中的方法，把所有线程都唤醒</span></span><br><span class="line">        <span class="comment">// set up next generation</span></span><br><span class="line">        count = parties;</span><br><span class="line">        generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets current barrier generation as broken and wakes up everyone.</span></span><br><span class="line"><span class="comment">     * Called only while holding lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        generation.broken = <span class="keyword">true</span>;</span><br><span class="line">        count = parties;</span><br><span class="line">        trip.signalAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可能抛出中断、超时 阻塞中断异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed,<span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException,BrokenBarrierException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">			<span class="comment">//引用 浅拷贝</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = --count;<span class="comment">//记录有线程到达目的地</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;<span class="comment">//最后一个到达的线程执行方法</span></span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                    nextGeneration();<span class="comment">//这一批结束了 进行更新 把状态重设</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();<span class="comment">//没有要做的最终操作也要把这一代结束</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await();<span class="comment">//condition的方法 让当前线程等待</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();<span class="comment">//被打断了 而且当前一代没作废 主动作废</span></span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();<span class="comment">//如果出现意外上面的条件没执行 也要主动打断</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">ScheduledThreadPoolExecutor</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">extends ThreadPoolExecutor <span class="comment">//线程池 池化线程对应的资源 避免反复生成和销毁带来的代价</span></span><br><span class="line">implements ScheduledExecutorService<span class="comment">// extends ExecutorService 可以调度命令使得经历一段延迟之后再执行，或者阶段性的执行</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//case:</span></span><br><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;, <span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://www.baeldung.com/thread-pool-java-and-guava">线程池系列介绍</a></p>
</blockquote>
<p>enable：激活 execute：执行</p>
<p>激活不一定执行，按照激活的顺序排队（FIFO）来被调度去提交执行</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211030113256401.png" alt="image-20211030113256401"></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html">Semaphore</a></h2><p>permits:允许调用的资源，如果没有permit，acquire方法会阻塞；release方法释放permit资源。Semaphore通常用来限制进入临界区的线程数量。lock可以认为是数量为1的semaphore</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//case</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     available.acquire();<span class="comment">//申请</span></span><br><span class="line">     <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (markAsUnused(x))</span><br><span class="line">       available.release();<span class="comment">//释放</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Not a particularly efficient data structure; just for demo</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">          used[i] = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">return</span> items[i];</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">       <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部实现——Sync-extends-AbstractQueuedSynchronizer"><a href="#内部实现——Sync-extends-AbstractQueuedSynchronizer" class="headerlink" title="内部实现——Sync extends AbstractQueuedSynchronizer"></a>内部实现——Sync extends AbstractQueuedSynchronizer</h3><p>利用了AQS，与CountDownLatch类似，permit的数量被state记录</p>
<p>acquire方法调用了Sync的acquireSharedInterruptibly，实际调用了AQS的tryAcquireShared和doAcquireSharedInterruptibly，与CountDownLatch类似。</p>
<p>release方法调用了Sync的releaseShared，实际调用了AQS的tryReleaseShared和doReleaseShared</p>
<blockquote>
<p>综合来看，在涉及数量的同步上，都利用了AQS 这里信号量的逻辑和AQS的逻辑基本一致，申请的到就继续，申请不到即阻塞</p>
</blockquote>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Exchanger.html">Exchanger</a></h2><p>“Synchronization point” 说明可以认为这里的exchanger操作是一个可以视为原子操作 交换指定的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FillAndEmpty</span> </span>&#123;</span><br><span class="line">  Exchanger&lt;DataBuffer&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;DataBuffer&gt;();</span><br><span class="line">  DataBuffer initialEmptyBuffer = ... a made-up type</span><br><span class="line">  DataBuffer initialFullBuffer = ...</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FillingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      DataBuffer currentBuffer = initialEmptyBuffer;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (currentBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          addToBuffer(currentBuffer);</span><br><span class="line">          <span class="keyword">if</span> (currentBuffer.isFull())</span><br><span class="line">            currentBuffer = exchanger.exchange(currentBuffer);<span class="comment">//在这里交换</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">EmptyingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      DataBuffer currentBuffer = initialFullBuffer;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (currentBuffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          takeFromBuffer(currentBuffer);</span><br><span class="line">          <span class="keyword">if</span> (currentBuffer.isEmpty())</span><br><span class="line">            currentBuffer = exchanger.exchange(currentBuffer);<span class="comment">//在这里交换</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> FillingLoop()).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> EmptyingLoop()).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sun.misc.Unsafe U; compareAndSwapObject来实现原子操作</p>
<p>可以用来实现管道之类进程间通信的机制（？）</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/DelayQueue.html">DelayQueue</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; //有四种处理不能立刻满足的操作的方式</span></span><br></pre></td></tr></table></figure>

<p>不限长度的延迟元素的队列，其中元素只有超时之后才能取出。队列头的元素是超时最久的元素</p>
<p>其中容纳的元素需要继承自Delayed类，还要重载compareTo以便进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayObject</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayObject</span><span class="params">(String data, <span class="keyword">long</span> delayInMilliseconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.startTime = System.currentTimeMillis() + delayInMilliseconds;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> diff = startTime - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> unit.convert(diff, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ints.saturatedCast(</span><br><span class="line">          <span class="keyword">this</span>.startTime - ((DelayObject) o).startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.baeldung.com/java-delay-queue">例子：超时的消费者和生产者</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueProducer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;DelayObject&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Integer numberOfElementsToProduce;</span><br><span class="line">    <span class="keyword">private</span> Integer delayOfEachProducedMessageMilliseconds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard constructor</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfElementsToProduce; i++) &#123;</span><br><span class="line">            DelayObject object</span><br><span class="line">              = <span class="keyword">new</span> DelayObject(</span><br><span class="line">                UUID.randomUUID().toString(), delayOfEachProducedMessageMilliseconds);</span><br><span class="line">            System.out.println(<span class="string">&quot;Put object: &quot;</span> + object);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(object);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                ie.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;DelayObject&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Integer numberOfElementsToTake;</span><br><span class="line">    <span class="keyword">public</span> AtomicInteger numberOfConsumedElements = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard constructors</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfElementsToTake; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                DelayObject object = queue.take();</span><br><span class="line">                numberOfConsumedElements.incrementAndGet();</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer take: &quot;</span> + object);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> givenDelayQueue_whenProduceElement</span></span><br><span class="line"><span class="function">  <span class="title">_thenShouldConsumeAfterGivenDelay</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// given</span></span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    BlockingQueue&lt;DelayObject&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> numberOfElementsToProduce = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> delayOfEachProducedMessageMilliseconds = <span class="number">500</span>;</span><br><span class="line">    DelayQueueConsumer consumer = <span class="keyword">new</span> DelayQueueConsumer(</span><br><span class="line">      queue, numberOfElementsToProduce);</span><br><span class="line">    DelayQueueProducer producer = <span class="keyword">new</span> DelayQueueProducer(</span><br><span class="line">      queue, numberOfElementsToProduce, delayOfEachProducedMessageMilliseconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// when</span></span><br><span class="line">    executor.submit(producer);</span><br><span class="line">    executor.submit(consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then</span></span><br><span class="line">    executor.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    executor.shutdown();</span><br><span class="line"> </span><br><span class="line">    assertEquals(consumer.numberOfConsumedElements.get(), numberOfElementsToProduce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>打开ObeoDesigner出现&#39;Failed to load jvm.dll&#39;问题</title>
    <url>/post/87e0a4be/</url>
    <content><![CDATA[<p>打开ObeoDesigner的时候跳出了一个弹窗，在网上搜索发现解决方案都与Java编辑器Eclipse有关。仔细看发现文件夹下确实有Eclipse，应该是需要Java和Eclipse支持。</p>
<p>参考了<a href="https://www.crifan.com/eclipse_failed_to_load_the_jni_shared_library_jvm_dll/">这篇文章</a>，x86是32位的软件，实际上jvm.dll是存在的，但是版本不匹配，于是重新安装一个64位的版本。并修改了环境变量。修改之后检查了一下vscode的java环境，没有问题。</p>
<p>修改环境变量麻烦的就在于担心其他环境不适配。如果能用服务器或者虚拟机做隔离就更好了。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM Internals Notes</title>
    <url>/post/601be613/</url>
    <content><![CDATA[<p>阅读<a href="https://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a>的笔记</p>
<h2 id="JVM-System-Threads"><a href="#JVM-System-Threads" class="headerlink" title="JVM System Threads"></a>JVM System Threads</h2><p>用户运行的main函数并不是java中最初始的线程，java开始运行的时候就对应着机器中的一个线程，可以称之为Java Thread，当java中其他的线程（non-deamon）的都结束以后，Java Thread才会终止，可以认为是java本身一个代表</p>
<p>在main运行之外，还有一些java system thread来在幕后支撑main函数运行，比如：</p>
<ul>
<li>VM thread 等到JVM到达safe point，例如“stop-the-world”垃圾回收，线程的栈dump，线程暂停和biased locking revocation（有偏向的锁的撤回？）</li>
<li>Periodc task thread 阶段性任务；一些计时事件</li>
<li>GC Thread 垃圾回收</li>
<li>Compiler thread 在运行时将字节码转成原本的代码的线程</li>
<li>Signal dispatcher thread处理发送给JVM线程的信号并调用对应的JVM方法</li>
</ul>
<p>对于每一个thread来说，有一些必要的组件:</p>
<ul>
<li>PC 程序计数器 其中native线程的PC是不确定的</li>
<li>Stack 栈 每一个被调用的方法都有一个对应的frame被放入栈中，遵循LIFO原则 其中栈空间除了push和pop是不被直接管理支配的，并且frame中的一些结构可能被分配到堆上，因此这些object所占用的空间未必连续</li>
<li>Native Stack 为native方法准备的 和C stack一样 因为Java Native Invocation用C语言的连接模型（linkage model）实现</li>
<li>Stack Restrictions 大小可以固定或者灵活，超出范围是栈溢出，没有多余空间可分配是OutOfMemoryError</li>
<li>Frame 对每一次方法调用都会配备的相关信息，在抛出异常或者方法返回的时候被pop出栈<ul>
<li>Local Variable Array 一些基本数据类型，对象只保存引用，返回地址，this指针</li>
<li>OperandStack 作用类似于CPU中的general-purpose reg（通用寄存器）因为对变量操纵频繁 因此local variable array和operand stack数据交换也很频繁（具体看ClassFile里字节码的写法）</li>
</ul>
</li>
<li>Dynamic Linking 与c在编译中确定方法汇编和所在文件位置不同 在java当中方法编译后的链接是在运行时动态完成的 在类被确定并加载，调用静态方法或者动态方法的时候，symbolic reference从一个逻辑上的指针经由lazy resolution被解析，被替换成直接的引用，如果直接引用中涉及到的类没有被解析，那么就会去加载这个类。每个直接引用以相对于运行时变量或者方法存储的相对位置（offset）被储存</li>
</ul>
<h2 id="Shared-Between-Thread"><a href="#Shared-Between-Thread" class="headerlink" title="Shared Between Thread"></a>Shared Between Thread</h2><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>Object和Array数据结构都是存放在堆中的，因为frame并不是为空间大小会变化的数据结构设计的。并且不像简单的数据类型和引用，堆中的对象并不会随着方法返回而被销毁。</p>
<p>在堆中存在垃圾管理机制，被分为三种类型：young generation（常被分为Eden&amp;Survivor），old generation，permanent generation</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul>
<li><p>新对象被创建时进入young generation；minor garbage是把young generation中的对象从eden移到survivor，此时对象仍然活跃；</p>
</li>
<li><p>major garbage是把活跃的对象从young generation移动到old generation，通常会使得线程暂停；</p>
</li>
<li><p>permanent generation在old generation回收的时候回收，当其中有一个满的时候两者都会回收</p>
</li>
</ul>
<h3 id="Non-Heap-Memory"><a href="#Non-Heap-Memory" class="headerlink" title="Non-Heap Memory"></a>Non-Heap Memory</h3><p>一些不在Heap中的结构</p>
<ul>
<li>permanent generation 含有方法域和interned string的</li>
<li>code cache 已经被JIT compiler编译的部分方法的代码</li>
</ul>
<h3 id="Just-In-Time-Compilation"><a href="#Just-In-Time-Compilation" class="headerlink" title="Just In Time Compilation"></a>Just In Time Compilation</h3>]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>字节上海客户端面经一二三面</title>
    <url>/post/c9d2088f/</url>
    <content><![CDATA[<p>1115 内推投简历<br>1117 hr联系约19号面试</p>
<h2 id="1119一面"><a href="#1119一面" class="headerlink" title="1119一面"></a>1119一面</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul>
<li>进程线程</li>
<li>平常用线程编程过吗 举个例子？</li>
<li>刚刚提到互斥 怎么保证线程互不干扰？</li>
<li>死锁 </li>
<li>提到银行家算法就说一下具体实现</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>怎么用两个队列实现一个栈？</li>
<li>排序有了解吗 </li>
<li>说一个印象深刻的排序算法？（讲了快排）</li>
<li>快排既然有比较差的情况 怎么改进？</li>
<li>平均复杂度是nlogn 是怎么算出来的？</li>
<li>还有什么印象深刻的数据结构？ </li>
<li>（讲到树） 既然刚刚提到交换左右子树的题就写一下吧</li>
<li>一道算法题 交换左右子树 （一边写一边解释了思路 没有跑）</li>
</ul>
<h3 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h3><ul>
<li>基本的TCP UDP介绍一下？</li>
<li>刚刚提到TCP有保证稳定链接的机制 提到拥塞控制 详细说一下过程？（快恢复还是啥忘记名字了 面试官提示了一下）</li>
<li>拥塞控制中怎么知道网络的拥塞程度的呢（前面关于阈值和ccwindow名字想不起来了） </li>
<li>可以具体再说说吗（说到收到冗余3次和超时两种情况 会对应不同的处理方式</li>
</ul>
<h3 id="介绍一个课外项目"><a href="#介绍一个课外项目" class="headerlink" title="介绍一个课外项目"></a>介绍一个课外项目</h3><p>说了南小包 问了如何处理一些错误情况 异常 比如用户支付失败</p>
<h3 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h3><ul>
<li>如何实现随机播放音乐<ul>
<li>一个是均匀随机 面试官提示了洗牌算法</li>
<li>一个是权重 完整听到的歌加权重</li>
</ul>
</li>
</ul>
<h3 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h3><p>问了一下做什么业务<br>一般用什么语言</p>
<p>1119 晚上7点半 一面通过 </p>
<h2 id="1122下午四点二面"><a href="#1122下午四点二面" class="headerlink" title="1122下午四点二面"></a>1122下午四点二面</h2><ul>
<li><p>问了一些个人规划</p>
</li>
<li><p>为什么投iOS？（简历上写得多的是后端 我说看起来新手友好所以想试一下 面试官：”看来是做什么都可以对吧” 我：”是这样的“）</p>
</li>
<li><p>你觉得自己优势的能力？</p>
</li>
<li><p>做过最有挑战性的项目？（提到了大二上PA搞了我一个星期的bug）</p>
</li>
<li><p>这个bug为什么花了一个星期 最后怎么解决的 最后有和同学交流吗</p>
</li>
<li><p>现在让你debug你会怎么做？</p>
</li>
<li><p>一个电商平台你会如何设计？</p>
<ul>
<li>写一个计算满减的结算函数？</li>
</ul>
</li>
</ul>
<blockquote>
<p>基本没问啥算法 都是软问题</p>
</blockquote>
<h3 id="反问-1"><a href="#反问-1" class="headerlink" title="反问"></a>反问</h3><p>实习生培养？</p>
<p>1123 二面通过 约三面</p>
<h2 id="1124晚上七点三面"><a href="#1124晚上七点三面" class="headerlink" title="1124晚上七点三面"></a>1124晚上七点三面</h2><ul>
<li>问了个人规划 为什么这个时候投实习（说计划本科出来工作所以来试试）</li>
<li>不打算读研吗  </li>
<li>对什么方向感兴趣（因为我感兴趣的方向我也不是太懂 就说还需要探索）</li>
<li>介绍一下做的app应用吧——被问了一堆业务端逻辑设计给我问傻了 主要是写一些request和response流程</li>
<li>社交app好友列表 怎么在手机上第一次获取好友列表</li>
<li>在pc上添加了好友 在手机需要怎么同步<ul>
<li>说想要添加删除的信息 说成了log 给了提示 设备上可以获取与某个好友加好友的时间 还有另一个条件我忘了因为不理解 然后说了一下用加好友的时间倒序检查手机上没有登陆更新的这段时间的好友添加时间然后更新 </li>
<li>时间快到了就没多问 感觉确实盲区了55</li>
</ul>
</li>
<li>平常除了课本还看什么技术内容吗<ul>
<li>提到在看拓展阅读读到java虚拟机相关+垃圾回收 但是不熟 属于把自己坑到了</li>
</ul>
</li>
<li>大三什么时间方便实习 上课怎么办？</li>
</ul>
<h3 id="反问-2"><a href="#反问-2" class="headerlink" title="反问"></a>反问</h3><p>怎样学习客户端设计逻辑？</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>1125口头offer 1129隔了一个周末邮件正式offer确认 </p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Java下运行mysql</title>
    <url>/post/15229090/</url>
    <content><![CDATA[<h2 id="环境配置问题"><a href="#环境配置问题" class="headerlink" title="环境配置问题"></a>环境配置问题</h2><p>如果出现 <code>java.lang.ClassNotFoundException: com.mysql.jdbc.Driver</code> 的问题（在mysql 8.0及以上的版本 应该是<code>com.mysql.cj.jdbc.Driver</code>）有可能是没有安装connection j的依赖，最好先借助mysql installer检查mysql的安装包。</p>
<p>查到的解决方案大多针对有maven等管理工具的大型软件，对vscode下临时建立的小项目不直接适用。</p>
<p>安装后有一个jar包，移动到classpath以后依旧报错，在YouTube上找到一位<a href="https://www.youtube.com/watch?v=MtME-ERufu0&ab_channel=BoostMyTool">印度小哥制作的新手教程</a> 把jar包移动到java project中即可。</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211209203900546.png" alt="image-20211209203900546"></p>
<h2 id="依赖和包的使用"><a href="#依赖和包的使用" class="headerlink" title="依赖和包的使用"></a>依赖和包的使用</h2><p>需要java.sql.*</p>
<p>可以<a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-usagenotes-statements.html">参考Mysql官方文档</a> 和 <a href="https://www.runoob.com/java/java-mysql-connect.html">菜鸟教程</a></p>
<p>Statement: 用于像数据库发送指令 其中execute可以用于执行无返回结果和有返回结果的sql语句，但是executeQuery只能用于有返回结果的（如select）</p>
<p>ResultSet：用于接收结果，<a href="https://blog.csdn.net/SHU15121856/article/details/79305295">游标</a>可以通过该对象使用</p>
<h4 id="额外收获"><a href="#额外收获" class="headerlink" title="额外收获"></a>额外收获</h4><ul>
<li>”==“ 改成 equals就可以正常判断 why？<ul>
<li>“==” 基本类型比较的是值，引用类型比较的是引用 string后者，equals比较的是引用类型的值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Java实现简单Reactor</title>
    <url>/post/b5bd3a01/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Reactor最早是在<a href="http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf">这篇论文</a>中提出的 作为Java课程拓展阅读的笔记，主要分析老师给的<a href="https://github.com/caochun/java-server/tree/main/src/main/java">参考实现</a>和论文中介绍的组件的对应关系。</p>
<p>一张解释了各个组件之间关系的图：</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211134127551.png" alt="image-20211211134127551"></p>
<p>InitiationDispatcher （以下简称ID）是事实上监听事件的组件，其中使用NIO的实现方式，因为实际上一个Reactor中ID尽可能的使用单线程的方式实现，如果轻易阻塞会极大影响效率。同时具有一张用于分发的EventHandler表，在事件注册的时候进行初始化。SynchronouseEventDemultiplexer是用于通知ID的组件。</p>
<p>EvenHandler和Handle实际上实现了“Dispatch”（分发）的功能，事件注册时需要在ID中注册。</p>
<p>在看懂Reactor的代码之前，需要理解网络通信，以及了解NIO的实现机制。</p>
<h2 id="Reactor-Basic"><a href="#Reactor-Basic" class="headerlink" title="Reactor Basic"></a>Reactor Basic</h2><p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211135057739.png" alt="image-20211211135057739"></p>
<p>可以理解为Reactor统一处理请求，再将请求根据具体的任务分发到具体的acceptor，交给对应的处理函数执行（demultiplexing）代码对应single文件夹，其中包括了基础的组件。</p>
<p>Handler（Runnable）对应了论文中的EventHandler，其中需要初始化socket，并且设置为NIO模式（将会使用到select）。</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211135532346.png" alt="image-20211211135532346"></p>
<p>此外，最重要的是注册事件。注册事件实际上除了绑定到特定的selectkey上，还会在启动run的时候绑定具体的处理函数。</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211135554150.png" alt="image-20211211135554150"></p>
<p>特别的是，所有事件注册在同一个Reactor的socket上，因此Accept事件结束后要用interestOps注册下一个需要被处理的事件。</p>
<p>Reactor类中的run中的循环实际上对应着论文中的ID，进行监听，select实现了NIO，在监听到事件后进行分发。其中的dispatch函数就是提取之前注册在selectkey上的handler对应的具体的Runnable来执行。</p>
<p>Basic的缺点是，在执行任务的一侧，依旧是多线程，并没有解决最开始希望减少线程开销的目标。因此在Pool版中使用了线程池来有效管理资源。</p>
<h2 id="Pool-Reactor"><a href="#Pool-Reactor" class="headerlink" title="Pool Reactor"></a>Pool Reactor</h2><p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211140352313.png" alt="image-20211211140352313"></p>
<p>除了增加线程池相关，其他代码与basic没有太大差别。</p>
<h2 id="Multiple-Reactor"><a href="#Multiple-Reactor" class="headerlink" title="Multiple Reactor"></a>Multiple Reactor</h2><p>注意到上述两种，不同事件都注册在同一个selector上，在同一个线程中处理，而不同的事件处理时长可能不同，在同一个线程中可能会阻塞。因此考虑把事件分类，并用不同的selector处理。提高效率的同时增加了拓展性。</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20211211140628740.png" alt="image-20211211140628740"></p>
<p>示例代码中把事件分为连接事件和操作事件，MainReactor和SubReactor分别进行处理。在这种模式下，thread的使用模式（单线程/无限制的多线程/线程池）不受限制。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期实习面经</title>
    <url>/post/155d23b4/</url>
    <content><![CDATA[<h1 id="谷歌"><a href="#谷歌" class="headerlink" title="谷歌"></a>谷歌</h1><h2 id="投递"><a href="#投递" class="headerlink" title="投递"></a>投递</h2><p>同样是偶然在公众号看到。第一次用国内邮箱发送邮件被退回；但改用谷歌邮箱以后依旧没成功，最后请人内推。谷歌是滚动制，投递越早越好，然而正好与考试周冲突，可能投递完了只收到上海base的面试邮件。</p>
<p>面试用的自然语言（中英语）和计算机语言都可以在问卷中自选。</p>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ul>
<li><p>给定开心数的定义：各个位上数字的平方之和计算得到新的数，一直计算下去如果能得到1就是开心数，如果进入循环，即有计算得出的数重复出现，则不是。判断一个数是否是开心数。</p>
</li>
<li><p>追问：（我使用的是Java，并且用哈希表来解决）</p>
<ul>
<li><p>为什么要使用hashset？</p>
</li>
<li><p>hashset插入和查询的复杂度</p>
</li>
<li><p>哈希表底层原理？</p>
</li>
</ul>
</li>
<li><p>（有点答不上来于是换了进阶算法） 给定一个10^6以内的数，返回有多少个小于给定数的开心数？</p>
<ul>
<li>类似NP问题的思路（？） 被提示：有些数字进行一次各个位数字平方和就可以得到1，有些需要两次，即第一次先得到到1只有一步开心数计算的数字，以此倒退。</li>
</ul>
</li>
</ul>
<h1 id="微软提前批"><a href="#微软提前批" class="headerlink" title="微软提前批"></a>微软提前批</h1><h2 id="投递时间"><a href="#投递时间" class="headerlink" title="投递时间"></a>投递时间</h2><p>12月底偶然发现公众号更新了提前批相关信息，苦于当时在考试，在跨年夜当天晚上投递了，在1月3号投递ddl当天收到了意向征集的表格。</p>
<h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h2><ul>
<li>中英文自我介绍<ul>
<li>中文介绍结束后，英文自我介绍的时候被提醒介绍些简历之外的信息，于是回答了为什么想要来投递，被追问了原因。（对自己说的每一句话都要有圆回来的能力）</li>
</ul>
</li>
<li>项目<ul>
<li>选一个印象深刻的项目介绍。</li>
<li>三个问题：<ul>
<li>what：一个怎样的项目，实现了怎样的效果</li>
<li>why：为什么要做这个项目</li>
<li>how：如何实现的，有什么印象深刻的问题，是如何解决的</li>
</ul>
</li>
</ul>
</li>
<li>算法<ul>
<li>给定一个整数数组，要求把奇数放在数组左侧，0在中间，非0整数放在右侧</li>
</ul>
</li>
<li>反问：介绍苏州组的业务?</li>
</ul>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ul>
<li>项目<ul>
<li>java项目中的多机联网是怎样做的？服务器和客户端是怎样交互的？</li>
<li>突然有一方掉线了如何处理？如何确认对方依旧在线？</li>
</ul>
</li>
<li>算法<ul>
<li>有无限枚面值分别为1，2，4，8的硬币，给定一个数值给出有多少种兑换方式（提示：利用bfs/dfs思考，对每种面值，确定该兑换方法下兑换多少枚）</li>
</ul>
</li>
<li>反问&amp;其他<ul>
<li>面试官问：对自己的未来如何打算的？（因为简历上的方向和目前实习的方向不完全一致）</li>
<li>反问：如何找到自己的方向？提升的通用方法？</li>
</ul>
</li>
</ul>
<h2 id="终面"><a href="#终面" class="headerlink" title="终面"></a>终面</h2><ul>
<li><p>项目</p>
<ul>
<li>模拟计算机的项目是独立完成的吗？任务量大概多大？（面试官恰巧是校友）</li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li>给定一个有随机指针的链表，已知随机指针可能为空或者指向任意一个不是本节点的链表上的节点，对该链表进行深拷贝。（时间允许的情况下完整写完代码并进行了测试）</li>
</ul>
</li>
<li><p>反问</p>
<ul>
<li>实习生的培养方式？上班时间和节奏？</li>
</ul>
</li>
</ul>
<h1 id="Overall"><a href="#Overall" class="headerlink" title="Overall"></a>Overall</h1><p>固定节目是：自我介绍，问项目，算法题；保留节目是反问。</p>
<p>自我介绍可以复述简历上的技能，但是也有面试官严格一些会追问。我选择介绍投递该岗位的理由。（因为剖析自己性格优缺点我实在是说不出口，尽管论坛里很推荐）</p>
<p>项目需要记住自己做了什么，怎样做的，最终效果。最好多想想有什么优化的地方，并且对用到的技术思路有所了解，面试前可以把认真写的实验报告拿出来复习。（微软二面危在此处的血泪教训）</p>
<p>算法题，体感谷歌问的题目有点智力题的感觉，不是太依赖技巧，而且需要知其所以然，所谓”基础扎实”。做完热题100/剑指offer合集会有个大概认知，遇到新题不能说见过但是会有一些基础分析思路。</p>
<p>反问是一个很好的了解公司的环节。如果感觉不好一般问如何提升（显示我知道自己菜虚心学习），太尴尬了就不问；感觉还可以就会问工作内容/工作节奏/培养方案。</p>
<p>两家外企的面试节奏都比较慢，投递邮件4-7天后得到面试通知（春节前），面试结束后，如果有接下来的面试，微软是2-3天得知结果并且收到下一轮面试邮件；最终结果都是在大概5-7天后邮件发送。</p>
<h1 id="一些马后炮"><a href="#一些马后炮" class="headerlink" title="一些马后炮"></a>一些马后炮</h1><p>最开始想着主攻外企，于是只投了这两家知名外企。但是等待中发现这样做太过冒险，国内大厂的暑期实习面试启动时间基本在年后，年后开学再准备投递其他家时间就太紧了，应该至少再海投几家外企。还好最后被微软捞了，不然任务栈会直接爆炸。</p>
<p>准备期间也不是100%精力投入，依旧有遗漏的地方，所以遗憾被谷歌拒了。面试无论是八股还是算法知识点都不少，做成知识地图或许能更好的查漏补缺。</p>
<p>其实很难有完全准备好的时候，不同的时间总是有事要忙。因此每次快要开始前和等待结果的时候都最紧张，但是一旦开始，或者已经不能改变结果只能等待的时候，就投入手头的事情就好了。海投也很锻炼心态。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Software-Architecture docker踩坑小结+AW04记录</title>
    <url>/post/961e2082/</url>
    <content><![CDATA[<h2 id="gcr-io-镜像因为网络原因拉取失败"><a href="#gcr-io-镜像因为网络原因拉取失败" class="headerlink" title="gcr.io 镜像因为网络原因拉取失败"></a>gcr.io 镜像因为网络原因拉取失败</h2><p>尝试换源失败，总是提示验证失败，于是打算直接用代理从原网站下载</p>
<h3 id="虚拟机使用宿主机的梯子环境"><a href="#虚拟机使用宿主机的梯子环境" class="headerlink" title="虚拟机使用宿主机的梯子环境"></a>虚拟机使用宿主机的梯子环境</h3><p>vitualbox上没有装梯子，尝试使用宿主机的梯子环境。vitualbox上的网络连接方式是 <strong>网络地址转换（NAT）</strong></p>
<p>在终端用 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route show</span><br></pre></td></tr></table></figure>

<p>查看虚拟机所占用的ip地址，选择default的记录下来。</p>
<p>在虚拟机设置中找到Network-NeworkProxy 选择manual</p>
<p>所有proxy的ip都填写刚刚记录的ip，端口就查看电脑本机梯子上的端口填入（我的梯子软件界面自带了该信息，如果没有可以通过查看梯子软件进程占用的端口来确定）</p>
<p>在浏览器中访问google/youtube，成功即可</p>
<h3 id="mvn中的jib-dockerBuild使用代理"><a href="#mvn中的jib-dockerBuild使用代理" class="headerlink" title="mvn中的jib dockerBuild使用代理"></a>mvn中的jib dockerBuild使用代理</h3><p>首先参照<a href="https://note.qidong.name/2020/05/docker-proxy/">此篇文章</a>给dockerd设置的全局的代理。</p>
<p>随后，参考github上的<a href="https://github.com/GoogleContainerTools/jib/issues/1403">此issue</a>和另一篇<a href="https://www.jianshu.com/p/4701d9738bfa">文章</a>，执行mvn命令时需要添加参数，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn compile -Dhttps.proxyHost=10.0.2.2 -Dhttps.proxyPort=33210 compile jib:dockerBuild</span><br></pre></td></tr></table></figure>

<p>其中<code>10.0.2.2</code>和<code>33210</code>换成和虚拟机网络代理设置中的ip地址和端口，注意ip地址前不需要加协议名（在这里被坑了，因为不是很了解代理参数的含义）</p>
<p>就可以成功得到所需要的镜像了！</p>
<h2 id="gatling使用"><a href="#gatling使用" class="headerlink" title="gatling使用"></a>gatling使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/gatling.sh</span><br></pre></td></tr></table></figure>

<p>参考gatling官方文档编写更复杂的脚本，比如模仿添加购物车操作，简单来说是在get函数中的url带上参数</p>
<h2 id="docker的使用"><a href="#docker的使用" class="headerlink" title="docker的使用"></a>docker的使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps //查看当前在运行的容器</span><br><span class="line">docker ps -a //查看所有</span><br><span class="line">docker run -d --name app-pi-0.5 --cpus=0.5 -p 18080:8080 app-pi //限制cpu占用时间，映射端口，命名，选择镜像</span><br><span class="line">docker stop &#123;container-hash&#125;</span><br><span class="line">docker rm &#123;container-hash&#125; //删除容器</span><br><span class="line">docker rmi &#123;image-hash&#125; //删除镜像</span><br><span class="line">docker run --name redis -p 6379:6379 -e ALLOW_EMPTY_PASSWORD=yes bitnami/redis:latest//镜像启动redis服务 第一次会自动下载</span><br><span class="line">docker logs &#123;container-hash&#125; //查看log </span><br></pre></td></tr></table></figure>



<p>vscode中的run方法不会补全pom文件中的组件，第一次运行用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean spring-boot:run</span><br></pre></td></tr></table></figure>

<h3 id="Docker相关概念"><a href="#Docker相关概念" class="headerlink" title="Docker相关概念"></a>Docker相关概念</h3><p>image 映像文件: 包括光盘的所有信息的文件 可以被运行</p>
<p>root文件系统: 内核启动后加载的第一个文件系统，包括内核代码的影响文件和初始化脚本</p>
<p>docker image相当于一个root文件系统，配置了容器运行时需要的程序、库、资源、配置参数，但是都是静态的，image不包括任何动态数据。</p>
<p>image和container 就像class 和 instance的关系，可以认为是一种特定轻量级的环境。</p>
<h2 id="Redis相关"><a href="#Redis相关" class="headerlink" title="Redis相关"></a>Redis相关</h2><h3 id="Redis-info："><a href="#Redis-info：" class="headerlink" title="Redis info："></a>Redis info：</h3><p>键值对 非关系型数据库；</p>
<p>可以内存，可以分布式</p>
<p>Redis slot：可以认为是逻辑上构建范围区间，每个节点对应一定的范围，计算出的哈希值落到一个slot中，则值存到对应的节点中去。在节点添加和减少的时候，</p>
<h5 id="cluster-配置不同的地方在于："><a href="#cluster-配置不同的地方在于：" class="headerlink" title="cluster 配置不同的地方在于："></a>cluster 配置不同的地方在于：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.redis.cluster.nodes[0]=ip:port</span><br><span class="line">...[1]=ip:port</span><br></pre></td></tr></table></figure>



<h5 id="another-redis-manager"><a href="#another-redis-manager" class="headerlink" title="another redis manager:"></a>another redis manager:</h5><p>可以用来查看redis中数据存储的情况</p>
<h5 id="尝试连接数据库查看session遇到的问题-此时使用的是JDBC"><a href="#尝试连接数据库查看session遇到的问题-此时使用的是JDBC" class="headerlink" title="尝试连接数据库查看session遇到的问题,此时使用的是JDBC"></a>尝试连接数据库查看session遇到的问题,此时使用的是JDBC</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.beancreationexception: error creating bean with name &#x27;org.springframework.boot.autoconfigure.session.sessionautoconfiguration$servletsessionrepositoryvalidator&#x27;</span><br></pre></td></tr></table></figure>

<p>解决方案：在pom.xml中添加依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h5 id="基于redis的session配置"><a href="#基于redis的session配置" class="headerlink" title="基于redis的session配置"></a><a href="https://www.baeldung.com/spring-session">基于redis的session配置</a></h5><p>bean factory 初始化失败 ：把starter-data-jpa 改成 starter-data-redis 前者是用于session-jdbc的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>连不上 给redis镜像<a href="https://www.jianshu.com/p/67fc4b1cbe1b">添加配置文件</a> 修改映射端口（见群聊讨论）？？重启 先开redis镜像 再开webpos镜像 又好了</p>
<h5 id="直接配置redis，不使用docker"><a href="#直接配置redis，不使用docker" class="headerlink" title="直接配置redis，不使用docker"></a>直接配置redis，不使用docker</h5><p>redis容器问题太多了 改用直接配置</p>
<p>下载压缩包 make后make install 确认redis-server,redis-cli可用</p>
<p>分节点配置脚本可以参考<a href="https://redis.io/docs/manual/scaling/">官方网站</a></p>
<p>自动化读取各个文件夹中的脚本来构建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for d in ./*/ ; do (cd &quot;$d&quot; &amp;&amp; redis-server ./redis.conf &amp;); done</span><br><span class="line"></span><br><span class="line">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \</span><br><span class="line">--cluster-replicas 1 &amp;</span><br></pre></td></tr></table></figure>

<p>构建之后需要检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster check 127.0.0.1:7000 //example</span><br><span class="line">redis-cli --cluster fix 127.0.0.1:7000 //if something wrong</span><br><span class="line">redis-cli -h localhost -p 7000</span><br><span class="line">keys*</span><br><span class="line">flushdb //清空当前</span><br></pre></td></tr></table></figure>



<h5 id="镜像中连不上集群？"><a href="#镜像中连不上集群？" class="headerlink" title="镜像中连不上集群？"></a>镜像中连不上集群？</h5><p><a href="https://blog.csdn.net/qq_20597727/article/details/85040056">参考</a> 由于在镜像中运行程序，应使用ifconfig查看docker对应的ip，替换127.0.0.1 并且在每个节点的redis.conf中插入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected-mode no</span><br></pre></td></tr></table></figure>

<p>设置后可以在宿主机命令行用redis-cli检查各个节点状态或者查看内容</p>
<h5 id="host-网络？"><a href="#host-网络？" class="headerlink" title="host 网络？"></a>host 网络？</h5><p>待补充</p>
<h5 id="可序列化对象才能写入redis数据库"><a href="#可序列化对象才能写入redis数据库" class="headerlink" title="可序列化对象才能写入redis数据库"></a>可序列化对象才能写入redis数据库</h5><p>出现问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer ; nested exception is java.io.NotSerializableException: com.example.webpos.model.Product] with root cause</span><br><span class="line"></span><br><span class="line">java.io.NotSerializableException: com.example.webpos.model.Product</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询后发现是被写入的对象（包括cart，item，product）应该implements Serializable接口，成为可序列化对象才能写入redis数据库</p>
<h2 id="cache和session"><a href="#cache和session" class="headerlink" title="cache和session"></a>cache和session</h2><p><strong>cache</strong>：product时使用——实际的业务层是在JD 不是原先的serviceImp——用的是另一个数据库</p>
<p>@CacheEvict  清除缓存</p>
<p><strong>session</strong>: 传递cart信息 getAttribute-getCart/setAttribute-changeCart  <strong>在controller中添加 与网页运行有关</strong></p>
<h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p>编写好haproxy.cfg </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defaults</span><br><span class="line">	mode tcp</span><br><span class="line">frontend lb-app-pi</span><br><span class="line">	bind *:8080 #统一对外接口</span><br><span class="line">	default_backend servers</span><br><span class="line">backend servers</span><br><span class="line">	balance roundrobin #轮换方式</span><br><span class="line">	server server1 localhost:8081 # 单独一个服务器的端口 在本次实验中是镜像映射到本机的端口</span><br><span class="line">	server server2 localhost:8082</span><br><span class="line">	server server3 localhost:8083</span><br><span class="line">	server server4 localhost:8084</span><br></pre></td></tr></table></figure>

<p>用以下命令运行对应目录下的该文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">haproxy -f haproxy.cfg</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -nlp //是查看所有的端口占用情况</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop实验一记录</title>
    <url>/post/f141b6ad/</url>
    <content><![CDATA[<h2 id="虚拟机环境准备"><a href="#虚拟机环境准备" class="headerlink" title="虚拟机环境准备"></a>虚拟机环境准备</h2><p>账户设置：采用虚拟机原有设置 没有新建账号</p>
<p>环境变量设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi ~/.bash_profile</span><br><span class="line"></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/bin/java <span class="comment">#需要查询本地Java安装地址 export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64/bin/java //需要查询本地Java安装地址 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/hadoop/hadoop_installs/hadoop-2.7.7</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$JAVA_HOME</span>/lib:.</span><br></pre></td></tr></table></figure>

<p>下载安装ssh 确认启动</p>
<p>（由于和另一个实验环境冲突，尝试了修改，暂时未测试）</p>
<h2 id="Hadoop配置"><a href="#Hadoop配置" class="headerlink" title="Hadoop配置"></a>Hadoop配置</h2><p><a href="https://hadoop.apache.org/docs/r2.7.2/index.html">Apache Hadoop官方文档</a></p>
<p><a href="https://www.w3cschool.cn/hadoop/hadoop_command_reference.html">账户配置和基础指令指导</a></p>
<h3 id="填写配置文件"><a href="#填写配置文件" class="headerlink" title="填写配置文件"></a>填写配置文件</h3><p><a href="https://blog.csdn.net/u013232219/article/details/104429007">https://blog.csdn.net/u013232219/article/details/104429007</a></p>
<p><a href="https://www.jianshu.com/p/2138e473b909">https://www.jianshu.com/p/2138e473b909</a></p>
<p><a href="https://blog.51cto.com/u_13836096/2532831">带参数解读版本</a></p>
<h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#~/.bashrc etc/profile同理</span></span><br><span class="line">sudo vim ~/.bashsrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashsrc <span class="comment">#启动配置</span></span><br></pre></td></tr></table></figure>

<p>HADOOP_HOME应该填写hadoop安装的路径 这样在bash中可以直接使用hadoop命令</p>
<p>jdk 版本比较高 <a href="https://blog.csdn.net/weixin_43968936/article/details/102654353">弹出警告可以忽略不计</a></p>
<p>hadoop需要的java环境变量</p>
<p><code>/usr/lib/jvm/java-11-openjdk-amd64/bin/java</code> 而vscode java 需要的是 <code>/usr/lib/jvm/java-11-openjdk-amd64/bin/java</code></p>
<p>出现问题时可以在安装hadoop的文件夹下的logs中查看，也注意观察终端info信息中显示log写入的地方 出现问题及时打印log查看报错</p>
<h3 id="进行测试实验"><a href="#进行测试实验" class="headerlink" title="进行测试实验"></a>进行测试实验</h3><p> <a href="https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html#copyFromLocal">指令文档</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start-all.sh</span><br><span class="line">hadoop fs -ls /    <span class="comment">#先查看当前hdfs下的文件夹</span></span><br><span class="line">hadoop fs -mkdir /test-in <span class="comment">#创建文件夹</span></span><br><span class="line">hadoop fs -put /home/njucs/BigData/V.html /test-in <span class="comment">#移动文件到hadoop hdfs文件系统中指定文件夹下 注意本地文件夹的名字要写全 如果是在hadoop文件夹中操作的话</span></span><br><span class="line">tail -500 yarn-hadoop-resourcemanager-xxx <span class="comment">#显示前500个字节</span></span><br><span class="line">hadoop dfs -cat /V-out/part-r-00000 <span class="comment">#查看结果</span></span><br></pre></td></tr></table></figure>

<p><a href="https://hijiangtao.github.io/2014/02/19/wordcountrunning/">样例的运行方法指导</a> 样例程序wordcount在hadoop的share/hadoop/mapreduce下</p>
<p>可视化信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:50070/ 查看信息 端口是默认的</span><br><span class="line">http://localhost:8088/cluster  查看集群信息 ip和端口默认 </span><br></pre></td></tr></table></figure>

<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol>
<li><p>不要轻易使用format命令，会导致datanode无法启动，<a href="https://blog.csdn.net/aicyo8644/article/details/102063909?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.topblog&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.topblog">解决方案</a>是检查datanode和namenode的cluster-ID是否一致 最好直接删除</p>
</li>
<li><p>application中找不到正在运行的任务，参考<a href="https://blog.csdn.net/tangtang5156/article/details/40867759">解决方案</a>后，是yarn.xml没设置好</p>
</li>
</ol>
<h2 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h2><p>类别：添加或规范化License信息</p>
<p>位置：<code>pkg/ddc/goosefs/runtime_info.go</code></p>
<p>内容：在该文件头部添加或规范化License信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add upstream https://github.com/fluid-cloudnative/fluid.git</span><br><span class="line">git fetch upstream</span><br><span class="line">git merge upstream/master <span class="comment">#merge远程代码改动</span></span><br></pre></td></tr></table></figure>

<p>调试方法+远程提交方法见Chap4 PPT</p>
<p>主要是熟悉git的开源社区协作方法</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
  <entry>
    <title>NJUCS 各研究组宣讲</title>
    <url>/post/89396cda/</url>
    <content><![CDATA[<h2 id="BigAI"><a href="#BigAI" class="headerlink" title="BigAI"></a>BigAI</h2><p>邮件: <a href="mailto:&#x6c;&#x69;&#x77;&#x75;&#106;&#x75;&#110;&#64;&#110;&#x6a;&#117;&#46;&#101;&#100;&#x75;&#x2e;&#x63;&#110;">&#x6c;&#x69;&#x77;&#x75;&#106;&#x75;&#110;&#64;&#110;&#x6a;&#117;&#46;&#101;&#100;&#x75;&#x2e;&#x63;&#110;</a></p>
<p>主页: <a href="https://cs.nju.edu.cn/lwj">https://cs.nju.edu.cn/lwj</a></p>
<p>大数据机器学习 机器学习算法：存储、计算、通信</p>
<ul>
<li>哈希学习<ul>
<li>哈希函数很关键 哈希值应当保留样本是否相似的特征</li>
<li>实际应用: 行人重识别，自动问答，视频查重</li>
</ul>
</li>
<li>并行与分布式随机学习<ul>
<li>单机器：并行；多机器：分布式</li>
<li>交互协同的开销有时比计算开销更大，是加速的代价</li>
<li>分布式机器学习：数据不出本地（保护隐私等原因），实现可信机器学习</li>
</ul>
</li>
<li>大数据机器学习平台LIBBLE<ul>
<li>机器学习的底层数据平台</li>
</ul>
</li>
</ul>
<p>应用：</p>
<p>智慧医疗</p>
<h2 id="ICS-基础研究和系统工程中心"><a href="#ICS-基础研究和系统工程中心" class="headerlink" title="ICS - 基础研究和系统工程中心"></a>ICS - 基础研究和系统工程中心</h2><p><a href="http://cs.nju.edu.cn/ics">http://cs.nju.edu.cn/ics</a></p>
<p>判断程序的正误？如何根据行为习惯进行推断？高效的多心（并发）问题？</p>
<p>（可见许畅老师的主页）</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418164005445.png" alt="image-20220418164005445"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418164044249.png" alt="image-20220418164044249"></p>
<p><img src="/post/89396cda/191220083\Young&Wild&Free\hexo\source_posts\NJUCS-各研究组宣讲.assets\image-20220418164145804.png" alt="image-20220418164145804"></p>
<p>（见软件所主页）</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418164409172.png" alt="image-20220418164409172"></p>
<ul>
<li>软件工程+机器学习<ul>
<li>软件智能化: 机器编写代码，自动测试等</li>
<li>逻辑的演绎性+学习的归纳性的冲突 SE+AI</li>
</ul>
</li>
</ul>
<p><a href="http://cs.nju.edu.cn/ics">http://cs.nju.edu.cn/ics</a></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418165928416.png" alt="image-20220418165928416"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418170429405.png" alt="image-20220418170429405"></p>
<h2 id="SEG"><a href="#SEG" class="headerlink" title="SEG"></a>SEG</h2><p><a href="http://seg.nju.edu.cn/">http://seg.nju.edu.cn</a></p>
<p>设计开发方法/程序分析/编译优化</p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418171124595.png" alt="image-20220418171124595"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418171902259.png" alt="image-20220418171902259"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418172312609.png" alt="image-20220418172312609"></p>
<p><img src="https://gitee.com/mzl0830/pic-storage/raw/master/image-20220418172344072.png" alt="image-20220418172344072"></p>
<p>学术or工程</p>
<p>下一场4月25日（下周同一时间）</p>
]]></content>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful microPos-AW05</title>
    <url>/post/c689f23c/</url>
    <content><![CDATA[<p><a href="https://github.com/sawork-2022/aw05-August0830">作业项目地址</a></p>
<p>Steps：</p>
<p>REST/micro机制弄大概懂</p>
<p>设计包括cache 断路器机制</p>
<p>Question：</p>
<p>ehcache <a href="https://www.baeldung.com/spring-boot-ehcache">在服务中使用的例子</a> 类似之前 在JDRepostry添加</p>
<p>断路器</p>
<ul>
<li>cart的功能<ul>
<li>初步设想：老师的课堂样例是网页翻页，我的理解是基于一个状态，在进行一个操作之后转移到另一个状态，也就是从一个页面，经过一个点击操作进入另一个页面。而在一定状态下，能够进行的操作是有限的，因此一定可以确定一个页面，即是前一个还是后一个。</li>
<li>REST是没有状态的，即没有session可以存储购物车状态。但对于服务端来说，由于商品数量有限，从任意一个购物车状态能够转移到的另一个购物车状态都是有限的。假设有ABC 三种产品，一开始所有购物车状态是0，则下一种状态只有 A1,B1,C1三种可能。</li>
<li>（果然计算机的本质是状态机！）</li>
</ul>
</li>
</ul>
<p>REST</p>
<p>解决接口不规范的问题</p>
<p>用于发送测试请求：postman</p>
<p>ResponseEntity RESTful架构下返回的标准的数据接口，可以被网页解析；</p>
<p>把数据返回，并且传入http状态代码。</p>
<p>拆解：方法名是名词，method中对应http方法</p>
<p>api：规定程序接口 仿照样例实现</p>
<p><a href="https://en.wikipedia.org/wiki/Data_transfer_object">DTO</a> </p>
<p><a href="https://martinfowler.com/eaaCatalog/dataTransferObject.html">martinFowler的解读</a></p>
<p><a href="https://www.baeldung.com/entity-to-and-from-dto-for-a-java-spring-application">Entity To DTO Conversion for a Spring REST API</a></p>
<p><a href="https://www.baeldung.com/java-dto-pattern">The DTO Pattern (Data Transfer Object)</a></p>
<p>map struct（？）</p>
<p>不同类型的数据进行综合</p>
<p>为了减少传输时间，把多次请求（不同类型）的数据合并在一起传输，mapper主要用来处理此类转换</p>
<p>spring-petclinic-microservice 虽然有dto文件夹 但是并没有用到map 主要是抽离gateway和biz层的数据交换</p>
<p>resttemplate</p>
<p>open-api <a href="https://www.baeldung.com/java-openapi-generator-server">baeldung</a></p>
<p>前端页面（？）—— 先返回json格式的数据</p>
<h2 id="micro-微服务架构"><a href="#micro-微服务架构" class="headerlink" title="micro 微服务架构"></a>micro 微服务架构</h2><p>参考的代码 <a href="https://github.com/spring-petclinic/spring-petclinic-microservices">spring-petclinic-microservices</a>和<a href="https://github.com/spring-petclinic/spring-petclinic-microservices-config">配置文件参考</a>；以及<a href="https://github.com/paulc4/microservices-demo">microservice-demo</a></p>
<h3 id="discovery-eureka"><a href="#discovery-eureka" class="headerlink" title="discovery/eureka"></a>discovery/eureka</h3><h3 id="eureka-server"><a href="#eureka-server" class="headerlink" title="eureka server"></a>eureka server</h3><p>没有采用远程fetch的形式，直接做了本地配置。</p>
<p>对于eureka的配置，可以参考spring关于eureka的<a href="https://spring.io/guides/gs/service-registration-and-discovery/">官方文档</a>。其中提供了在start.io建立eureka项目的方式。可以直接使用，对于已经有配置文件的本项目来说，复制粘贴pom中的内容即可（关键是要包含netflix-eureka的依赖）。启动时记得添加@EnableEurekaServer的标注。</p>
<p>yml文件是对于discovery的配置，作为一个独立的服务配置。如果不是默认application.yml的命名方式，需要在mian函数中额外指明。**并且不需要加后缀yml!**（遇到问题记得检查文件是否生效）</p>
<p>如果yml没有配置成功，默认情况下eureka会把自身注册，就会出现如下报错：</p>
<p><code>com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server</code></p>
<p>即一个逻辑死循环，因此需要仿照样例将 <code>registerWithEureka</code>,<code>fetchRegistry</code>设置为false。</p>
<h3 id="other-server"><a href="#other-server" class="headerlink" title="other server"></a>other server</h3><p><a href="https://cloud.spring.io/spring-cloud-netflix/multi/multi__service_discovery_eureka_clients.html">简单教程</a></p>
<p>记得在yml文件中添加eureka，服务的application类中启用@EnableDiscoveryClient，并且在pom中添加如下依赖（注意starter不同！）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>调试中： rest/mvc架构和gateway不共存</p>
<p>如果上层文件夹中pom文件已经有依赖资源，在子层中再次添加依赖需要指明版本。</p>
<p>如果log中出现 <code>Registering application GATEWAY with eureka with status UP</code>，再检查eureka，一般是成功注册了。</p>
<p><strong>配置服务的一般步骤: 依赖+注解+运行检查</strong></p>
<p>如果已有文件中出现冲突，如出现以下报错即是spring-boot-starter-web和spring-cloud-starter-netflix-eureka-client版本冲突，</p>
<p><code>[spring boot classnotfound org.springframework.boot.Bootstrapper while staring application](https://stackoverflow.com/questions/65917014/spring-boot-classnotfound-org-springframework-boot-bootstrapper-while-staring-ap)</code></p>
<p>可以在<a href="https://start.spring.io/">自动生成项目文件的spring官方网站</a>同时选中所需的依赖，然后进行替换。此处是添加了dependencyManagement解决的。</p>
<h2 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h2><p>最后做 其他的可以先做独立应用？——应用本身应该是能够在端口被访问的</p>
<p>配置文件中 关于spring的部分，配置了thymeleaf相关，即网页显示</p>
<p>添加断路器 在转发需求的时候</p>
<p>两部分，一部分保证在eureka登记，另一部分实现转发</p>
<p><a href="https://www.javainuse.com/spring/cloud-gateway">转发-简单样例</a> <a href="https://spring.io/guides/gs/gateway/">转发-官方手册</a></p>
<p><a href="https://stackoverflow.com/questions/60705382/mono-class-in-java-what-is-and-when-to-use">Mono&lt;T&gt;</a> 处理流式数据</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>NJUCS</tag>
      </tags>
  </entry>
</search>
